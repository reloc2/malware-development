<!DOCTYPE html>
<html class="dark"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie-edge">
        <meta name="csrf-token" content="aHzsquahomm2Bo0anbhiCgbZ1siEurCTfma8L6Pk">
        <link rel="stylesheet" href="Payload%20Encryption%20-%20AES%20Encryption_files/template.css">
        <link rel="shortcut icon" href="#favicon.ico">
        <!-- fontawesome for icons -->
        <link rel="stylesheet" href="Payload%20Encryption%20-%20AES%20Encryption_files/font-awesome.min.css">
        <!-- google fonts -->
        <link rel="preconnect" href="https://fonts.gstatic.com/">
        <link href="Payload%20Encryption%20-%20AES%20Encryption_files/css2.css" rel="stylesheet">
        <link href="Payload%20Encryption%20-%20AES%20Encryption_files/css2_002.css" rel="stylesheet">
        <title>Payload Encryption - AES Encryption</title>
        <!-- Custom css files, order matters -->
        <link rel="preload" as="style" href="Payload%20Encryption%20-%20AES%20Encryption_files/app.fdbb573b.css"><link rel="stylesheet" href="Payload%20Encryption%20-%20AES%20Encryption_files/app.fdbb573b.css"><link rel="stylesheet" href="Payload%20Encryption%20-%20AES%20Encryption_files/viewer.css">
    </head>
    <body>
        <nav id="navbar" class="px-2 sm:px-4 py-2.5 bg-gray-900 sticky hidden">
    <div class="container flex flex-wrap justify-between mx-auto">
      <a data-target="_self" href="#" class="flex items-center">
        <div class="main-logo flex flex-row items-center">
            <span class="text-xl logo-font text-white">MALDEV</span>
            <img class="w-[25px] mx-2 relative bottom-1" src="Payload%20Encryption%20-%20AES%20Encryption_files/logo-bug-2.png" alt="Logo">   
            <span class="text-xl logo-font text-white">ACADEMY</span>          
        </div>
      </a>
      <button data-collapse-toggle="navbar-default" id="navbar-phone-btn" type="button" class="inline-flex items-center p-2 ml-3 text-sm text-gray-500 rounded-lg md:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="navbar-default" aria-expanded="false">
        <span class="sr-only">Open main menu</span>
        <svg class="w-6 h-6" aria-hidden="true" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg>
      </button>
      <div class="hidden w-full md:block md:w-auto" id="navbar-default">
        <ul class="flex flex-col items-center p-4 mt-4 bg-gray-50 rounded-lg border border-gray-100 md:flex-row md:space-x-8 md:mt-0 md:text-sm md:font-medium md:border-0 md:bg-white dark:bg-gray-800 md:dark:bg-gray-900 dark:border-gray-700">
          <li>
            <a data-target="_self" href="#" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Home</a>
          </li>
          <li>
            <a data-target="_self" href="#faq" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">FAQ</a>
          </li>
          <li>
            <a data-target="_self" href="#syllabus" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Syllabus</a>
          </li>
                              <li>
            <a data-target="_self" href="#pricing" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Pricing</a>
          </li>
                                        <li>
            <a data-target="_self" href="#profile" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Profile</a>
          </li>
          <li>
            <form action="#logout" method="POST">
            <input type="hidden" name="_token" value="aHzsquahomm2Bo0anbhiCgbZ1siEurCTfma8L6Pk">              <button type="submit" class="block py-2 pr-4 pl-3 text-gray-400 md:p-0">Logout</button>
            </form>
          </li>
          <li class="mt-4 md:mt-0">
            <a data-target="_self" href="#modules" class="text-white bg-blue-700 hover:bg-blue-800 font-medium rounded-lg text-sm px-5 py-2.5 text-center md:mr-3 mr-0 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800">Modules</a>
          </li>
                  </ul>
      </div>
    </div>
  </nav>        <div class="bg-gray-900 p-4">
    <div class="flex">
        <div class="md:flex-row flex-col flex md:items-center w-1/2 bg-gray-700 border-l border-t border-gray-600 pl-4 pt-2 pb-2 rounded-tl">
            <div>
                Module 19 - Payload Encryption - AES Encryption
            </div>
            <div class="ml-2 w-4 h-4 bg-green-800 rounded-full"></div>
        </div>
        <div class="flex justify-end items-center w-1/2 bg-gray-700 pr-4 pt-2 pb-2 rounded-tr border-t border-r border-gray-600">
            <div class="enlarge-container pr-4">
                <img src="Payload%20Encryption%20-%20AES%20Encryption_files/enlarge.svg" onclick="toggleScreenWidth()" class="hover:bg-gray-600 rounded-sm cursor-pointer" id="enlargeToggle" alt="Screen Width" width="20px">
            </div>
            <div class="objectives-container pr-4">
                <img src="Payload%20Encryption%20-%20AES%20Encryption_files/objectives.svg" onclick="toggleObjectives()" class="hover:bg-gray-600 cursor-pointer" id="objectivesToggle" alt="Objectives" width="20px">
            </div>
            <div class="terminal-container  pr-4 ">
                <img src="Payload%20Encryption%20-%20AES%20Encryption_files/ide.svg" onclick="toggleIde()" class="hover:bg-gray-600 rounded-sm cursor-pointer" id="terminalToggle" alt="Terminal" width="22px">
            </div>
                                    <div class="dl-container">
                <a href="#download/file/Aes" target="_blank">
                    <img src="Payload%20Encryption%20-%20AES%20Encryption_files/dl.svg" class="hover:bg-gray-600 rounded-full cursor-pointer" alt="Download" width="20px">
                </a>
            </div>
                                </div>
    </div>
    <div id="height-container" class="flex h-full min-h-[800px]">
        <div class="flex max-w-full min-w-full">
            <div id="description-container" class="viewer code-description h-full bg-gray-800 p-4 border-r border-l border-b border-gray-600 px-5 md:px-10 lg:px-20 w-full"><div class="toastui-editor-contents" style="overflow-wrap: break-word;">
            <h2>Payload Encryption - AES Encryption</h2>
<h3>Advanced Encryption Standard</h3>
<p>This module discusses a more secure encryption algorithm, Advanced 
Encryption Standard (AES). It is a symmetric-key algorithm, meaning the 
same key is used for both encryption and decryption. There are several 
types of AES encryption such as AES128, AES192, and AES256 that vary by 
the key size. For example, AES128 uses a 128-bit key whereas AES256 uses
 a 256-bit key.</p>
<p>Additionally, AES can use different <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation" target="_blank">block cipher modes of operation</a>
 such as CBC and GCM. Depending on the AES mode, the AES algorithm will 
require an additional component along with the encryption key called an <a href="https://en.wikipedia.org/wiki/Initialization_vector" target="_blank">Initialization Vector</a> or IV. Providing an IV provides an additional layer of security to the encryption process.</p>
<p>Regardless of the chosen AES type, AES always requires a 128-bit 
input and produces a 128-bit output blocks. The important thing to keep 
in mind is that the input data should be multiples of 16 bytes (128 
bits). If the payload being encrypted is not a multiple of 16 bytes then
 padding is required to increase the size of the payload and make it a 
multiple of 16 bytes.</p>
<p>The module provides 2 code samples that use AES256-CBC. The first 
sample is achieved through the bCrypt library which utilizes WinAPIs and
 the second sample uses <a href="https://github.com/kokke/tiny-AES-c" target="_blank">Tiny Aes Project</a>.
 Note that since the AES256-CBC is being used, the code uses a 32-byte 
key and a 16-byte IV. Again, this would vary if the code used a 
different AES type or mode.</p>
<h3>AES Using WinAPIs (bCrypt Library)</h3>
<p>There are several ways to implement the AES encryption algorithm. This section utilizes the bCrypt library (<a href="https://learn.microsoft.com/en-us/windows/win32/api/bcrypt/" target="_blank">bcrypt.h</a>)
 to perform AES encryption. This section will explain the code which is 
available for download as usual at the top right of the module box.</p>
<h4>AES Structure</h4>
<p>To start, an <code>AES</code> structure is created which contains the required data to perform encryption and decryption.</p>
<pre><code>typedef struct _AES {

	PBYTE	pPlainText;         // base address of the plain text data 
	DWORD	dwPlainSize;        // size of the plain text data

	PBYTE	pCipherText;        // base address of the encrypted data	
	DWORD	dwCipherSize;       // size of it (this can change from dwPlainSize in case there was padding)

	PBYTE	pKey;               // the 32 byte key
	PBYTE	pIv;                // the 16 byte iv

} AES, *PAES;
</code></pre>
<h4>SimpleEncryption Wrapper</h4>
<p>The <code>SimpleEncryption</code> function has six parameters that are used to initialize the <code>AES</code> structure. Once the structure is initialized, the function will call <code>InstallAesEncryption</code> to perform the AES encryption process. Note that two of its parameters are <code>OUT</code> parameters, therefore the function returns the following:</p>
<ul>
<li>
<p><code>pCipherTextData</code> - A pointer to the newly allocated heap buffer which contains the ciphertext data.</p>
</li>
<li>
<p><code>sCipherTextSize</code> - The size of the ciphertext buffer.</p>
</li>
</ul>
<p>The function returns <code>TRUE</code> if the <code>InstallAesEncryption</code> succeeds, otherwise <code>FALSE</code>.</p>
<pre><code>// Wrapper function for InstallAesEncryption that makes things easier
BOOL SimpleEncryption(IN PVOID pPlainTextData, IN DWORD sPlainTextSize, IN PBYTE pKey, IN PBYTE pIv, OUT PVOID* pCipherTextData, OUT DWORD* sCipherTextSize) {

	if (pPlainTextData == NULL || sPlainTextSize == NULL || pKey == NULL || pIv == NULL)
		return FALSE;
	
	// Intializing the struct
	AES Aes = {
		.pKey        = pKey,
		.pIv         = pIv,
		.pPlainText  = pPlainTextData,
		.dwPlainSize = sPlainTextSize
	};

	if (!InstallAesEncryption(&amp;Aes)) {
		return FALSE;
	}

	// Saving output
	*pCipherTextData = Aes.pCipherText;
	*sCipherTextSize = Aes.dwCipherSize;

	return TRUE;
}
</code></pre>
<h4>SimpleDecryption Wrapper</h4>
<p>The <code>SimpleDecryption</code> function also has six parameters and behaves similarly to <code>SimpleEncryption</code> with the difference being that it calls the <code>InstallAesDecryption</code> function and it returns two different values.</p>
<ul>
<li>
<p><code>pPlainTextData</code> - A pointer to the newly allocated heap buffer which contains the plaintext data.</p>
</li>
<li>
<p><code>sPlainTextSize</code> - The size of the plaintext buffer.</p>
</li>
</ul>
<p>The function returns <code>TRUE</code> if the <code>InstallAesDecryption</code> succeeds, otherwise <code>FALSE</code>.</p>
<pre><code>// Wrapper function for InstallAesDecryption that make things easier
BOOL SimpleDecryption(IN PVOID pCipherTextData, IN DWORD sCipherTextSize, IN PBYTE pKey, IN PBYTE pIv, OUT PVOID* pPlainTextData, OUT DWORD* sPlainTextSize) {

	if (pCipherTextData == NULL || sCipherTextSize == NULL || pKey == NULL || pIv == NULL)
		return FALSE;

	// Intializing the struct
	AES Aes = {
		.pKey          = pKey,
		.pIv           = pIv,
		.pCipherText   = pCipherTextData,
		.dwCipherSize  = sCipherTextSize
	};

	if (!InstallAesDecryption(&amp;Aes)) {
		return FALSE;
	}

	// Saving output
	*pPlainTextData = Aes.pPlainText;
	*sPlainTextSize = Aes.dwPlainSize;

	return TRUE;
}
</code></pre>
<h4>Cryptographic Next Generation</h4>
<p>Cryptographic Next Generation (CNG) provides a set of cryptographic 
functions that can be used by applications of the OS. CNG provides a 
standardized interface for cryptographic operations, making it easier 
for developers to implement security features in their applications. 
Both <code>InstallAesEncryption</code> and <code>InstallAesDecryption</code> functions make use of CNG.</p>
<p>More information about CNG is available <a href="https://learn.microsoft.com/en-us/windows/win32/seccng/cng-portal" target="_blank">here</a>.</p>
<h4>InstallAesEncryption Function</h4>
<p>The <code>InstallAesEncryption</code> is the function that performs AES encryption. The function has one parameter, <code>PAES</code>, which is a pointer to a populated <code>AES</code> structure. The bCrypt library functions used in the function are shown below.</p>
<ul>
<li>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider" target="_blank">BCryptOpenAlgorithmProvider</a> - Used to load the <a href="https://learn.microsoft.com/en-us/windows/win32/seccng/cng-algorithm-identifiers" target="_blank">BCRYPT_AES_ALGORITHM</a> Cryptographic Next Generation (CNG) provider to enable the use of cryptographic functions.</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgetproperty" target="_blank">BCryptGetProperty</a> - This function is called twice, the first time to retrieve the value of <a href="https://learn.microsoft.com/en-us/windows/win32/seccng/cng-property-identifiers" target="_blank">BCRYPT_OBJECT_LENGTH</a> and the second time to fetch the value of <a href="https://learn.microsoft.com/en-us/windows/win32/seccng/cng-property-identifiers" target="_blank">BCRYPT_BLOCK_LENGTH</a> property identifiers.</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptsetproperty" target="_blank">BCryptSetProperty</a> - Used to initialize the <code>BCRYPT_OBJECT_LENGTH</code> property identifier.</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgeneratesymmetrickey" target="_blank">BCryptGenerateSymmetricKey</a> - Used to create a key object from the input AES key specified.</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptencrypt" target="_blank">BCryptEncrypt</a>
 - Used to encrypt a specified block of data. This function is called 
twice, the first time retrieves the size of the encrypted data to 
allocate a heap buffer of that size. The second call encrypts the data 
and stores the ciphertext in the allocated heap.</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptdestroykey" target="_blank">BCryptDestroyKey</a> - Used to clean up by destroying the key object created using <code>BCryptGenerateSymmetricKey</code>.</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptclosealgorithmprovider" target="_blank">BCryptCloseAlgorithmProvider</a> - Used to clean up by closing the object handle of the algorithm provider created earlier using <code>BCryptOpenAlgorithmProvider</code>.</p>
</li>
</ul>
<p>The function returns <code>TRUE</code> if it successfully encrypts the payload, otherwise <code>FALSE</code>.</p>
<pre><code>// The encryption implementation
BOOL InstallAesEncryption(PAES pAes) {

  BOOL                  bSTATE           = TRUE;
  BCRYPT_ALG_HANDLE     hAlgorithm       = NULL;
  BCRYPT_KEY_HANDLE     hKeyHandle       = NULL;

  ULONG       		cbResult         = NULL;
  DWORD       		dwBlockSize      = NULL;
  
  DWORD       		cbKeyObject      = NULL;
  PBYTE       		pbKeyObject      = NULL;

  PBYTE      		pbCipherText     = NULL;
  DWORD       		cbCipherText     = NULL,


  // Intializing "hAlgorithm" as AES algorithm Handle
  STATUS = BCryptOpenAlgorithmProvider(&amp;hAlgorithm, BCRYPT_AES_ALGORITHM, NULL, 0);
  if (!NT_SUCCESS(STATUS)) {
    	printf("[!] BCryptOpenAlgorithmProvider Failed With Error: 0x%0.8X \n", STATUS);
    	bSTATE = FALSE; goto _EndOfFunc;
  }

  // Getting the size of the key object variable pbKeyObject. This is used by the BCryptGenerateSymmetricKey function later 
  STATUS = BCryptGetProperty(hAlgorithm, BCRYPT_OBJECT_LENGTH, (PBYTE)&amp;cbKeyObject, sizeof(DWORD), &amp;cbResult, 0);
  if (!NT_SUCCESS(STATUS)) {
    	printf("[!] BCryptGetProperty[1] Failed With Error: 0x%0.8X \n", STATUS);
    	bSTATE = FALSE; goto _EndOfFunc;
  }

  // Getting the size of the block used in the encryption. Since this is AES it must be 16 bytes.
  STATUS = BCryptGetProperty(hAlgorithm, BCRYPT_BLOCK_LENGTH, (PBYTE)&amp;dwBlockSize, sizeof(DWORD), &amp;cbResult, 0);
  if (!NT_SUCCESS(STATUS)) {
   	printf("[!] BCryptGetProperty[2] Failed With Error: 0x%0.8X \n", STATUS);
    	bSTATE = FALSE; goto _EndOfFunc;
  }

  // Checking if block size is 16 bytes
  if (dwBlockSize != 16) {
    	bSTATE = FALSE; goto _EndOfFunc;
  }

  // Allocating memory for the key object 
  pbKeyObject = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbKeyObject);
  if (pbKeyObject == NULL) {
    	bSTATE = FALSE; goto _EndOfFunc;
  }

  // Setting Block Cipher Mode to CBC. This uses a 32 byte key and a 16 byte IV.
  STATUS = BCryptSetProperty(hAlgorithm, BCRYPT_CHAINING_MODE, (PBYTE)BCRYPT_CHAIN_MODE_CBC, sizeof(BCRYPT_CHAIN_MODE_CBC), 0);
  if (!NT_SUCCESS(STATUS)) {
    	printf("[!] BCryptSetProperty Failed With Error: 0x%0.8X \n", STATUS);
    	bSTATE = FALSE; goto _EndOfFunc;
  }

  // Generating the key object from the AES key "pAes-&gt;pKey". The output will be saved in pbKeyObject and will be of size cbKeyObject 
  STATUS = BCryptGenerateSymmetricKey(hAlgorithm, &amp;hKeyHandle, pbKeyObject, cbKeyObject, (PBYTE)pAes-&gt;pKey, KEYSIZE, 0);
  if (!NT_SUCCESS(STATUS)) {
    	printf("[!] BCryptGenerateSymmetricKey Failed With Error: 0x%0.8X \n", STATUS);
    	bSTATE = FALSE; goto _EndOfFunc;
  }

  // Running BCryptEncrypt first time with NULL output parameters to retrieve the size of the output buffer which is saved in cbCipherText
  STATUS = BCryptEncrypt(hKeyHandle, (PUCHAR)pAes-&gt;pPlainText, (ULONG)pAes-&gt;dwPlainSize, NULL, pAes-&gt;pIv, IVSIZE, NULL, 0, &amp;cbCipherText, BCRYPT_BLOCK_PADDING);
  if (!NT_SUCCESS(STATUS)) {
    	printf("[!] BCryptEncrypt[1] Failed With Error: 0x%0.8X \n", STATUS);
    	bSTATE = FALSE; goto _EndOfFunc;
  }

  // Allocating enough memory for the output buffer, cbCipherText
  pbCipherText = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbCipherText);
  if (pbCipherText == NULL) {
    	bSTATE = FALSE; goto _EndOfFunc;
  }

  // Running BCryptEncrypt again with pbCipherText as the output buffer
  STATUS = BCryptEncrypt(hKeyHandle, (PUCHAR)pAes-&gt;pPlainText, (ULONG)pAes-&gt;dwPlainSize, NULL, pAes-&gt;pIv, IVSIZE, pbCipherText, cbCipherText, &amp;cbResult, BCRYPT_BLOCK_PADDING);
  if (!NT_SUCCESS(STATUS)) {
    	printf("[!] BCryptEncrypt[2] Failed With Error: 0x%0.8X \n", STATUS);
    	bSTATE = FALSE; goto _EndOfFunc;
  }


  // Clean up
_EndOfFunc:
  if (hKeyHandle) 
    	BCryptDestroyKey(hKeyHandle);
  if (hAlgorithm) 
    	BCryptCloseAlgorithmProvider(hAlgorithm, 0);
  if (pbKeyObject) 
    	HeapFree(GetProcessHeap(), 0, pbKeyObject);
  if (pbCipherText != NULL &amp;&amp; bSTATE) {
        // If everything worked, save pbCipherText and cbCipherText 
        pAes-&gt;pCipherText 	= pbCipherText;
        pAes-&gt;dwCipherSize 	= cbCipherText;
  }
  return bSTATE;
}
</code></pre>
<h4>InstallAesDecryption Function</h4>
<p>The <code>InstallAesDecryption</code> is the function that performs AES decryption. The function has one parameter, <code>PAES</code>, which is a pointer to a populated <code>AES</code> structure. The bCrypt library functions used in the function are the same as in the <code>InstallAesEncryption</code> function above, with the only difference being that <code>BCryptDecrypt</code> is used instead of <code>BCryptEncrypt</code>.</p>
<ul>
<li>
<a href="https://learn.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptdecrypt" target="_blank">BCryptDecrypt</a>
 - Used to decrypt a specified block of data. This function is called 
twice, the first time retrieves the size of the decrypted data to 
allocate a heap buffer of that size. The second call decrypts the data 
and stores the plaintext data in the allocated heap.</li>
</ul>
<p>The function returns <code>TRUE</code> if it successfully decrypts the payload, otherwise <code>FALSE</code>.</p>
<pre><code>// The decryption implementation
BOOL InstallAesDecryption(PAES pAes) {

  BOOL                  bSTATE          = TRUE;
  BCRYPT_ALG_HANDLE     hAlgorithm      = NULL;
  BCRYPT_KEY_HANDLE     hKeyHandle      = NULL;

  ULONG                 cbResult        = NULL;
  DWORD                 dwBlockSize     = NULL;
  
  DWORD                 cbKeyObject     = NULL;
  PBYTE                 pbKeyObject     = NULL;

  PBYTE                 pbPlainText     = NULL;
  DWORD                 cbPlainText     = NULL,

  // Intializing "hAlgorithm" as AES algorithm Handle
  STATUS = BCryptOpenAlgorithmProvider(&amp;hAlgorithm, BCRYPT_AES_ALGORITHM, NULL, 0);
  if (!NT_SUCCESS(STATUS)) {
    	printf("[!] BCryptOpenAlgorithmProvider Failed With Error: 0x%0.8X \n", STATUS);
    	bSTATE = FALSE; goto _EndOfFunc;
  }

  // Getting the size of the key object variable pbKeyObject. This is used by the BCryptGenerateSymmetricKey function later
  STATUS = BCryptGetProperty(hAlgorithm, BCRYPT_OBJECT_LENGTH, (PBYTE)&amp;cbKeyObject, sizeof(DWORD), &amp;cbResult, 0);
  if (!NT_SUCCESS(STATUS)) {
    	printf("[!] BCryptGetProperty[1] Failed With Error: 0x%0.8X \n", STATUS);
    	bSTATE = FALSE; goto _EndOfFunc;
  }
  
  // Getting the size of the block used in the encryption. Since this is AES it should be 16 bytes.
  STATUS = BCryptGetProperty(hAlgorithm, BCRYPT_BLOCK_LENGTH, (PBYTE)&amp;dwBlockSize, sizeof(DWORD), &amp;cbResult, 0);
  if (!NT_SUCCESS(STATUS)) {
    	printf("[!] BCryptGetProperty[2] Failed With Error: 0x%0.8X \n", STATUS);
    	bSTATE = FALSE; goto _EndOfFunc;
  }
  
  // Checking if block size is 16 bytes
  if (dwBlockSize != 16) {
    	bSTATE = FALSE; goto _EndOfFunc;
  }
  
  // Allocating memory for the key object 
  pbKeyObject = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbKeyObject);
  if (pbKeyObject == NULL) {
    	bSTATE = FALSE; goto _EndOfFunc;
  }
  
  // Setting Block Cipher Mode to CBC. This uses a 32 byte key and a 16 byte IV.
  STATUS = BCryptSetProperty(hAlgorithm, BCRYPT_CHAINING_MODE, (PBYTE)BCRYPT_CHAIN_MODE_CBC, sizeof(BCRYPT_CHAIN_MODE_CBC), 0);
  if (!NT_SUCCESS(STATUS)) {
    	printf("[!] BCryptSetProperty Failed With Error: 0x%0.8X \n", STATUS);
    	bSTATE = FALSE; goto _EndOfFunc;
  }
  
  // Generating the key object from the AES key "pAes-&gt;pKey". The output will be saved in pbKeyObject of size cbKeyObject 
  STATUS = BCryptGenerateSymmetricKey(hAlgorithm, &amp;hKeyHandle, pbKeyObject, cbKeyObject, (PBYTE)pAes-&gt;pKey, KEYSIZE, 0);
  if (!NT_SUCCESS(STATUS)) {
    	printf("[!] BCryptGenerateSymmetricKey Failed With Error: 0x%0.8X \n", STATUS);
    	bSTATE = FALSE; goto _EndOfFunc;
  }

  // Running BCryptDecrypt first time with NULL output parameters to retrieve the size of the output buffer which is saved in cbPlainText
  STATUS = BCryptDecrypt(hKeyHandle, (PUCHAR)pAes-&gt;pCipherText, (ULONG)pAes-&gt;dwCipherSize, NULL, pAes-&gt;pIv, IVSIZE, NULL, 0, &amp;cbPlainText, BCRYPT_BLOCK_PADDING);
  if (!NT_SUCCESS(STATUS)) {
    	printf("[!] BCryptDecrypt[1] Failed With Error: 0x%0.8X \n", STATUS);
    	bSTATE = FALSE; goto _EndOfFunc;
  }
  
  // Allocating enough memory for the output buffer, cbPlainText
  pbPlainText = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbPlainText);
  if (pbPlainText == NULL) {
    	bSTATE = FALSE; goto _EndOfFunc;
  }
  
  // Running BCryptDecrypt again with pbPlainText as the output buffer
  STATUS = BCryptDecrypt(hKeyHandle, (PUCHAR)pAes-&gt;pCipherText, (ULONG)pAes-&gt;dwCipherSize, NULL, pAes-&gt;pIv, IVSIZE, pbPlainText, cbPlainText, &amp;cbResult, BCRYPT_BLOCK_PADDING);
  if (!NT_SUCCESS(STATUS)) {
    	printf("[!] BCryptDecrypt[2] Failed With Error: 0x%0.8X \n", STATUS);
    	bSTATE = FALSE; goto _EndOfFunc;
  }

  // Clean up
_EndOfFunc:
  if (hKeyHandle)
    	BCryptDestroyKey(hKeyHandle);
  if (hAlgorithm)
    	BCryptCloseAlgorithmProvider(hAlgorithm, 0);
  if (pbKeyObject)
    	HeapFree(GetProcessHeap(), 0, pbKeyObject);
  if (pbPlainText != NULL &amp;&amp; bSTATE) {
        // if everything went well, we save pbPlainText and cbPlainText
        pAes-&gt;pPlainText   = pbPlainText;
        pAes-&gt;dwPlainSize  = cbPlainText;
  }
  return bSTATE;

}
</code></pre>
<h4>Additional Helper Functions</h4>
<p>The code also includes two small helper functions as well, <code>PrintHexData</code> and <code>GenerateRandomBytes</code>.</p>
<p>The first function, <code>PrintHexData</code>, prints an input buffer as a char array in C syntax to the console.</p>
<pre><code>// Print the input buffer as a hex char array
VOID PrintHexData(LPCSTR Name, PBYTE Data, SIZE_T Size) {

  printf("unsigned char %s[] = {", Name);

  for (int i = 0; i &lt; Size; i++) {
    	if (i % 16 == 0)
      	    printf("\n\t");
	    
    	if (i &lt; Size - 1) {
            printf("0x%0.2X, ", Data[i]);
    	else
      	    printf("0x%0.2X ", Data[i]);
  }

  printf("};\n\n\n");
  
}
</code></pre>
<p>The other function, <code>GenerateRandomBytes</code>, fills up an input buffer with random bytes which in this case is used to generate a random key and IV.</p>
<pre><code>// Generate random bytes of size sSize
VOID GenerateRandomBytes(PBYTE pByte, SIZE_T sSize) {

  for (int i = 0; i &lt; sSize; i++) {
    	pByte[i] = (BYTE)rand() % 0xFF;
  }

}
</code></pre>
<h4>Padding</h4>
<p>Both <code>InstallAesEncryption</code> and <code>InstallAesDecryption</code> functions use the <code>BCRYPT_BLOCK_PADDING</code> flag with the <code>BCryptEncrypt</code> and <code>BCryptDecrypt</code>
 bcrypt functions respectively, which will automatically pad the input 
buffer, if required, to be a multiple of 16 bytes, solving the AES 
padding issue.</p>
<h4>Main Function - Encryption</h4>
<p>The main function below is used to perform the encryption routine on an array of plaintext data.</p>
<pre><code>// The plaintext, in hex format, that will be encrypted
// this is the following string in hex "This is a plain text string, we'll try to encrypt/decrypt !"
unsigned char Data[] = {
	0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x70, 0x6C,
	0x61, 0x69, 0x6E, 0x20, 0x74, 0x65, 0x78, 0x74, 0x20, 0x73, 0x74, 0x72,
	0x69, 0x6E, 0x67, 0x2C, 0x20, 0x77, 0x65, 0x27, 0x6C, 0x6C, 0x20, 0x74,
	0x72, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x65, 0x6E, 0x63, 0x72, 0x79, 0x70,
	0x74, 0x2F, 0x64, 0x65, 0x63, 0x72, 0x79, 0x70, 0x74, 0x20, 0x21
};

int main() {

	BYTE pKey [KEYSIZE];                    // KEYSIZE is 32 bytes
	BYTE pIv [IVSIZE];                      // IVSIZE is 16 bytes

	srand(time(NULL));                      // The seed to generate the key. This is used to further randomize the key.
	GenerateRandomBytes(pKey, KEYSIZE);     // Generating a key with the helper function
	
	srand(time(NULL) ^ pKey[0]);            // The seed to generate the IV. Use the first byte of the key to add more randomness.
	GenerateRandomBytes(pIv, IVSIZE);       // Generating the IV with the helper function

	// Printing both key and IV onto the console 
	PrintHexData("pKey", pKey, KEYSIZE);
	PrintHexData("pIv", pIv, IVSIZE);

	// Defining two variables the output buffer and its respective size which will be used in SimpleEncryption
	PVOID pCipherText = NULL;
	DWORD dwCipherSize = NULL;
	
	// Encrypting
	if (!SimpleEncryption(Data, sizeof(Data), pKey, pIv, &amp;pCipherText, &amp;dwCipherSize)) {
		return -1;
	}

	// Print the encrypted buffer as a hex array
	PrintHexData("CipherText", pCipherText, dwCipherSize);
	
	// Clean up
	HeapFree(GetProcessHeap(), 0, pCipherText);
	system("PAUSE");
	return 0;
}
</code></pre>
<p><img src="Payload%20Encryption%20-%20AES%20Encryption_files/encryption-new-225952410-4a747a9a-ef94-479c-be3b-d6ae5e8de27.png" alt="image"></p>
<h4>Main Function - Decryption</h4>
<p>The main function below is used to perform the decryption routine. 
The decryption routine requires the decryption key, IV and ciphertext.</p>
<pre><code>// the key printed to the screen
unsigned char pKey[] = {
		0x3E, 0x31, 0xF4, 0x00, 0x50, 0xB6, 0x6E, 0xB8, 0xF6, 0x98, 0x95, 0x27, 0x43, 0x27, 0xC0, 0x55,
		0xEB, 0xDB, 0xE1, 0x7F, 0x05, 0xFE, 0x65, 0x6D, 0x0F, 0xA6, 0x5B, 0x00, 0x33, 0xE6, 0xD9, 0x0B };

// the iv printed to the screen
unsigned char pIv[] = {
		0xB4, 0xC8, 0x1D, 0x1D, 0x14, 0x7C, 0xCB, 0xFA, 0x07, 0x42, 0xD9, 0xED, 0x1A, 0x86, 0xD9, 0xCD };


// the encrypted buffer printed to the screen, which is:
unsigned char CipherText[] = {
		0x97, 0xFC, 0x24, 0xFE, 0x97, 0x64, 0xDF, 0x61, 0x81, 0xD8, 0xC1, 0x9E, 0x23, 0x30, 0x79, 0xA1,
		0xD3, 0x97, 0x5B, 0xAE, 0x29, 0x7F, 0x70, 0xB9, 0xC1, 0xEC, 0x5A, 0x09, 0xE3, 0xA4, 0x44, 0x67,
		0xD6, 0x12, 0xFC, 0xB5, 0x86, 0x64, 0x0F, 0xE5, 0x74, 0xF9, 0x49, 0xB3, 0x0B, 0xCA, 0x0C, 0x04,
		0x17, 0xDB, 0xEF, 0xB2, 0x74, 0xC2, 0x17, 0xF6, 0x34, 0x60, 0x33, 0xBA, 0x86, 0x84, 0x85, 0x5E };

int main() {

	// Defining two variables the output buffer and its respective size which will be used in SimpleDecryption
	PVOID	pPlaintext  = NULL;
	DWORD	dwPlainSize = NULL;

	// Decrypting
	if (!SimpleDecryption(CipherText, sizeof(CipherText), pKey, pIv, &amp;pPlaintext, &amp;dwPlainSize)) {
		return -1;
	}
	
	// Printing the decrypted data to the screen in hex format
	PrintHexData("PlainText", pPlaintext, dwPlainSize);
	
	// this will print: "This is a plain text string, we'll try to encrypt/decrypt !"
	printf("Data: %s \n", pPlaintext);
	
	// Clean up
	HeapFree(GetProcessHeap(), 0, pPlaintext);
	system("PAUSE");
	return 0;
}

</code></pre>
<p><img src="Payload%20Encryption%20-%20AES%20Encryption_files/encryption-new-225953480-03161b1a-119f-4c97-9b9e-11745047a21.png" alt="image"></p>
<h4>bCrypt Library Drawbacks</h4>
<p>One of the primary drawbacks of using the method outlined above to 
implement AES encryption is that the usage of the cryptographic WinAPIs 
results in them being visible in the binary's Import Address Table 
(IAT). Security solutions can detect the use of cryptographic functions 
by scanning the IAT, which can potentially indicate malicious behavior 
or raise suspicion. Hiding WinAPIs in the IAT is possible and will be 
discussed in a future module.</p>
<p>The image below shows the IAT of the binary using Windows APIs for AES encryption. The usage of the <code>crypt.dll</code> library and the cryptographic functions is clearly visible.</p>
<p><img src="Payload%20Encryption%20-%20AES%20Encryption_files/iat-aes.png" alt="image"></p>
<h3>AES Using Tiny-AES Library</h3>
<p>This section makes use of the <a href="https://github.com/kokke/tiny-AES-c" target="_blank">tiny-AES-c</a>
 third-party encryption library that performs AES encryption without the
 use of WinAPIs. Tiny-AES-C is a small portable library that can perform
 AES128/192/256 in C.</p>
<h4>Setting Up Tiny-AES</h4>
<p>To begin using Tiny-AES there are two requirements:</p>
<ol>
<li>
<p>Include <code>aes.hpp</code> (C++) or include <code>aes.h</code> (C) in the project.</p>
</li>
<li>
<p>Add the <code>aes.c</code> file to the project.</p>
</li>
</ol>
<h4>Tiny-AES Library Drawbacks</h4>
<p>Before diving into the code it's important to be aware of the drawbacks of the tiny-AES library.</p>
<ol>
<li>
<p>The library does not support padding. All buffers must be multiples of 16 bytes.</p>
</li>
<li>
<p>The <a href="https://github.com/kokke/tiny-AES-c/blob/master/aes.c#L79" target="_blank">arrays</a>
 used in the library can be signatured by security solutions to detect 
the usage of Tiny-AES. These arrays are used to apply the AES algorithm 
and therefore are a requirement to have in the code. With that being 
said, there are ways to modify their signature in order to avoid 
security solutions detecting the usage of Tiny-AES. One possible 
solution is to XOR these arrays, for example, to decrypt them at runtime
 right before calling the initialization function, <code>AES_init_ctx_iv</code>.</p>
</li>
</ol>
<h4>Custom Padding Function</h4>
<p>The lack of padding support can be solved by creating a custom padding function as shown in the code snippet below.</p>
<pre><code>BOOL PaddBuffer(IN PBYTE InputBuffer, IN SIZE_T InputBufferSize, OUT PBYTE* OutputPaddedBuffer, OUT SIZE_T* OutputPaddedSize) {

	PBYTE	PaddedBuffer        = NULL;
	SIZE_T	PaddedSize          = NULL;

	// calculate the nearest number that is multiple of 16 and saving it to PaddedSize
	PaddedSize = InputBufferSize + 16 - (InputBufferSize % 16);
	// allocating buffer of size "PaddedSize"
	PaddedBuffer = (PBYTE)HeapAlloc(GetProcessHeap(), 0, PaddedSize);
	if (!PaddedBuffer){
		return FALSE;
	}
	// cleaning the allocated buffer
	ZeroMemory(PaddedBuffer, PaddedSize);
	// copying old buffer to new padded buffer
	memcpy(PaddedBuffer, InputBuffer, InputBufferSize);
	//saving results :
	*OutputPaddedBuffer = PaddedBuffer;
	*OutputPaddedSize   = PaddedSize;

	return TRUE;
}
</code></pre>
<h4>Tiny-AES Encryption</h4>
<p>Similar to how the bCrypt library's encryption and decryption process
 was explained earlier in the module, the snippets below explain 
Tiny-AES's encryption and decryption process.</p>
<pre><code>#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;
#include "aes.h"

// "this is plaintext string, we'll try to encrypt... lets hope everything goes well :)" in hex
// since the upper string is 82 byte in size, and 82 is not mulitple of 16, we cant encrypt this directly using tiny-aes
unsigned char Data[] = {
	0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x70, 0x6C, 0x61, 0x6E,
	0x65, 0x20, 0x74, 0x65, 0x78, 0x74, 0x20, 0x73, 0x74, 0x69, 0x6E, 0x67,
	0x2C, 0x20, 0x77, 0x65, 0x27, 0x6C, 0x6C, 0x20, 0x74, 0x72, 0x79, 0x20,
	0x74, 0x6F, 0x20, 0x65, 0x6E, 0x63, 0x72, 0x79, 0x70, 0x74, 0x2E, 0x2E,
	0x2E, 0x20, 0x6C, 0x65, 0x74, 0x73, 0x20, 0x68, 0x6F, 0x70, 0x65, 0x20,
	0x65, 0x76, 0x65, 0x72, 0x79, 0x74, 0x68, 0x69, 0x67, 0x6E, 0x20, 0x67,
	0x6F, 0x20, 0x77, 0x65, 0x6C, 0x6C, 0x20, 0x3A, 0x29, 0x00
};



int main() {
	// struct needed for Tiny-AES library
	struct AES_ctx ctx;


	BYTE pKey[KEYSIZE];                             // KEYSIZE is 32 bytes
	BYTE pIv[IVSIZE;                                // IVSIZE is 16 bytes
		

	srand(time(NULL));                              // the seed to generate the key
	GenerateRandomBytes(pKey, KEYSIZE);             // generating the key bytes
	
	srand(time(NULL) ^ pKey[0]);                    // The seed to generate the IV. Use the first byte of the key to add more randomness.
	GenerateRandomBytes(pIv, IVSIZE);               // Generating the IV

	// Prints both key and IV to the console
	PrintHexData("pKey", pKey, KEYSIZE);
	PrintHexData("pIv", pIv, IVSIZE);

	// Initializing the Tiny-AES Library
	AES_init_ctx_iv(&amp;ctx, pKey, pIv);


	// Initializing variables that will hold the new buffer base address in the case where padding is required and its size
	PBYTE	PaddedBuffer        = NULL;
	SIZE_T	PAddedSize          = NULL;

	// Padding the buffer, if required
	if (sizeof(Data) % 16 != 0){
		PaddBuffer(Data, sizeof(Data), &amp;PaddedBuffer, &amp;PAddedSize);
		// Encrypting the padded buffer instead
		AES_CBC_encrypt_buffer(&amp;ctx, PaddedBuffer, PAddedSize);
		// Printing the encrypted buffer to the console
		PrintHexData("CipherText", PaddedBuffer, PAddedSize);
	}
	// No padding is required, encrypt 'Data' directly
	else {
		AES_CBC_encrypt_buffer(&amp;ctx, Data, sizeof(Data));
		// Printing the encrypted buffer to the console
		PrintHexData("CipherText", Data, sizeof(Data));
	}
	// Freeing PaddedBuffer, if necessary
	if (PaddedBuffer != NULL){
		HeapFree(GetProcessHeap(), 0, PaddedBuffer);
	}
	system("PAUSE");
	return 0;
}

</code></pre>
<h4>Tiny-AES Decryption</h4>
<pre><code>#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;
#include "aes.h"

// Key
unsigned char pKey[] = {
		0xFA, 0x9C, 0x73, 0x6C, 0xF2, 0x3A, 0x47, 0x21, 0x7F, 0xD8, 0xE7, 0x1A, 0x4F, 0x76, 0x1D, 0x84,
		0x2C, 0xCB, 0x98, 0xE3, 0xDC, 0x94, 0xEF, 0x04, 0x46, 0x2D, 0xE3, 0x33, 0xD7, 0x5E, 0xE5, 0xAF };

// IV
unsigned char pIv[] = {
		0xCF, 0x00, 0x86, 0xE1, 0x6D, 0xA2, 0x6B, 0x06, 0xC4, 0x8B, 0x1F, 0xDA, 0xB6, 0xAB, 0x21, 0xF1 };

// Encrypted data, multiples of 16 bytes
unsigned char CipherText[] = {
		0xD8, 0x9C, 0xFE, 0x68, 0x97, 0x71, 0x5E, 0x5E, 0x79, 0x45, 0x3F, 0x05, 0x4B, 0x71, 0xB9, 0x9D,
		0xB2, 0xF3, 0x72, 0xEF, 0xC2, 0x64, 0xB2, 0xE8, 0xD8, 0x36, 0x29, 0x2A, 0x66, 0xEB, 0xAB, 0x80,
		0xE4, 0xDF, 0xF2, 0x3C, 0xEE, 0x53, 0xCF, 0x21, 0x3A, 0x88, 0x2C, 0x59, 0x8C, 0x85, 0x26, 0x79,
		0xF0, 0x04, 0xC2, 0x55, 0xA8, 0xDE, 0xB4, 0x50, 0xEE, 0x00, 0x65, 0xF8, 0xEE, 0x7C, 0x54, 0x98,
		0xEB, 0xA2, 0xD5, 0x21, 0xAA, 0x77, 0x35, 0x97, 0x67, 0x11, 0xCE, 0xB3, 0x53, 0x76, 0x17, 0xA5,
		0x0D, 0xF6, 0xC3, 0x55, 0xBA, 0xCD, 0xCF, 0xD1, 0x1E, 0x8F, 0x10, 0xA5, 0x32, 0x7E, 0xFC, 0xAC };



int main() {

	// Struct needed for Tiny-AES library
	struct AES_ctx ctx;
	// Initializing the Tiny-AES Library
	AES_init_ctx_iv(&amp;ctx, pKey, pIv);

	// Decrypting
	AES_CBC_decrypt_buffer(&amp;ctx, CipherText, sizeof(CipherText));
	 
	// Print the decrypted buffer to the console
	PrintHexData("PlainText", CipherText, sizeof(CipherText));

	// Print the string
	printf("Data: %s \n", CipherText);

	// exit
	system("PAUSE");
	return 0;
}
</code></pre>
<h3>Tiny-AES IAT</h3>
<p>The image below shows a binary's IAT which uses Tiny-AES to perform 
encryption instead of WinAPIs. No cryptographic functions are visible in
 the IAT of the binary.</p>
<p><img src="Payload%20Encryption%20-%20AES%20Encryption_files/iat-no-winapis.png" alt="image"></p>
<h3>Conclusion</h3>
<p>This module explained the basics of AES and provided two working AES 
implementations. One should also have an idea of how security solutions 
will detect the usage of encryption libraries.</p>

            </div></div>
            <div id="accessory-container" class="hidden flex flex-col w-1/4 min-w-1/4 h-full">
                <div id="objectives" class="hidden p-4 border-r border-b bg-gray-900 border-gray-600 font-code w-full h-1/2">
                    <div class="w-full bg-gray-700 text-center mb-4 font-sans text-lg">Objectives</div>
                                                                        
                                                                        
            <div class="flex items-center mb-2 font-sans">
                                <input type="checkbox" id="objective-0" data-objective-id="0" class="flex-none w-4 h-4 text-blue-600 bg-gray-100 rounded border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                                <label class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Understand how AES encryption works</label>
                            </div>
                                                                        
                                                                        
                    <div class="flex items-center mb-2 font-sans">
                                <input type="checkbox" id="objective-1" data-objective-id="1" class="flex-none w-4 h-4 text-blue-600 bg-gray-100 rounded border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                                <label class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Review the provided code</label>
                            </div>
                                                                        
                                                                        
                    <div class="flex items-center mb-2 font-sans">
                                <input type="checkbox" id="objective-2" data-objective-id="2" class="flex-none w-4 h-4 text-blue-600 bg-gray-100 rounded border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                                <label class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Compile and run the code to encrypt and decrypt your shellcode</label>
                            </div>
                                                                        
                                                                        
                    <div class="flex items-center mb-2 font-sans">
                                <input type="checkbox" id="objective-3" data-objective-id="3" class="flex-none w-4 h-4 text-blue-600 bg-gray-100 rounded border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                                <label class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Use Windows APIs to perform AES encryption on your shellcode</label>
                            </div>
                                                                        
                                                                        
                    <div class="flex items-center mb-2 font-sans">
                                <input type="checkbox" id="objective-4" data-objective-id="4" class="flex-none w-4 h-4 text-blue-600 bg-gray-100 rounded border-gray-300 focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                                <label class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Use Tiny-AES library to perform AES encryption on your shellcode</label>
                            </div>
                                                                                  
                </div>
                <div id="ide" class="hidden p-4 border-r border-b border-gray-600 font-code w-full h-1/2">
                    <textarea class="bg-gray-900 outline-0 w-full h-full resize-none font-sans" placeholder="Write temporary notes or code here"></textarea>
                </div>
            </div>  
        </div>
      </div>
      <div class="flex">
        <div class="flex flex-row flex-wrap justify-center items-center w-full bg-gray-700 border-r border-l border-gray-600 pl-4 pt-2 pb-2 rounded-bl rounded-br">
                        <div class="mr-2">
                <a data-target="_self" href="#modules/18"><button class="w-[100px] h-10 px-5 text-sm duration-150 text-white bg-blue-700 hover:bg-blue-800 rounded-lg focus:shadow-outline">Previous</button></a>           
            </div>
                        <div class="mr-2">
                <a data-target="_self" href="#modules"><button class="w-[100px] h-10 px-5 text-sm duration-150 text-white bg-blue-700 hover:bg-blue-800 rounded-lg focus:shadow-outline">Modules</button></a>           
            </div>
            <div class="my-2 mr-2">
            <form id="complete-module" action="#modules/19/complete" method="POST">
                <input type="hidden" name="_token" value="aHzsquahomm2Bo0anbhiCgbZ1siEurCTfma8L6Pk">                <button id="complete-btn" class="w-[100px] h-10 px-5 text-white text-sm duration-150 bg-green-700 rounded-lg focus:shadow-outline hover:bg-green-800 ">Complete</button>
            </form>
            <form id="uncomplete-module" action="#modules/19/progress" method="POST">
                <input type="hidden" name="_token" value="aHzsquahomm2Bo0anbhiCgbZ1siEurCTfma8L6Pk">                <button id="uncomplete-btn" class="w-[100px] h-10 px-5 text-white text-sm duration-150 bg-red-700 rounded-lg focus:shadow-outline hover:bg-red-800 hidden">Undo</button>
            </form>
            </div>
                                    <div class="mr-2">
                <a data-target="_self" href="#modules/20"><button class="w-[100px] h-10 px-5 text-sm duration-150 text-white bg-blue-700 hover:bg-blue-800 rounded-lg focus:shadow-outline">Next</button></a>           
            </div>
                    </div>
    </div>
</div>

<footer id="footer" class="text-gray-400 border-t-[1px] border-gray-700 bg-gray-900 body-font hidden">
    <div class="container px-5 py-8 mx-auto flex items-center sm:flex-row flex-col">
      <p class="text-sm text-gray-400 sm:ml-4 sm:pl-4 sm:border-gray-800 sm:py-2 sm:mt-0 mt-4">© 2023 MalDev Academy</p>
        <a href="#" target="_blank" class="text-gray-500 hover:text-white ml-2">
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true"><path d="M8.29 20.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0022 5.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.072 4.072 0 012.8 9.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.108 0 003.834 2.85A8.233 8.233 0 012 18.407a11.616 11.616 0 006.29 1.84"></path></svg>
        </a>
      <span class="inline-flex sm:ml-auto sm:mt-0 mt-4 justify-center sm:justify-start">
        <a class="text-gray-400 text-sm" href="/" target="_blank">
#      </a></span><a class="text-gray-400 text-sm" href="/" target="_blank">
    </a></div><a class="text-gray-400 text-sm" href="/" target="_blank">
  </a></footer><a class="text-gray-400 text-sm" href="/" target="_blank">        

        <script src="Payload%20Encryption%20-%20AES%20Encryption_files/jquery-3.6.0.min.js"></script>
        <script src="Payload%20Encryption%20-%20AES%20Encryption_files/bootstrap.min.js"></script>
        <link rel="preload" as="style" href="Payload%20Encryption%20-%20AES%20Encryption_files/app.4474f4d1.css"><link rel="modulepreload" href="Payload%20Encryption%20-%20AES%20Encryption_files/app.5f3af5ce.js"><link rel="stylesheet" href="Payload%20Encryption%20-%20AES%20Encryption_files/app.4474f4d1.css"><script type="module" src="Payload%20Encryption%20-%20AES%20Encryption_files/app.5f3af5ce.js"></script><script src="Payload%20Encryption%20-%20AES%20Encryption_files/navbar.js"></script>
<script src="Payload%20Encryption%20-%20AES%20Encryption_files/moduleviewer.js"></script>

 
<script>
$(document).ready(function() {
    $('a:not([data-target="_self"])').attr('target', '_blank');

    $('input[type=checkbox]').change(function() {
    var checked = $(this).is(':checked');
    var userId = 260;
    var moduleId = 19;
    var objectiveId = $(this).data('objective-id');
    $.ajax({
        url: checked ? "#complete/objective" : "#remove/objective",
        type: "POST",
        data: {
        _token: "aHzsquahomm2Bo0anbhiCgbZ1siEurCTfma8L6Pk",
        user_id: userId,
        module_id: moduleId,
        objective_id: objectiveId
        },
        success: function(response) {

        },
        error: function(xhr) {
        console.log('Error');
        }
    });
    });

    $('#complete-module').submit(function(event) {
    event.preventDefault(); // Prevent default form submission

    var form = $(this);
    var url = form.attr('action');
    var data = form.serialize();
    var completeBtn = form.find('#complete-btn');
    var uncompleteBtn = $('#uncomplete-btn');

    $.ajax({
        type: 'POST',
        url: url,
        data: data,
        success: function(response) {
            completeBtn.addClass('hidden');
            uncompleteBtn.removeClass('hidden');
        },
        error: function(xhr) {
            console.log('Error');
        }
    });
});

$('#uncomplete-module').submit(function(event) {
    event.preventDefault(); // Prevent default form submission

    var form = $(this);
    var url = form.attr('action');
    var data = form.serialize();
    var completeBtn = $('#complete-btn');
    var uncompleteBtn = form.find('#uncomplete-btn');

    $.ajax({
        type: 'POST',
        url: url,
        data: data,
        success: function(response) {
            uncompleteBtn.addClass('hidden');
            completeBtn.removeClass('hidden');
        },
        error: function(xhr) {
            console.log('Error');
        }
    });
});
});
</script>
    
</a></body></html>